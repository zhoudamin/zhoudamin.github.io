---
title: Java基础-1
字数统计: WordCount
阅读时长预计: Min2Read
总字数统计: TotalCount
date: 2017-08-07 15:54:27
categories: Java
tags: 基础
---

Java基本功

![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=855083503,1162680843&fm=26&gp=0.jpg)
<!--more-->

# Java是否存在内存泄露

内存泄露是指一个不再被程序使用的对象或变量还在内存中占有存储空间。

如果开发人员忘记释放已分配的内存就会造成内存泄露。

在Java中，判断一个内存空间是否符合垃圾回收机制标准有两个：

1. 给对象赋予了null，以后再没使用过
2. 给对象赋予了新值，重新分配了内存空间

内存泄露主要有两种情况：

1. 在堆中申请的空间没有被释放
2. 对象已经不再使用，但还是在内存中保留着

Java中的垃圾回收机制可以解决情况1，所以内存泄露主要是情况2

在Java中，引起内存泄露的主要原因有：

1. 静态集合类
2. 各种连接，如数据库连接、网络联结以及IO连接等
3. 监听器
4. 变量不合理的作用域
5. 单例模式可能会造成内存泄露

***

# Java中的堆和栈有什么区别

堆和栈都是内存中存放数据的地方

堆主要用来存放对象，栈用来执行程序

栈的存取速度比堆快

堆可以在运行中动态的分配内存

当main()方法退出后，栈中的变量会被回收

---

# Java Collections 框架是什么

Java Collections框架中包含了大量集合接口、这些接口的实现类、操作他们的算法。

## Set

表示数学意义上的集合概念。特点是集合中的元素不能重复

HashSet

TreeSet ：容器中的元素是有序的

## List

又称为有序的Collection。

按对象进入的顺序保存对象，多以它能对列表中的每个元素的插入和删除位置进行精准的控制。

同时，它可以保存重复的对象。

## Map

提供了一个从键映射到值的数据结构。它用于保存键值对，其中值可以重复，键是唯一的。

HashMap 是基于散列表实现的，采用对象 HashCode 可以进行快速查询。

LinkedHashMap 采用列表来维护内部的顺序。

TreeMap 基于红黑树的数据结构来实现的，内部元素是按需排列的。

---

# cookie和session区别

1. cookie保存在客户端，数据存放在客户的浏览器上；session机制采取保存在服务器端的方案，数据存放在服务器上。
2. cookie安全性不够，session信息存放在服务器，因此较为安全。
3. cookie性能更高
4. 单个cookie保存的数据大小不能超过4 KB，而session不存在这个问题。


---

# Hibernate优点

1. 提高开发效率
2. 可以完全采用面向对象的思想，不需要关心数据库的关系模型
3. 有很好的移植性
4. 支持透明持久化

---



# 使用Hibernate提高性能

1. 延迟加载
2. 缓存技术
3. 优化查询语句

---

# 分页机制

当数据量很大时，如果一次性的把数据取出来，不仅浪费时间，还消耗大量的内存

采用分页机制使得查询的结果集中数据量减少了，同时也降低了内存的消耗，因此可以显著降低响应时间，有助于提高系统的可用性，增强用户体验。

方法：

1. 框架自带分页机制
2. SQL语句实现分页

---

# GC

自动检测对象的作用域，自动的把不再被使用的存储空间释放掉。

**作用**

* 分配内存
* 确保被引用的对象不被错误的回收
* 回收不再被引用的对象的内存空间


---



# 垃圾回收算法

1. 引用计数法：缺点是无法处理循环引用问题
2. 标记-清除法：标记所有从根节点开始的可达对象，缺点是会造成内存空间不连续，不连续的内存空间的工作效率低于连续的内存空间
3. 复制算法：将内存空间分成两块，每次将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块。适用于新生代（存活对象少，垃圾对象多）
4. 标记-压缩算法：清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清除边界所有空间。适用于老年代。
5. 分代

---

# 死锁

当线程需要持有多个锁时，就有可能产生死锁。

线程A当前持有互斥锁lock1，线程B当前持有互斥锁lock2。

A想要lock2，B也想要lock1，互相试图获取对方的，又不肯先释放自己的，就陷入了无尽的等待/阻塞。

这种情况成为死锁。

---


# ArrayList、Vector、LinkedList区别

| 容器         | 动态    | 扩充大小 | 同步？      | 安全？    | 效率                           |
| ---------- | ----- | ---- | -------- | ------ | ---------------------------- |
| ArrayList  | 可伸缩数组 | 1.5倍 | 非同步      | 不是线程安全 | 索引or在末端增删元素效率高               |
| Vector     | 可伸缩数组 | 2倍   | 绝大多数方法同步 | 线程安全   | 索引or在末端增删元素效率高、多线程           |
| LinkedList | 可伸缩数组 |      |          | 非线程安全  | 双向列表实现，插入数据高，指定位置插入or删除元素效率高 |

---

# 排序算法对比

| 排序算法   | 最好时间       | 平均时间       | 最坏时间            | 辅助存储      | 稳定性  | 备注        |
| ------ | ---------- | ---------- | --------------- | --------- | ---- | --------- |
| 简单选择排序 | $O（n^2）$   | $O（n^2）$   | $O（n^2）$        | $O（1）$    | 不稳定  | n小时较好     |
| 直接插入排序 | $O（n）$     | $O（n^2）$   | $O（n^2）$        | $O（1）$    | 稳定   | 大部分已有序时较好 |
| 冒泡排序   | $O（n）$     | $O（n^2）$   | $O（n^2）$        | $O（1）$    | 稳定   | n小时较好     |
| 希尔排序   | $O（n）$     | $O（nlogn）$ | $O（n^s）(1<s<2)$ | $O（1）$    | 不稳定  | s是所选分组    |
| 快速排序   | $O（nlogn）$ | $O（nlogn）$ | $O（n^2）$        | $O（logn）$ | 不稳定  | n大时较好     |
| 堆排序    | $O（nlogn）$ | $O（nlogn）$ | $O（nlogn）$      | $O（1）$    | 不稳定  | n大时较好     |
| 归并排序   | $O（nlogn）$ | $O（nlogn）$ | $O（nlogn）$      | $O（n）$    | 稳定   | n大时较好     |



---

# 什么是值传递和引用传递

* 值传递：方法调用时，实参会把它的值传递给形参，形参用实参的值初始化一个临时的存储单元，因此值一样，存储单元不一样，形参的改变不会影响实参。
* 引用传递：在方法调用时，传递的是对象，形参与实参指向同一块存储单元，对形参的改变就会改变实参。

---

# 面向对象的三个基本元素

1. 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 
2. 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。  
3. 多态： 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。

---

# 是否可以主动通知JVM进行垃圾回收？

由于垃圾回收器的存在，Java语言没有提供给开发人员释放已分配内存的方法，开发人员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。

但是开发可以调用System.gc()方法来“通知”垃圾回收器运行，当然，JVM也不会马上运行。



---

# Java中堆和栈的区别

1. 栈内存主要用来存放基本数据类型和引用变量；堆内存用来存放运行时创建的对象
2. 堆主要用来存放对象，栈主要用来执行程序

---





---



# 线程状态有哪些，它们之间是如何转换的

1. New（新建）：刚创建，还没调用start方法
2. Runnable（可运行）：可以在Java虚拟机中运行的状态
3. Blocked（被阻塞）：当一个线程获取其他线程的内部对象锁而不得
4. Waiting（等待）：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态
5. Timed waiting（计时等待）：有超时参数的方法会让线程进入计时等待，如果超时或者出现通知，会切换到可运行状态
6. Terminated（被终止）：因为run方法正常退出或因为没有捕获的异常终止了run方法而死亡



![](http://upload-images.jianshu.io/upload_images/44770-698ba70a7a713f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

---



# 线程与进程的区别，各有什么优缺点

线程：是指程序在执行过程中，能够执行程序代码的一个执行单元。4个状态：运行，就绪，挂起，结束。

进程：是指一段正在执行的程序。

创建一个线程比创建一个进程所要的资源少。

---

# 当你在浏览器输入一个网址，如http://www.taobao.com，按回车之后发生了什么？

请从技术的角度描述，如浏览器、网络（UDP、TCP、HTTP等），以及服务器等各种参与对象上由此引发的一系列活动，请尽可能的涉及到所有的关键技术点。

```markdown
1.DNS域名解析：浏览器缓存、系统缓存、路由器、ISP的DNS服务器、根域名服务器。把域名转化成IP地址。 

2.与IP地址对应的服务器建立TCP连接，经历三次握手：SYN，ACK、SYN，ACK 

3.以get，post方式发送HTTP请求，get方式发送主机，用户代理，connection属性，cookie等 

4.获得服务器的响应，显示页面

-----------------------------------------------------------

1 查缓存

2 DNS解析

3 获取ip

4 建立tcp连接

5 发http数据

6 接受http数据并解析

7 close

-------------------------------------------------------------------

1、根据域名查询域名的IP。浏览器缓存->操作系统缓存->本地域名服务器缓存->域名服务器。

2、得到IP后发起基于TCP的HTTP请求。如果浏览器存储了该域名下的cookie，那么会把cookie放入HTTP请求头里。

3、TCP被包装为IP包，通过网络（可能经过很多路由器、交换机）发送到IP地址对应的服务器。这个服务器可能只是一个反向代理服务器，如果是，则HTTP请求被转交给内网中真实的某一个服务器（可能有多个服务器）。

4、服务器分析HTTP请求，生成HTTP响应（可能是HTML、图片等）后，将响应发送给客户端浏览器。

5、浏览器得到响应后，根据响应内容显示结果。如果响应的是图片，则将图片”画“在浏览器页面上；如果是HTML，则渲染HTML并”画“在浏览器页面上，在分析HTML时，若发现引用了其他资源，例如css、图片等，则发起HTTP请求，得到响应资源。

```



---

#  linux中cat、more、less命令区别

均可用来查看文件内容

|  命令  | 区别                                       | 功能对比 |
| :--: | :--------------------------------------- | ---- |
| cat  | 一次性显示整个文件的内容，还可以将多个文件连接起来显示，常与重定向符号配合使用，适用于文件内容少的情况 | 一般   |
| more | 一般用于显示文件内容超过一屏的内容，提供翻页的功能。提供分页显示。        | 强    |
| less | 一般用于显示文件内容超过一屏的内容，提供翻页的功能。翻页、跳转、查找。      | 更强   |



---



* 索引的作用及代价？如何建好索引？索引的原理
* Hash算法
* 算法：二分查找算法，冒泡排序、选择排序算法、插入排序、归并、希尔、快排算法
* 锁：乐观锁和悲观锁
* 什么情况下会产生死锁？如何避免死锁？
* JVM GC：介绍垃圾回收机制，垃圾回收算法。
* JAVA的反射机制
* Java集合类有哪些，分别在哪些场景使用
* Linux下如何快速查找某个文件
* Linux下如何设置环境变量


---

# Linux下如何查看TCP连接状态

```shell
LISTEN：          侦听来自远方的TCP端口的连接请求  listen
 
SYN-SENT：    再发送连接请求后等待匹配的连接请求     syn-sent

SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认  syn-received

ESTABLISHED： 代表一个打开的连接

FIN-WAIT-1：  等待远程TCP连接中断请求，或先前的连接中断请求的确认

FIN-WAIT-2：  从远程TCP等待连接中断请求

CLOSE-WAIT：  等待从本地用户发来的连接中断请求

CLOSING：     等待远程TCP对连接中断的确认

LAST-ACK：    等待原来的发向远程TCP的连接中断请求的确认

TIME-WAIT：   等待足够的时间以确保远程TCP接收到连接中断请求的确认

CLOSED：      没有任何连接状态

```















* 简述一次HTTP请求的基本流程
* 什么是JDBC，为什么需要什么是JDBC？实现原理是什么？
* Get和Post的区别
* Cookie和Session的区别，分别用于什么场景
* 为什么需要编码？UTF-8和GBK是如何进行编码的
* 分别介绍下JDK，JRE和JVM









1. HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别





1. 索引有什么用？如何建索引？
2. ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。
3. equals方法实现
4. 面向对象
5. 线程状态，BLOCKED和WAITING有什么区别
6. JVM如何加载字节码文件
7. JVM GC，GC算法。
8. 什么情况会出现Full GC，什么情况会出现yong GC。




# JVM内存模型

Java内存模型，指Java程序在运行时内存的模型，而Java代码运行在Java虚拟机上，所以也就指Java虚拟机的运行时内存模型。












1. Java运行时数据区
2. 事务的实现原理



## 技术深度

 

1. 有没有看过JDK源码，看过的类实现原理是什么。
2. HTTP协议
3. TCP协议
4. 一致性Hash算法
5. JVM如何加载字节码文件
6. 类加载器如何卸载字节码
7. IO和NIO的区别，NIO优点
8. Java线程池的实现原理，keepAliveTime等参数的作用。
9. HTTP连接池实现原理
10. 数据库连接池实现原理
11. 数据库的实现原理



## 技术框架

 

1. 看过哪些开源框架的源码
2. 为什么要用Redis，Redis有哪些优缺点？Redis如何实现扩容？
3. Netty是如何使用线程池的，为什么这么使用
4. 为什么要使用Spring，Spring的优缺点有哪些
5. Spring的IOC容器初始化流程
6. Spring的IOC容器实现原理，为什么可以通过byName和ByType找到Bean
7. Spring AOP实现原理
8. 消息中间件是如何实现的，技术难点有哪些



## 系统架构

 

1. 如何搭建一个高可用系统
2. 哪些设计模式可以增加系统的可扩展性
3. 介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。
4. 抽象能力，怎么提高研发效率。
5. 什么是高内聚低耦合，请举例子如何实现
6. 什么情况用接口，什么情况用消息
7. 如果AB两个系统互相依赖，如何解除依赖
8. 如何写一篇设计文档，目录是什么
9. 什么场景应该拆分系统，什么场景应该合并系统
10. 系统和模块的区别，分别在什么场景下使用



## 分布式系统

 

1. 分布式事务，两阶段提交。
2. 如何实现分布式锁
3. 如何实现分布式Session
4. 如何保证消息的一致性
5. 负载均衡
6. 正向代理（客户端代理）和反向代理（服务器端代理）
7. CDN实现原理
8. 怎么提升系统的QPS和吞吐量



## 实战能力

 

1. 有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。
2. 开发中有没有遇到什么技术问题？如何解决的
3. 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。
4. 新浪微博是如何实现把微博推给订阅者
5. Google是如何在一秒内把搜索结果返回给用户的。
6. 12306网站的订票系统如何实现，如何保证不会票不被超卖。
7. 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。



## 软能力

 

1. 如何学习一项新技术，比如如何学习Java的，重点学习什么
2. 有关注哪些新的技术
3. 工作任务非常多非常杂时如何处理
4. 项目出现延迟如何处理
5. 和同事的设计思路不一样怎么处理
6. 如何保证开发质量
7. 职业规划是什么？短期，长期目标是什么
8. 团队的规划是什么
9. 能介绍下从工作到现在自己的成长在那里






---



# 基础概念

1. 多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改为同步。
2. 并发：在 [操作系统 ](http://baike.baidu.com/view/880.htm)中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个 [处理机 ](http://baike.baidu.com/view/2107226.htm)上运行。其中两种并发关系分别是同步和互斥
3. 互斥：进程间相互排斥的使用临界资源的现象，就叫互斥。
4. 同步： 进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。
5. 其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。 
6. 并行：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。
7. 多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。
8. 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。
9. 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。
10. constructor在一个对象被new时执行
11. @java中关于继承的描述：一个子类只能继承一个父类;  继承具有传递性;父类一般具有通用性，子类更具体。
12. 当一个对象不再被引用后就成为垃圾可以被回收，但是线程就算没有被引用也可以独立运行的。



![](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2077281022,811568533&fm=26&gp=0.jpg)