---
title: 面经-阿里1
字数统计: WordCount
阅读时长预计: Min2Read
总字数统计: TotalCount
date: 2017-07-20 10:10:20
categories: 面经
tags: 
	- 阿里
	- Java
	- 笔试
---
阿里面经总结，查漏补缺~
![](http://img.yqdown.com/img2016/1/20/2016012070632345.jpg)
<!--more-->

# Java基础：

## 面向对象和面向过程的区别
面向过程就像一个细心的管家，什么事情都要考虑到；
而面向对象就像家用电器，只需要知道他的功能，不用知道工作原理。
面向过程是一种以事件为中心的编程思想，分析出解决问题所需要的步骤，然后用函数将这些步骤实现，并按顺序调用；
面向对象是以对象为中心的编程思想。
eg:汽车发动，汽车到站
对面向过程来说，这是两个事件，关心的是事件，不是汽车本身，写两个事件函数，分别调用；


## Java的四个基本特性（抽象、封装、继承，多态）
抽象：
抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。
抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

封装：
通常认为封装就是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装，我们编写一个类就是对数据和数据操作的封装。
可以说，封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。

继承：继承是从已有类得到继承信息创建新类的过程。
提供继承信息的类被称为父类(超类、基类)；得到继承信息的类被称为子类(派生类)。
继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。

多态：
多态是指允许不同子类型的对象对同一消息作出不同的响应。

## 多态的理解(实现方法)
### Overload和Override的区别
方法重载--Overload：
实现的是编译时的多态性(也称为前绑定)。

方法重写--Override：
实现的是运行时的多态性(也称为后绑定)。运行时的多态是面向对象最精髓的东西。

### 要实现多态需要做两件事：
1.方法重写
子类继承父类并重写父类中已有的或抽象的方法
2.对象造型
用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为。

### 项目中对多态的应用
举个栗子，在实验室信息管理系统中，有两种用户，教师和学生，两个用户都可以登陆系统，他们有相同的方法Login，但登陆之后他们会进入不同的页面，也就是在登陆时会有不同的操作，两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。

4. 构造器Constructor是否可被override

5. 访问控制符public,protected,private,以及默认的区别

6. 是否可以继承String类

7. String和StringBuffer、StringBuilder的区别

8. hashCode和equals方法的关系

9. 抽象类和接口的区别

10. 自动装箱与拆箱

11. 什么是泛型、为什么要使用以及泛型擦除

12. Java中的集合类及关系图

13. HashMap实现原理(看源代码)

14. HashTable实现原理(看源代码)

## HashMap和HashTable区别
HashTable的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap；
HashTable不允许null值(key 和 value都不可以)，HashMap允许null值(key 和 value 都可以)；
两者的遍历方式大同小异，HashTable仅仅比HashMap多一个elements方法；

HashTable和HashMap都能通过values()方法返回一个Collection，然后进行遍历处理，两者也都可以通过entrySet()方法返回一个Set，然后进行遍历处理。

HashTable使用Enumeration，HashMap使用Iterator。

哈希值的使用不同，HashTable直接使用对象的HashCode，HashMap重新计算hash值，而且用于代替求模；
HashTable中hash数组默认大小是11，增加的方式是old*2+1，HashMap中hash数组的默认大小是16，而且一定是2的指数；
HashTable基于Dictionary，而HashMap基于AbstractMap类。


16. HashTable如何实现线程安全(看源代码)

17. ArrayList和vector区别(看源代码)

18. ArrayList和LinkedList区别及使用场景

19. Collection和Collections的区别

20. Concurrenthashmap实现原理(看源代码)

21. Error、Exception区别

22. Unchecked Exception和Checked Exception，各列举几个

23. Java中如何实现代理机制(JDK、CGLIB)

24. 多线程的实现方式

25. 线程的状态转换

26. 如何停止一个线程

## 什么是线程安全
某个类的行为与其规范一致；
不管多个线程是怎样的执行顺序和优先级，或是wait，sleep，join等控制方式，如果一个类在多线程访问下运转一切正常，并且访问类不需要进行额外的同步处理或协调，那么我们认为它是线程安全的。

## 如何保证线程安全
对变量使用volitate
对程序段进行加锁(synchronized,lock)

29. Synchronized如何使用

30. synchronized和Lock的区别

31. 多线程如何进行信息交互

32. sleep和wait的区别(考察的方向是是否会释放锁)

33. 多线程与死锁

34. 如何才能产生死锁

35. 什么叫守护线程，用什么方法实现守护线程

## Java线程池技术及原理
线程池就是事先创建若干个可执行的线程放入一个池(容器)中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。


37. java并发包concurrent及常用的类

38. volatile关键字

39. Java中的NIO，BIO，AIO分别是什么

40. IO和NIO区别

41. 序列化与反序列化

42. 常见的序列化协议有哪些

43. 内存溢出和内存泄漏的区别

44. Java内存模型及各个区域的OOM，如何重现OOM

45. 出现OOM如何解决

46. 用什么工具可以查出内存泄漏

47. Java内存管理及回收算法

48. Java类加载器及如何加载类(双亲委派)

49. xml解析方式

50. Statement和PreparedStatement之间的区别


# JavaEE:

## servlet生命周期及各个方法
①实例化阶段：服务器对Servlet进行实例化，调用Servlet的构造方法
②初始化阶段：服务器调用Servlet的init方法进行初始化（只在第一次请求时调用）。
③请求处理阶段：服务器调用Servlet的service方法，然后根据请求方式调用相应的doXXX方法。
④服务终止阶段：服务器调用Servlet的destroy方法销毁Servlet实例


2. servlet中如何自定义filter

3. JSP原理

4. JSP和Servlet的区别

5. JSP的动态include和静态include

6. Struts中请求处理过程

7. MVC概念

8.Spring mvc与Struts区别

9. Hibernate/Ibatis两者的区别

10. Hibernate一级和二级缓存

11. Hibernate实现集群部署

12. Hibernate如何实现声明式事务

13. 简述Hibernate常见优化策略

14. Spring bean的加载过程(推荐看Spring的源码)

15. Spring如何实现AOP和IOC

16. Spring bean注入方式

17. Spring的事务管理(推荐看Spring的源码)

18. Spring事务的传播特性

19. springmvc原理

20. springmvc用过哪些注解

21. Restful有几种请求

22. Restful好处

23. Tomcat，Apache，JBoss的区别

24. memcached和redis的区别

25. 有没有遇到中文乱码问题，如何解决的

26. 如何理解分布式锁

27. 你知道的开源协议有哪些

28. json和xml区别


# 设计模式：

## 设计模式的六大原则
1. 单一职责原则
  定义：不要存在多于一个导致类变更的原因。即一个类只负责一项职责。

2. 里氏替换原则

3. 依赖倒置原则

4. 接口隔离原则

5. 迪米特法则

6. 开闭原则




## 常用的设计模式

3. 用一个设计模式写一段代码或画出一个设计模式的UML

4. 如何理解MVC

## 高内聚，低耦合方面的理解
内聚性又称快内联系，指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。
若一个模块内各元素联系的越紧密，则它的内聚性就越高。
耦合性也称块间联系，指软件系统结构中各模块间相互紧密程度的一种度量。模块间联系越紧密，其耦合性就越强。
将软件系统化分模块时，尽量做到高内聚低耦合，提高模块的独立性。
有个例子很容易明白：一个程序有50个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他49个函数都需要做修改，这就是高耦合的后果。
一旦你理解了它，你编写概要设计的时候设计类或者模块自然会考虑到“高内聚，低耦合”。


# 算法：

1. 深度优先、广度优先算法

2. 排序算法及对应的时间复杂度和空间复杂度

3. 写一个排序算法

4. 查找算法

5. B+树和二叉树查找时间复杂度

6. KMP算法、hash算法

7. 常用的hash算法有哪些

8. 如何判断一个单链表是否有环？

9. 给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少？

10. 给你一个数组，如何里面找到和为K的两个数？

11. 100000个数找出最小或最大的10个？

12. 一堆数字里面继续去重，要怎么处理？


# 数据结构：

1. 队列、栈、链表、树、堆、图

2. 编码实现队列、栈


# Linux:

## linux常用命令
1. cd命令：切换目录
2. ls命令：查看文件与目录
3. grep命令：分析一行的信息
4. find命令：查找
5. cp命令：copy，复制文件
6. mv命令：move ，移动文件，目录或更名
7. rm命令: 该命令用于删除文件或目录，remove
8. ps命令: 该命令用于将某个时间点的进程运行情况选取下来并输出，process之意
9. kill命令: 该命令用于向某个工作或者是某个PID（数字）传送一个信号
10. killall命令: 该命令用于向一个命令启动的进程发送一个信号
11. file命令: 该命令用于判断接在file命令后的文件的基本数据
12. tar命令: 该命令用于对文件进行打包
13. cat命令: 该命令用于查看文本文件的内容，后接要查看的文件名
14. chgrp命令: 该命令用于改变文件所属用户组
15. chown命令: 该命令用于改变文件的所有者
16. chmod命令: 该命令用于改变文件的权限
17. vim命令: 该命令主要用于文本编辑，它接一个或多个文件名作为参数
18. gcc命令: 对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序
19. time命令: 该命令用于测算一个命令（即程序）的执行时间

## 如何查看内存使用情况

3. Linux下如何进行进程调度


# 操作系统：

1. 操作系统什么情况下会死锁

2. 产生死锁的必要条件

3. 死锁预防


# 数据库：

1. 范式

2. 数据库事务隔离级别

3. 数据库连接池的原理

4. 乐观锁和悲观锁

5. 如何实现不同数据库的数据查询分页

6. SQL注入的原理，如何预防

7. 数据库索引的实现(B+树介绍、和B树、R树区别)

8. SQL性能优化

9. 数据库索引的优缺点以及什么时候数据库索引失效

10.Redis的存储结构


# 网络：

1. OSI七层模型以及TCP/IP四层模型

2. HTTP和HTTPS区别

3. HTTP报文内容

4. get提交和post提交的区别

5. get提交是否有字节限制，如果有是在哪限制的

6. TCP的三次握手和四次挥手

7. session和cookie的区别

8. HTTP请求中Session实现原理

9. redirect与forward区别

10.DNS

11. TCP和UDP区别


# 安全：

1. 如果客户端不断的发送请求连接会怎样

2. DDos攻击

3. DDos预防

4. 那怎么知道连接是恶意的呢？可能是正常连接


# 其它：

1. 说一个你参与的项目、其中作为什么角色

2. 遇到最困的问题是什么，怎么解决的

3. 你认为自己有那些方面不足

4. 平常如何学习的

5. 如何评价自己


# 智力题：

1. 给你50个红球和50个黑球，有两个一模一样的桶，往桶里放球，让朋友去随机抽，采用什么策略可以让朋友抽到红球的概率更高？

2. 从100个硬币中找出最轻的那个假币？

```
Java代码实现
```
<br/>

![](http://img3.duitang.com/uploads/item/201504/20/20150420H3518_PZH2i.jpeg)