<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zhoudamin.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="收集的findbugs清理指导！">
<meta property="og:type" content="article">
<meta property="og:title" content="findbugs clean">
<meta property="og:url" content="http://www.zhoudamin.com/2020/05/13/findbugs-clean/index.html">
<meta property="og:site_name" content="Notes">
<meta property="og:description" content="收集的findbugs清理指导！">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-13T13:57:43.000Z">
<meta property="article:modified_time" content="2020-05-13T14:12:00.308Z">
<meta property="article:author" content="Damin ZHOU">
<meta property="article:tag" content="findbugs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.zhoudamin.com/2020/05/13/findbugs-clean/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>findbugs clean | Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Notes" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Learn Practice Summary</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.zhoudamin.com/2020/05/13/findbugs-clean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Damin ZHOU">
      <meta itemprop="description" content="Goals determine <br/> what you are going to be .">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          findbugs clean
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-13 21:57:43 / 修改时间：22:12:00" itemprop="dateCreated datePublished" datetime="2020-05-13T21:57:43+08:00">2020-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/" itemprop="url" rel="index"><span itemprop="name">开发者手册</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>收集的findbugs清理指导！</p>
<a id="more"></a>

<p>1、Bug: Hard coded reference to an absolute pathname<br>BUG描述：This code constructs a File object using a hard coded to an absolute pathname（此代码包含文件对象为一个绝对路径名）</p>
<p>问题原因：硬编码指向绝对路径。</p>
<p>File preFile = new File(PREFERENCES_FILE_FULL_PATH);</p>
<p>而private static final String PREFERENCES_FILE_FULL_PATH =</p>
<pre><code>    "/data/data/com.android.mms/shared_prefs/auto_downLoad.xml";</code></pre><p>PREFERENCES_FILE_FULL_PATH声明为了final型，不可变的。如果后续文件路径有变更，引用不到了，但路径又不可更改，就会引入问题。</p>
<p>解决方法：去掉final。</p>
<p>2、Bug: Pattern: Dead store to local variable</p>
<p>BUG描述：This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. （该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。）</p>
<p>问题原因：锁屏中提示Dead store to velocityX，分析代码</p>
<p>case MotionEvent.ACTION_POINTER_1_UP语句中定义了局部变量velocityX，并且只在if ((mDirectionFlag &amp;&amp; velocityX &gt; 0)||(!mDirectionFlag &amp;&amp; velocityX &lt; 0))</p>
<pre><code>                velocityX = -velocityX;中赋值后并未再使用。因此没有赋值的必要，并且分析代码不需要该变量，可以去除。</code></pre><p>解决方法：去掉velocityX变量的定义及赋值。</p>
<p>3、BUG: Inconsistent synchronization<br>BUG描述：The fields of this class appear to be accessed inconsistently with respect to synchronization. （不合理的同步）</p>
<p>问题原因：根据描述ConfigLoader文件中mUnlockAppDataMap在46%的时间内都是处于被锁状态。分析代码mUnlockAppDataMap是在checkUnlockAppConfigChange这个函数中被锁的。而该方法public synchronized boolean checkUnlockAppConfigChange(Context context)没有地方调用。</p>
<p>解决方法：去掉synchronized关键字。</p>
<p>4、BUG: Incorrect lazy initialization of static field</p>
<p>BUG描述：This method contains an unsynchronized lazy initialization of a non-volatile static field. Because the compiler or processor may reorder instructions, threads are not guaranteed to see a completely initialized object, if the method can be called by multiple threads.（这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。）</p>
<p>问题原因：sInstance 是static型，clean()方法可能被多个线程调用，在sInstance判断为非空后，再清空置null时可能会有问题。</p>
<p>解决方法：给clean()加上关键字synchronized .public static synchronized void clean()</p>
<p>5、BUG: Redundant nullcheck of value known to be non-null</p>
<p>BUG描述：This method contains a redundant check of a known non-null value against the constant null.(方法中对不为空的值进行为空的判断。)</p>
<p>问题原因：分析findbugs报错的这段代码</p>
<p>if(mInputStream == null){</p>
<p>Log.i(TAG , “ mInputStream is null “);</p>
<p>return;</p>
<p>}</p>
<p>mDBuilder = mDBuilderFactory.newDocumentBuilder();</p>
<p>if(mInputStream != null) {</p>
<p>mDocument = mDBuilder.parse(mInputStream);</p>
<p>}else {</p>
<p>Log.i(TAG , “mInputStream ==  null”);</p>
<p>return;</p>
<p>}</p>
<p>mInputStream若为null，则直接返回。后面不需要再有if(mInputStream != null)的判断。</p>
<p>解决方法：在mInputStream判空后不再重复判空，将后面if判断中的mInputStream改为mDBuilder。</p>
<p>6、BUG: Should be a static inner class</p>
<p>BUG描述：This class is an inner class, but does not use its embedded reference to the object which created it.  This reference makes the instances of the class larger, and may keep the reference to the creator object alive longer than necessary.  If possible, the class should be made static.（若成员类中未访问外围类的非静态成员，为避免额外的空间和时间开销，建议改用静态成员类。）</p>
<p>问题原因：非静态成员类和静态成员类的区别在于，非静态成员类是对象的，静态成员类是类的。非静态成员类可以访问外围类的任何成员，但前提是必须存在外围类对象。JAVA需要额外维护非静态成员类和外围类对象的关系。分析代码private class IccText和private class MediaMetadata {没有访问到外围类的非静态成员，所以findbugs建议将其设为static型。</p>
<p>解决方法：将这2个内部类改为static型。</p>
<p>7、BUG: Switch statement found where one case falls through to the next case<br>BUG描述：This method contains a switch statement where one case branch will fall through to the next case. Usually you need to end this case with a break or return.（Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break或者return语句来跳出。）</p>
<p>问题原因：case MotionEvent.ACTION_UP执行完之后没有break，会继续走case MotionEvent.ACTION_CANCEL分支。分析代码逻辑，手指抬起后，锁屏图标需要回到初始位置，而回到初始位置的逻辑是在ACTION_CANCEL里做的。即ACTION_UP后的逻辑还需要ACTION_CANCEL里面的逻辑。</p>
<p>解决方法：将ACTION_CANCEL中的逻辑拉出来做成一个函数，ACTION_UP逻辑后调用这个函数后再做break操作。</p>
<p>8、BUG: Unread field<br>BUG描述：This field is never read.  Consider removing it from the class.（类中定义的属性从未被调用，建议删除。）</p>
<p>问题原因：在类中定义了成员变量private HwViewProperty mCondition = null;代码中只有赋值操作mCondition = new HwViewProperty(mContext,value, ViewPropertyType.TYPE_CONDITION, mCallback);但没有使用这个变量mCondition的地方。</p>
<p>解决方法：去掉mCondition的定义及赋值语句。但需注意，mCondition = new HwViewProperty(mContext,value, ViewPropertyType.TYPE_CONDITION, mCallback);赋值中，虽然mCondition变量后续没有使用到，但new HwViewProperty对象调用HwViewProperty的构造方法时，其实是做了功能操作的。因此，去掉mCondition，但需要保留new HwViewProperty(mContext,value, ViewPropertyType.TYPE_CONDITION, mCallback);</p>
<p>9、BUG: Write to static field from instance method<br>BUG描述：This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.（实例方法直接写静态变量。）</p>
<p>问题原因：sInstance是类的静态成员变量，非静态方法unregisterCallbaks直接对其赋值，非静态方法是与对象相关联的，当多个对象同时对该变量进行赋值时可能出现问题。</p>
<p>解决方法：在使用静态成员变量时使用get和set方法。</p>
<p>May expose internal representation by incorporating reference to mutable object<br>分析<br>主要是针对Date类的get/set方法，涉及了深拷贝和浅拷贝的问题。<br>解决方法：<br>public Date getCreateDate() {<br>       return (Date) createDate.clone();<br>   }</p>
<p>   public void setCreateDate(Date createDate) {<br>       this.createDate = (Date) createDate.clone();<br>   }</p>
<p>Write to static field from instance method<br>原因：在其他类对static属性进行直接修改<br>解决方法：将static属性设置为private或者protected形式，使用set/get方法进行修改和获取。</p>
<p>Field should be package protected<br>A mutable static field could be changed by malicious code or by accident. The field could be made package protected to avoid this vulnerability.</p>
<p>一、Security 关于代码安全性防护</p>
<p>DMI_CONSTANT_DB_PASSWORD<br>代码中创建DB的密码时采用了写死的密码。</p>
<p>DMI_EMPTY_DB_PASSWORD<br>创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。</p>
<p>HRS_REQUEST_PARAMETER_TO_COOKIE<br>此代码使用不受信任的HTTP参数构造一个HTTP Cookie。</p>
<p>HRS_REQUEST_PARAMETER_TO_HTTP_HEADER<br>在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。</p>
<p>SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE<br>该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。</p>
<p>XSS_REQUEST_PARAMETER_TO_JSP_WRITER<br>在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。</p>
<p>二、Experimental 关于代码实验性问题<br>LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE<br>OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：</p>
<p>public static void initLogging() throws Exception {</p>
<p> Logger logger = Logger.getLogger(“edu.umd.cs”);</p>
<p> logger.addHandler(new FileHandler()); // call to change logger configuration</p>
<p> logger.setUseParentHandlers(false); // another call to change logger configuration</p>
<p>}</p>
<p>该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。</p>
<p>public static void main(String[] args) throws Exception {</p>
<p> initLogging(); // adds a file handler to the logger</p>
<p> System.gc(); // logger configuration lost</p>
<p> Logger.getLogger(“edu.umd.cs”).info(“Some message”); // this isn’t logged to the file as expected</p>
<p>}</p>
<p>OBL_UNSATISFIED_OBLIGATION<br>这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。</p>
<p>一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。</p>
<p>三、Bad practice代码实现中的一些坏习惯<br>AM_CREATES_EMPTY_JAR_FILE_ENTRY<br>调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。</p>
<p>AM_CREATES_EMPTY_ZIP_FILE_ENTRY<br>调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。</p>
<p>BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS<br>equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。</p>
<p>DMI_RANDOM_USED_ONLY_ONCE<br>随机创建对象只使用过一次就抛弃</p>
<p>BIT_SIGNED_CHECK<br>检查位操作符运行是否合理</p>
<p>((event.detail &amp; SWT.SELECTED) &gt; 0)</p>
<p>If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use ‘!= 0’ instead of ‘&gt; 0’.</p>
<p>CN_IDIOM<br>按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone</p>
<p>CN_IDIOM_NO_SUPER_CALL<br>一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。</p>
<p>CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE<br>类中定义了clone方法但是它没有实现Cloneable接口</p>
<p>CO_ABSTRACT_SELF<br>抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：</p>
<p>int compareTo(T o)  比较此对象与指定对象的顺序。</p>
<p>CO_SELF_NO_OBJECT<br>类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型</p>
<p>DE_MIGHT_DROP<br>方法可能抛出异常</p>
<p>DE_MIGHT_IGNORE<br>此方法可能忽略异常。通常，应该以某种方式处理或报告异常，或者将异常抛出方法。</p>
<p>DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION<br>不要用removeAll方法去clear一个集合</p>
<p>DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED<br>类加载器只能建立在特殊的方法体内</p>
<p>DM_EXIT<br>在方法中调用System.exit(…)语句，考虑用RuntimeException来代替</p>
<p>DM_RUN_FINALIZERS_ON_EXIT<br>在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。</p>
<p>ES_COMPARING_PARAMETER_STRING_WITH_EQ<br>用==或者!=方法去比较String类型的参数</p>
<p>ES_COMPARING_STRINGS_WITH_EQ<br>用==或者！=去比较String类型的对象</p>
<p>EQ_ABSTRACT_SELF<br>This class defines a covariant version of equals(). To correctly override the equals() method in java.lang.Object, the parameter of equals() must have type java.lang.Object.</p>
<p>这个类定义了equals()方法，但是参数却是Object的子类。正确覆盖equals()方法，参数必须是Object</p>
<p>EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS<br>equals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。</p>
<p>public boolean equals(Object o) {</p>
<p>  if (o instanceof Foo)</p>
<pre><code>return name.equals(((Foo)o).name);</code></pre><p>  else if (o instanceof String)</p>
<pre><code>return name.equals(o);</code></pre><p>  else return false;</p>
<p>EQ_COMPARETO_USE_OBJECT_EQUALS<br>类中定义了compareTo方法但是继承了Object中的compareTo方法</p>
<p>22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)</p>
<p>类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换</p>
<p>EQ_SELF_NO_OBJECT<br>类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。</p>
<p>FI_EMPTY<br>为空的finalizer方法应该删除。一下关于finalizer的内容省略</p>
<p>GC_UNCHECKED_TYPE_IN_GENERIC_CALL<br>This call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.</p>
<p>此对泛型集合方法的调用在编译类型对象时传递一个参数，其中预期泛型类型参数中的特定类型。因此，标准Java类型系统和静态分析都不能提供关于作为参数传递的对象是否属于适当类型的有用信息。</p>
<p>HE_EQUALS_NO_HASHCODE<br>方法定义了equals方法却没有定义hashCode方法</p>
<p>HE_HASHCODE_NO_EQUALS<br> 类定义了hashCode方法去没有定义equal方法</p>
<p>HE_EQUALS_USE_HASHCODE<br>一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法</p>
<p>HE_INHERITS_EQUALS_USE_HASHCODE<br>子类继承了父类的equals方法却使用了Object的hashCode方法</p>
<p>IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION<br>子类在父类未初始化之前使用父类对象实例</p>
<p>public class CircularClassInitialization {</p>
<p>static class InnerClassSingleton extends CircularClassInitialization {</p>
<p>static InnerClassSingleton singleton = new InnerClassSingleton();</p>
<p>}</p>
<p>static CircularClassInitialization foo = InnerClassSingleton.singleton;</p>
<p>}</p>
<p>IMSE_DONT_CATCH_IMSE<br>捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法</p>
<p>ISC_INSTANTIATE_STATIC_CLASS<br>为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。</p>
<p>IT_NO_SUCH_ELEMENT<br>迭代器的next方法不能够抛出NoSuchElementException</p>
<p>J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION<br>在HttpSession对象中保存非连续的对象</p>
<p>JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS<br> The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .</p>
<p>该类使用net.jcip.annotations进行注释。不可变的，该注释的规则要求所有字段都是final</p>
<p>NP_BOOLEAN_RETURN_NULL<br>返回值为boolean类型的方法直接返回null，这样会导致空指针异常</p>
<p>NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT<br>变量调用equals方法时没有进行是否为null的判断</p>
<p>NP_TOSTRING_COULD_RETURN_NULL<br>toString方法可能返回null</p>
<p>NM_CLASS_NAMING_CONVENTION<br>类的名称以大写字母名称开头</p>
<p>NM_CLASS_NOT_EXCEPTION<br>类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆</p>
<p>NM_CONFUSING<br>令人迷惑的方面命名</p>
<p>NM_FIELD_NAMING_CONVENTION<br>非final类型的字段需要遵循驼峰命名原则</p>
<p>NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER<br>验证是否是java预留关键字</p>
<p>NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER<br>验证是否时java中的关键字</p>
<p>NM_METHOD_NAMING_CONVENTION<br>方法名称以小写字母开头</p>
<p>NM_SAME_SIMPLE_NAME_AS_INTERFACE<br>实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中</p>
<p>NM_SAME_SIMPLE_NAME_AS_SUPERCLASS<br>继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中</p>
<p>NM_VERY_CONFUSING_INTENTIONAL<br>很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。</p>
<p>NM_WRONG_PACKAGE_INTENTIONAL<br>由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法</p>
<p>import alpha.Foo;</p>
<p>public class A {</p>
<p>  public int f(Foo x) { return 17; }</p>
<p>}</p>
<p>import beta.Foo;</p>
<p>public class B extends A {</p>
<p>  public int f(Foo x) { return 42; }</p>
<p>  public int f(alpha.Foo x) { return 27; }</p>
<p>}</p>
<p>ODR_OPEN_DATABASE_RESOURCE<br>方法中可能存在关闭数据连接失败的情况</p>
<p>OS_OPEN_STREAM<br>方法中可能存在关闭流失败的情况</p>
<p>OS_OPEN_STREAM_EXCEPTION_PATH<br>方法中可能存在关闭流时出现异常情况</p>
<p>RC_REF_COMPARISON_BAD_PRACTICE<br>当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float</p>
<p>RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN<br>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。</p>
<p>RR_NOT_CHECKED<br>InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。</p>
<p>SR_NOT_CHECKED<br>InputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况</p>
<p>RV_RETURN_VALUE_IGNORED_BAD_PRACTICE<br>方法忽略返回值的异常信息</p>
<p>SI_INSTANCE_BEFORE_FINALS_ASSIGNED<br>在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。</p>
<p>SE_BAD_FIELD_STORE<br>非序列化的值保存在声明为序列化的的非序列化字段中</p>
<p>SE_COMPARATOR_SHOULD_BE_SERIALIZABLE<br>Comparator接口没有实现Serializable接口</p>
<p>SE_INNER_CLASS<br>序列化内部类</p>
<p>SE_NONFINAL_SERIALVERSIONID<br>关于UID类的检查内容省略</p>
<p>SE_NO_SUITABLE_CONSTRUCTOR<br>子类序列化时父类没有提供一个void的构造函数</p>
<p>SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION<br>Externalizable 实例类没有定义一个void类型的构造函数</p>
<p>SE_READ_RESOLVE_MUST_RETURN_OBJECT<br>readResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象</p>
<p>SE_TRANSIENT_FIELD_NOT_RESTORED<br>This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.</p>
<p>该类包含一个在类中的多个位置更新的字段，因此它似乎是类状态的一部分。但是，由于字段被标记为transient，并且没有在readObject或readResolve中设置，所以它将在类的任何反序列化实例中包含默认值。</p>
<p>SE_NO_SERIALVERSIONID<br>一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID： </p>
<p> ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;</p>
<p>UI_INHERITANCE_UNSAFE_GETRESOURCE<br>当一个类被子类继承后不要使用this.getClass().getResource(…)来获取资源</p>
<p>四、Correctness关于代码正确性相关方面的<br>BC_IMPOSSIBLE_CAST<br>不可能的类转换，执行时会抛出ClassCastException</p>
<p>BC_IMPOSSIBLE_DOWNCAST<br>父类在向下进行类型转换时抛出ClassCastException</p>
<p>BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY<br>集合转换为数组元素时发生的类转换错误。</p>
<p>This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in: </p>
<p>String[] getAsArray(Collection<string> c) {</string></p>
<p>  return (String[]) c.toArray();</p>
<p>  }</p>
<p>This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can’t really do anything else, since the Collection object has no reference to the declared generic type of the collection. </p>
<p>The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient). </p>
<p>BC_IMPOSSIBLE_INSTANCEOF<br>采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。</p>
<p>BIT_AND<br>错误的使用&amp;位操作符，例如(e &amp; C)</p>
<p>BIT_AND_ZZ<br>检查恒等的逻辑错误</p>
<p>BIT_IOR<br>错误的使用|位操作符，例如(e | C)</p>
<p>BIT_SIGNED_CHECK_HIGH_BIT<br>检查逻辑运算符操作返回的标识。例如((event.detail &amp; SWT.SELECTED) &gt; 0)，建议采用!=0代替&gt;0</p>
<p>BOA_BADLY_OVERRIDDEN_ADAPTER<br>子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用</p>
<p>BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR<br>在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2</p>
<p>DLS_DEAD_STORE_OF_CLASS_LITERAL<br>以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。</p>
<p>DLS_OVERWRITTEN_INCREMENT<br>覆写增量增加错误i = i++</p>
<p>DMI_BAD_MONTH<br>hashNext方法调用next方法。</p>
<p>DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES<br>集合没有包含他们自己本身。</p>
<p>DMI_INVOKING_HASHCODE_ON_ARRAY<br>数组直接使用hashCode方法来返回哈希码。</p>
<p>int [] a1 = new int[]{1,2,3,4}; System.out.println(a1.hashCode()); System.out.println(java.util.Arrays.hashCode(a1));</p>
<p>DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT<br>Double.longBitsToDouble invoked on an int<br>在int上调用了Double.longBitsToDouble</p>
<p>DMI_VACUOUS_SELF_COLLECTION_CALL<br>集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。</p>
<p>DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION<br>Unless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can’t be observed using reflection (e.g., by using the isAnnotationPresent method). .</p>
<p>除非注释本身使用@Retention(RetentionPolicy.RUNTIME)进行了注释，否则不能使用反射(例如，使用isAnnotationPresent方法)观察注释。</p>
<p>DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD<br>While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.</p>
<p>虽然ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，但是一些继承的调优方法对它并不有用。特别是，由于它使用corePoolSize线程和无界队列充当固定大小的池，所以对maximumPoolSize的调整没有任何有用的效果。</p>
<p>EC_ARRAY_AND_NONARRAY<br>数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);</p>
<p>EC_INCOMPATIBLE_ARRAY_COMPARE<br>使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]</p>
<p>EC_NULL_ARG<br>调用equals的对象为null</p>
<p>EC_UNRELATED_CLASS_AND_INTERFACE<br>使用equals方法比较不相关的类和接口</p>
<p>EC_UNRELATED_INTERFACES<br>调用equals方法比较不同类型的接口</p>
<p>EC_UNRELATED_TYPES<br>调用equals方法比较不同类型的类</p>
<p>EC_UNRELATED_TYPES_USING_POINTER_EQUALITY<br>This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.</p>
<p>该方法使用指针相等来比较两个似乎属于不同类型的引用。这个比较的结果在运行时总是错误的。</p>
<p>EQ_ALWAYS_FALSE<br>使用equals方法返回值总是false</p>
<p>EQ_ALWAYS_TRUE<br>equals方法返回值总是true</p>
<p>EQ_COMPARING_CLASS_NAMES<br>使用equals方法去比较一个类的实例和类的类型</p>
<p>EQ_DONT_DEFINE_EQUALS_FOR_ENUM<br>This class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don’t do it.</p>
<p>该类定义枚举，并且使用对象标识定义枚举上的等式。为枚举值定义一个协变等于方法是一个非常糟糕的实践，因为它可能会导致使用协变枚举方法将两个不同的枚举值作为等于进行比较，而在正常情况下比较时作为不相等。不要这样做。</p>
<p>EQ_OTHER_NO_OBJECT<br>类中定义的equals方法时不要覆写equals（Object）方法</p>
<p>EQ_OTHER_USE_OBJECT<br>类中定义的equals方法时不要覆写Object中的equals（Object）方法</p>
<p>EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC<br>name=错误用法 - equals方法覆盖了父类的equals可能功能不符</p>
<p>EQ_SELF_USE_OBJECT<br>类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法</p>
<p>FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER<br>This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).</p>
<p>name=错误用法 - 测试是否与NaN相等</p>
<p>VA_FORMAT_STRING_BAD_ARGUMENT<br>错误使用参数类型来格式化字符串</p>
<p>VA_FORMAT_STRING_BAD_CONVERSION<br>指定的格式字符串和参数类型不匹配，例如：String.format(“%d”, “1”)</p>
<p>VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED<br>但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。</p>
<p>VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED<br>使用String的format方法时有非法的参数也经过了格式化操作。</p>
<p>VA_FORMAT_STRING_ILLEGAL<br>格式化String对象语句错误</p>
<p>VA_FORMAT_STRING_MISSING_ARGUMENT<br>String的format操作缺少必要的参数。</p>
<p>VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT<br>格式字符串定义错误，例如：formatter.format(“%&lt;s %s”, “a”, “b”); 抛出MissingFormatArgumentException异常</p>
<p>GC_UNRELATED_TYPES<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.</p>
<p>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String. </p>
<p>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks. </string></p>
<p>这个对泛型集合方法的调用包含一个与集合的参数(即，参数的类型既不是相应泛型类型参数的超类型，也不是相应泛型类型参数的子类型)。因此，集合不太可能包含与这里使用的方法参数相同的任何对象。很可能，传递给方法的值是错误的。</p>
<p>HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS<br>A method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn’t fulfill the requirement that equal objects have equal hashCodes.</p>
<p>方法、字段或类声明一个泛型签名，其中在需要可耐洗类的上下文中使用不可耐洗类。声明equals方法但从对象继承hashCode()方法的类是不可挂起的，因为它不满足equal对象具有相等hashCode的要求。</p>
<p>HE_USE_OF_UNHASHABLE_CLASS<br>A class defines an equals(Object) method but not a hashCode() method, and thus doesn’t fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.</p>
<p>类定义了equals(Object)方法，但没有定义hashCode()方法，因此不能满足equal对象具有相等hashCode的要求。该类的一个实例用于哈希数据结构中，这使得修复这个问题变得极为重要。</p>
<p>ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL<br>integral的值转换为double后使用了Math.ceil方法</p>
<p>ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND<br>int 类型的值转换为float类型之后调用了Math.round方法</p>
<p>IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD<br>在JUnit中的断言在run方法中不会被告知</p>
<p>IJU_BAD_SUITE_METHOD<br>在一个JUnit类中声明的一个suite()方法必须声明为</p>
<p>public static junit.framework.Test suite()</p>
<p>或者</p>
<p>public static junit.framework.TestSuite suite()的形式。</p>
<p>IL_CONTAINER_ADDED_TO_ITSELF<br>集合本身作为add方法的参数，这样会引起内容溢出。</p>
<p>IL_INFINITE_LOOP<br>方法的自调用引起的死循环</p>
<p>IM_MULTIPLYING_RESULT_OF_IREM<br>和整数余数进行乘法运算。例如：i % 60 * 1000 是进行(i % 60) * 1000运算而不是 i % (60 * 1000)</p>
<p>INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE<br>保证非负数和负数进行比较</p>
<p>INT_BAD_COMPARISON_WITH_SIGNED_BYTE<br>比较有符合数，要先把有符号数转换为无符合数再进行比较</p>
<p>IO_APPENDING_TO_OBJECT_OUTPUT_STREAM<br>宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。</p>
<p>IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN<br>The initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.</p>
<p>传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者</p>
<p>MF_CLASS_MASKS_FIELD<br>子类中定义了和父类中同名的字段。在调用时会出错</p>
<p>MF_METHOD_MASKS_FIELD<br>在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。</p>
<p>NP_ALWAYS_NULL<br>对象赋为null值后 没有被重新赋值</p>
<p>NP_ALWAYS_NULL_EXCEPTION<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.</p>
<p>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.</p>
<p>空指针引用上调用去除引用方法，将发生空指针异常</p>
<p>NP_ARGUMENT_MIGHT_BE_NULL<br>方法没有判断参数是否为空</p>
<p>NP_CLOSING_NULL<br>一个为空的对象调用close方法</p>
<p>NP_GUARANTEED_DEREF<br>There is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).</p>
<p>在正常的null判断分支上，对象去除引用操作是受保护的不允许的</p>
<p>NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).</p>
<p>异常路径上有一个语句或分支，如果执行该语句或分支，则该语句或分支将确保此时值为空，并且该值将被取消引用(涉及运行时异常的正向路径除外)。</p>
<p>NP_NONNULL_PARAM_VIOLATION<br>方法中为null的参数没有被重新赋值 void test(){</p>
<p>String ss = null;</p>
<p>sya(ss); } public void sya(String ad){</p>
<p>ad.getBytes(); }</p>
<p>NP_NONNULL_RETURN_VIOLATION<br>方法声明了返回值不能为空，但是方法中有可能返回null</p>
<p>NP_NULL_INSTANCEOF<br>检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的</p>
<p>NP_NULL_ON_SOME_PATH<br>对象可能没有重新赋值</p>
<p>NP_NULL_ON_SOME_PATH_EXCEPTION<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.</p>
<p>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.</p>
<p>在异常null值处理分支调用的方法上，可能存在对象去除引用操作</p>
<p>NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS<br>方法参数中声明为nonnull类型的参数为null</p>
<p>void test(){</p>
<p>String ss = null;</p>
<p>sya(ss); } public void sya(@nonnull String ad){</p>
<p>ad.getBytes(); }</p>
<p>NP_STORE_INTO_NONNULL_FIELD<br>为一个已经声明为不能为null值的属性赋值为null。</p>
<p>NM_BAD_EQUAL<br>类中定义了一个equal方法但是却不是覆写的Object对象的equals方法</p>
<p>NM_LCASE_HASHCODE<br>类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法</p>
<p>NM_LCASE_TOSTRING<br>类中定义了一个toString方法但是却不是覆写的Object中的toString方法</p>
<p>NM_METHOD_CONSTRUCTOR_CONFUSION<br>构造方法定义混乱，保证一个标准的构造函数。 例如： SA(){ } void SA(){ }</p>
<p>NM_VERY_CONFUSING<br>混乱的方法命名，如getName和getname方法同时出现的时候</p>
<p>NM_WRONG_PACKAGE<br>方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法</p>
<p>import alpha.Foo;</p>
<p>public class A {</p>
<p>  public int f(Foo x) { return 17; }</p>
<p>}</p>
<hr>
<p>import beta.Foo;</p>
<p>public class B extends A {</p>
<p>  public int f(Foo x) { return 42; }</p>
<p>}</p>
<p>QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT<br>再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作</p>
<p>RC_REF_COMPARISON<br>比较两个对象值是否相等时应该采用equals方法，而不是==方法</p>
<p>RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION<br>对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。</p>
<p>RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION<br>使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\’而应该使用’\‘</p>
<p>RV_01_TO_INT<br>从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。</p>
<p>RV_ABSOLUTE_VALUE_OF_HASHCODE<br>此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。</p>
<p>在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。</p>
<p>RV_ABSOLUTE_VALUE_OF_RANDOM_INT<br>此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。</p>
<p>RV_EXCEPTION_NOT_THROWN<br>此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x &lt; 0)</p>
<p>  new IllegalArgumentException(“x must be nonnegative”);</p>
<p>这可能是程序员的意图抛出创建的异常：</p>
<p>if (x &lt; 0)</p>
<p>  throw new IllegalArgumentException(“x must be nonnegative”);</p>
<p>86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)<br>该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);</p>
<p>dateString.trim();</p>
<p>程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：</p>
<p>String dateString = getHeaderField(name);</p>
<p>dateString = dateString.trim();</p>
<p>RpC_REPEATED_CONDITIONAL_TEST<br>该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。</p>
<p>SA_FIELD_DOUBLE_ASSIGNMENT<br>方法中的字段包含了双重任务，例如： </p>
<p> int x;</p>
<p>  public void foo() {</p>
<p>   x = x = 17;</p>
<p>  }</p>
<p>这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。</p>
<p>SA_FIELD_SELF_ASSIGNMENT<br>方法中包含自己对自己赋值的字段。例如：</p>
<p>int x;</p>
<p>  public void foo() {</p>
<pre><code>x = x;</code></pre><p>  }</p>
<p>SA_FIELD_SELF_COMPARISON<br>字段自己进行自比较可能表明错误或逻辑错误。</p>
<p>SA_LOCAL_SELF_COMPARISON<br>方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。</p>
<p>SA_LOCAL_SELF_COMPUTATION<br>此方法对同一变量执行了荒谬的计算（如x&amp;x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。</p>
<p>SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH<br>在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。</p>
<p>SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW<br>在swtich中因为出现异常而忽略了对case值的保存。</p>
<p>SIC_THREADLOCAL_DEADLY_EMBRACE<br>如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。</p>
<p>SIO_SUPERFLUOUS_INSTANCEOF<br>在进行instanceof操作时进行没有必要的类型检查</p>
<p>STI_INTERRUPTED_ON_CURRENTTHREAD<br>此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。</p>
<p>STI_INTERRUPTED_ON_UNKNOWNTHREAD<br>调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。</p>
<p>SE_METHOD_MUST_BE_PRIVATE<br>这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。</p>
<p>SE_READ_RESOLVE_IS_STATIC<br>为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。</p>
<p>UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS<br>在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。</p>
<p>UR_UNINIT_READ<br>此构造方法中使用了一个尚未赋值的字段或属性。 String a; public SA() {</p>
<p>String abc = a;</p>
<p>System.out.println(abc); }</p>
<p>UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR<br>方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：</p>
<p>abstract class A {</p>
<p>  int hashCode;</p>
<p>  abstract Object getValue();</p>
<p>  A() {</p>
<pre><code>hashCode = getValue().hashCode();

}</code></pre><p>  }</p>
<p>class B extends A {</p>
<p>  Object value;</p>
<p>  B(Object v) {</p>
<pre><code>this.value = v;

}</code></pre><p>  Object getValue() {</p>
<pre><code>return value;</code></pre><p>  }</p>
<p>  }</p>
<p>当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。</p>
<p>DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY<br>该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：</p>
<p>String[] a = { “a” };</p>
<p>System.out.println(a.toString());</p>
<p>//正确的使用为</p>
<p>System.out.println(Arrays.toString(a));</p>
<p>DMI_INVOKING_TOSTRING_ON_ARRAY<br>该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组</p>
<p>UWF_NULL_FIELD<br>字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。</p>
<p>107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD)<br>此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。</p>
<p>五：Performance关于代码性能相关方面的<br>BX_UNBOXING_IMMEDIATELY_REBOXED</p>
<p>装箱的值被取消装箱，然后立即重新装箱</p>
<p>BX_BOXING_IMMEDIATELY_UNBOXED</p>
<p>对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作</p>
<p>BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION</p>
<p>对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：</p>
<p>new Double(d).intValue()应该直接进行强制转换例如：(int) d</p>
<p>DM_BOXED_PRIMITIVE_TOSTRING</p>
<p>仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：</p>
<p>new Integer(1).toString()    替换为   Integer.toString(1)</p>
<p>new Long(1).toString()    替换为   Long.toString(1) </p>
<p>new Float(1.0).toString()    替换为   Float.toString(1.0) </p>
<p>new Double(1.0).toString()    替换为   Double.toString(1.0) </p>
<p>new Byte(1).toString()    替换为   Byte.toString(1) </p>
<p>new Short(1).toString()    替换为   Short.toString(1) </p>
<p>new Boolean(true).toString()    替换为   Boolean.toString(true)</p>
<p>DM_FP_NUMBER_CTOR</p>
<p>使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能</p>
<p>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。</p>
<p>DM_NUMBER_CTOR</p>
<p>使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能</p>
<p>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。</p>
<p>DMI_BLOCKING_METHODS_ON_URL</p>
<p>使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。</p>
<p>DMI_COLLECTION_OF_URLS</p>
<p>方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。</p>
<p>DM_BOOLEAN_CTOR</p>
<p>使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。</p>
<p>DM_GC</p>
<p>在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。</p>
<p>DM_NEXTINT_VIA_NEXTDOUBLE</p>
<p>如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)</p>
<p>DM_STRING_CTOR</p>
<p>使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式</p>
<p>DM_STRING_TOSTRING</p>
<p>调用String.toString()是多余的操作，只要使用String就可以了。</p>
<p>DM_STRING_VOID_CTOR</p>
<p>使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。</p>
<p>ITA_INEFFICIENT_TO_ARRAY</p>
<p>当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是</p>
<p>myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。</p>
<p>LO_APPENDED_STRING_IN_FORMAT_STRING</p>
<p>此方法使用SLF4J记录器记录一个字符串，其中第一个（格式）字符串是使用串联创建的。您应该使用{}标记将动态内容注入到字符串中，以便延迟String的构建，直到需要实际的日志字符串为止。如果日志级别足够高，以致不使用此日志语句，则将永远不会执行附加操作。</p>
<p>NAB_NEEDLESS_BOXING_VALUEOF</p>
<p>此方法将String传递给包装的原始对象的parse方法，该方法又调用valueOf（）方法以转换为装箱的原始对象。当需要从String转换为装箱的原始对象时，使用BoxedPrimitive.valueOf（String）方法更简单。</p>
<p>而不是这样的：</p>
<p>Boolean bo = Boolean.valueOf(Boolean.parseBoolean(“true”));</p>
<p>Float f = Float.valueOf(Float.parseFloat(“1.234”));</p>
<p>只需做：</p>
<p>Boolean bo = Boolean.valueOf(“true”);</p>
<p>Float f = Float.valueOf(“1.234”);</p>
<p>NAB_NEEDLESS_BOXING_PARSE</p>
<p>该方法将String传递给包装的原始对象的valueOf方法，该方法进而调用boxedValue（）方法以转换为原始对象。当需要从String转换为原始值时，使用BoxedPrimitive.parseBoxedPrimitive（String）方法更简单。</p>
<p>而不是这样的：</p>
<p>public int someMethod(String data) {</p>
<p>long l = Long.valueOf(data).longValue();</p>
<p>float f = Float.valueOf(data).floatValue();</p>
<p>return Integer.valueOf(data); // There is an implicit .intValue() call</p>
<p>}</p>
<p>只需做：</p>
<p>public int someMethod(String data) {</p>
<p>long l = Long.parseLong(data);</p>
<p>float f = Float.parseFloat(data);</p>
<p>return Integer.parseInt(data);</p>
<p>}</p>
<p>NAB_NEEDLESS_BOOLEAN_CONSTANT_CONVERSION</p>
<p>此方法将一个装箱的布尔常量分配给一个原始布尔变量，或将一个装箱的布尔常量分配给一个装箱的布尔变量。对需要的变量使用正确的常数</p>
<p>PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS</p>
<p>此方法在相同实例上使用相同的常量参数连续两次调用相同的方法，而无需对对象进行任何中间更改。如果此方法未对对象进行更改（看上去没有更改），则进行两次调用将很浪费。通过将结果分配给一个临时变量，然后第二次使用该变量，可以合并这些方法调用。</p>
<p>PSC_PRESIZE_COLLECTIONS</p>
<p>这个方法使用默认构造函数分配集合，即使它预先知道集合中将放置多少项(或者至少可以合理地猜测)，从而不必要地导致集合的中间重新分配。</p>
<p>您可以使用具有初始大小的构造函数，这样会好得多，但是由于映射和集合的加载因子，甚至这也不是一个正确的估计值。</p>
<p>如果您正在使用Guava，请使用它的方法来分配具有预先确定大小的映射和集合，以获得不重新分配的最佳机会，例如:</p>
<p>Sets.newHashSetWithExpectedSize (int)</p>
<p>Maps.newHashMapWithExpectedSize (int)</p>
<p>如果没有，一个很好的估计值应该是expectedSize / {LOADING_FACTOR}默认值为0.75</p>
<p>SBSC_USE_STRINGBUFFER_CONCATENATION</p>
<p>在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象</p>
<p>例如：</p>
<p>// This is bad</p>
<p>  String s = “”;</p>
<p>  for (int i = 0; i &lt; field.length; ++i) {</p>
<pre><code>s = s + field[i];</code></pre><p>  }</p>
<p>  // This is better</p>
<p>  StringBuffer buf = new StringBuffer();</p>
<p>  for (int i = 0; i &lt; field.length; ++i) {</p>
<pre><code>buf.append(field[i]);</code></pre><p>  }</p>
<p>  String s = buf.toString();</p>
<p>SEO_SUBOPTIMAL_EXPRESSION_ORDER</p>
<p>例如，此方法在if或while语句中构建条件表达式，该表达式既包含简单的局部变量比较，又包含方法调用的比较。表达式对这些命令进行排序，以便在简单的局部变量比较之前进行方法调用。这导致方法调用在不需要的条件下执行，因此有可能导致大量代码无执行。通过对表达式进行排序，以便首先包含局部变量条件的简单条件，可以消除这种浪费。假定方法调用没有副作用。如果该方法确实有副作用，则最好将这些调用从条件中拉出并先执行，然后将值分配给局部变量。</p>
<p>例：</p>
<p>if ((calculateHaltingProbability() &gt; 0) &amp;&amp; shouldCalcHalting) { }</p>
<p>Better：</p>
<p>if (shouldCalcHalting &amp;&amp; (calculateHaltingProbability() &gt; 0) { }</p>
<p>SS_SHOULD_BE_STATIC</p>
<p>类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。</p>
<p>SPP_STRINGBUFFER_WITH_EMPTY_STRING</p>
<p>这个方法调用StringBuffer或StringBuilder构造函数，传入一个常量空字符串(“”)。这与调用默认构造函数相同，但是会使代码更加困难。考虑传入一个默认大小。</p>
<p>UCPM_USE_CHARACTER_PARAMETERIZED_METHOD</p>
<p>此方法将String长度为1 的常量文字作为参数传递给方法，该方法公开了一个类似的方法，该方法采用char。处理一个字符而不是一个字符串更简单方便。</p>
<p>而不是像这样：</p>
<p>String myString = …</p>
<p>if (myString.indexOf(“e”) != -1) {</p>
<pre><code>int i = myString.lastIndexOf("e");

System.out.println(myString + ":" + i);  //the Java compiler will use a StringBuilder internally here [builder.append(":")]

...

return myString.replace("m","z");</code></pre><p>}</p>
<p>将单字母Strings 替换为它们的char等价物，如下所示：</p>
<p>String myString = …</p>
<p>if (myString.indexOf(‘e’) != -1) {</p>
<pre><code>int i = myString.lastIndexOf('e');

System.out.println(myString + ':' + i);  //the Java compiler will use a StringBuilder internally here [builder.append(':')]

...

return myString.replace('m','z');</code></pre><p>}</p>
<p>UM_UNNECESSARY_MATH</p>
<p>在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。</p>
<p>Method Parameter </p>
<p>abs -any- </p>
<p>acos 0.0 or 1.0 </p>
<p>asin 0.0 or 1.0 </p>
<p>atan 0.0 or 1.0 </p>
<p>atan2 0.0 cbrt 0.0 or 1.0 </p>
<p>ceil -any- </p>
<p>cos 0.0 </p>
<p>cosh 0.0 </p>
<p>exp 0.0 or 1.0 </p>
<p>expm1 0.0 </p>
<p>floor -any- </p>
<p>log 0.0 or 1.0 </p>
<p>log10 0.0 or 1.0 </p>
<p>rint -any- </p>
<p>round -any- </p>
<p>sin 0.0 </p>
<p>sinh 0.0 </p>
<p>sqrt 0.0 or 1.0 </p>
<p>tan 0.0 </p>
<p>tanh 0.0 </p>
<p>toDegrees 0.0 or 1.0 </p>
<p>toRadians 0.0</p>
<p>UPM_UNCALLED_PRIVATE_METHOD</p>
<p>定义为Private类型方法从未被调用，应该被删除。</p>
<p>URF_UNREAD_FIELD</p>
<p>类中定义的属性从未被调用，建议删除。</p>
<p>UUF_UNUSED_FIELD</p>
<p>类中定义的属性从未被使用，建议删除。</p>
<p>WMI_WRONG_MAP_ITERATOR</p>
<p>当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。</p>
<p>六：Internationalization关于代码国际化相关方面的<br>DM_CONVERT_CASE</p>
<p>使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换</p>
<p>String.toUpperCase( Locale l )</p>
<p>String.toLowerCase( Locale l )</p>
<p>七：Multithreaded correctness关于代码多线程正确性相关方面的<br>DL_SYNCHRONIZATION_ON_BOOLEAN</p>
<p>该代码同步一个封装的原始常量，例如一个Boolean类型。</p>
<p>private static Boolean inited = Boolean.FALSE;</p>
<p>…</p>
<p>  synchronized(inited) { </p>
<pre><code>if (!inited) {

   init();

   inited = Boolean.TRUE;

   }

 }</code></pre><p>…</p>
<p>由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁</p>
<p>DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE</p>
<p>该代码同步一个封装的原始常量，例如一个Integer类型。</p>
<p>private static Integer count = 0;</p>
<p>…</p>
<p>  synchronized(count) { </p>
<pre><code> count++;

 }</code></pre><p>…</p>
<p>由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁</p>
<p>DL_SYNCHRONIZATION_ON_SHARED_CONSTANT</p>
<p>同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。</p>
<p>DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE</p>
<p>同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：</p>
<p>private static final Integer fileLock = new Integer(1);</p>
<p>…</p>
<p>  synchronized(fileLock) { </p>
<pre><code> .. do something ..

 }</code></pre><p>…</p>
<p>它最后被定义为以下方式来代替：private static final Object fileLock = new Object();</p>
<p>DM_MONITOR_WAIT_ON_CONDITION</p>
<p>方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。</p>
<p>DM_USELESS_THREAD</p>
<p>这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。</p>
<p>ESync_EMPTY_SYNC</p>
<p>该代码包含一个空的同步块：synchronized() {}</p>
<p>IS2_INCONSISTENT_SYNC</p>
<p>不合理的同步</p>
<p>IS_FIELD_NOT_GUARDED</p>
<p>域不是良好的同步访问—</p>
<p>此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问</p>
<p>JLM_JSR166_LOCK_MONITORENTER</p>
<p>实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。</p>
<p>LI_LAZY_INIT_STATIC</p>
<p>静态域不正确的延迟初始化–</p>
<p>这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题</p>
<p>LI_LAZY_INIT_UPDATE_STATIC</p>
<p>这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。</p>
<p>即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。</p>
<p>ML_SYNC_ON_UPDATED_FIELD</p>
<p>对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。</p>
<p>MSF_MUTABLE_SERVLET_FIELD</p>
<p>一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。</p>
<p>MWN_MISMATCHED_NOTIFY</p>
<p>此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。</p>
<p>MWN_MISMATCHED_WAIT</p>
<p>此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。</p>
<p>NP_SYNC_AND_NULL_CHECK_FIELD</p>
<p>如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。</p>
<p>NO_NOTIFY_NOT_NOTIFYALL</p>
<p>调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。</p>
<p>RS_READOBJECT_SYNC</p>
<p>序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。</p>
<p>RU_INVOKE_RUN</p>
<p>这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。</p>
<p>SC_START_IN_CTOR</p>
<p>在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。</p>
<p>SP_SPIN_ON_FIELD</p>
<p>方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）</p>
<p>STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE</p>
<p>即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。</p>
<p>Calendar rightNow = Calendar.getInstance();</p>
<p>STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE</p>
<p>在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。</p>
<p>myString = DateFormat.getDateInstance().format(myDate);</p>
<p>STCAL_STATIC_CALENDAR_INSTANCE</p>
<p>Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。</p>
<p>STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE</p>
<p>DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。</p>
<p>SWL_SLEEP_WITH_LOCK_HELD</p>
<p>当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。</p>
<p>UG_SYNC_SET_UNSYNC_GET</p>
<p>这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。</p>
<p>UL_UNRELEASED_LOCK</p>
<p>方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：</p>
<p>  Lock l = …;</p>
<pre><code>l.lock();

try {

    // do something

} finally {

    l.unlock();</code></pre><p>}</p>
<p>UL_UNRELEASED_LOCK_EXCEPTION_PATH</p>
<p>方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：</p>
<p>  Lock l = …;</p>
<pre><code>l.lock();

try {

    // do something

} finally {

    l.unlock();</code></pre><p>}</p>
<p>UW_UNCOND_WAIT)</p>
<p>方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。</p>
<p>VO_VOLATILE_REFERENCE_TO_ARRAY</p>
<p>声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性</p>
<p>WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL</p>
<p>实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：</p>
<pre><code> private static final String base = "label";

 private static int nameCounter = 0;

 String constructComponentName() {

    synchronized (getClass()) {

        return base + nameCounter++;

    }

 }</code></pre><p>Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：</p>
<pre><code>private static final String base = "label";

 private static int nameCounter = 0;

 String constructComponentName() {

    synchronized (Label.class) {

        return base + nameCounter++;

    }

 }</code></pre><p>WS_WRITEOBJECT_SYNC</p>
<p>这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。</p>
<p>WA_AWAIT_NOT_IN_LOOP</p>
<p>方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。</p>
<p>WA_NOT_IN_LOOP</p>
<p>这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。</p>
<p>八：Malicious codevulnerability关于恶意破坏代码相关方面的<br>EI_EXPOSE_REP</p>
<p>返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。</p>
<p>EI_EXPOSE_REP2</p>
<p>此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。</p>
<p>FI_PUBLIC_SHOULD_BE_PROTECTED</p>
<p>一个类中的finalize（）方法必须声明为protected，而不能为public类型</p>
<p>MS_EXPOSE_REP</p>
<p>一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。</p>
<p>MS_FINAL_PKGPROTECT</p>
<p>一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。</p>
<p>MS_MUTABLE_ARRAY</p>
<p>一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。</p>
<p>MS_MUTABLE_HASHTABLE</p>
<p>一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。</p>
<p>MS_OOI_PKGPROTECT</p>
<p>将域尽量不要定义在接口中，并声明为包保护</p>
<p>在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。</p>
<p>MS_PKGPROTECT</p>
<p>一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。</p>
<p>九：Dodgy、style糟糕的代码</p>
<p>BC_BAD_CAST_TO_ABSTRACT_COLLECTION</p>
<p>在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。</p>
<p>BC_BAD_CAST_TO_CONCRETE_COLLECTION</p>
<p>代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。</p>
<p>BC_UNCONFIRMED_CAST</p>
<p>强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。</p>
<p>BC_VACUOUS_INSTANCEOF</p>
<p>instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。</p>
<p>CC_CYCLOMATIC_COMPLEXITY</p>
<p>该方法具有较高的圈复杂度，可以计算出分支点的个数。它很可能难以测试，并且很容易更改。考虑将此方法重构为多个方法以降低风险。</p>
<p>CFS_CONFUSING_FUNCTION_SEMANTICS</p>
<p>此方法将修改参数，然后将此参数作为方法的返回值返回。这将使这个方法的调用者感到困惑，因为传入参数的“原始”显然也不会更改。如果此方法的目的是更改参数，则将该方法更改为具有空返回值的a会更清楚。如果由于接口或超类契约需要返回类型，则可能应该复制该参数。</p>
<p>CI_CONFUSED_INHERITANCE</p>
<p>这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。</p>
<p>DB_DUPLICATE_BRANCHES</p>
<p>此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。</p>
<p>DB_DUPLICATE_SWITCH_CLAUSES</p>
<p>他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。</p>
<p>DLS_DEAD_LOCAL_STORE</p>
<p>该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。</p>
<p>DLS_DEAD_LOCAL_STORE_IN_RETURN</p>
<p>本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。</p>
<p>DLS_DEAD_LOCAL_STORE_OF_NULL</p>
<p>把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。</p>
<p>DMI_HARDCODED_ABSOLUTE_FILENAME</p>
<p>此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;</p>
<p>DMI_NONSERIALIZABLE_OBJECT_WRITTEN</p>
<p>代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。</p>
<p>DMI_USELESS_SUBSTRING</p>
<p>此代码调用了subString(0)方法，它将返回原来的值。</p>
<p>EXS_EXCEPTION_SOFTENING_HAS_CHECKED</p>
<p>此方法的异常签名受超类接口的约束，不抛出已捕获的已检查异常。因此，此异常被转换为未检查异常并引发。最好抛出最近的已检查异常，并使用初始原因字段用原始异常注释新异常。</p>
<p>EQ_DOESNT_OVERRIDE_EQUALS</p>
<p>该类扩展了定义equals方法的类并添加字段，但本身不定义equals方法。因此，该类实例上的等式将忽略子类的标识和添加的字段。确保这是您想要的，并且您不需要覆盖equals方法。即使不需要重写equals方法，也可以考虑重写它，以记录这样一个事实:子类的equals方法只返回调用super.equals(o)的结果。</p>
<p>FE_FLOATING_POINT_EQUALITY</p>
<p>此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较</p>
<p>VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN</p>
<p>使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false</p>
<p>IC_INIT_CIRCULARITY</p>
<p>在引用两个相互调用为环状static方法去初始化一个实例时是错误的。</p>
<p>ICAST_IDIV_CAST_TO_DOUBLE</p>
<p>整形数除法强制转换为double或者float类型。</p>
<p>int x = 2;</p>
<p>int y = 5;</p>
<p>// Wrong: yields result 0.0</p>
<p>double value1 =  x / y;</p>
<p>// Right: yields result 0.4</p>
<p>double value2 =  x / (double) y;</p>
<p>ICAST_INTEGER_MULTIPLY_CAST_TO_LONG</p>
<p>整形数做乘法运算结果转换为long值时如果采用</p>
<p>long convertDaysToMilliseconds(int days) { return 1000<em>3600</em>24*days; } 结果会因为超出整形的范围而出错。</p>
<p>如果使用：</p>
<p>long convertDaysToMilliseconds(int days) { return 1000L<em>3600</em>24*days; } </p>
<p>或者：</p>
<p>static final long MILLISECONDS_PER_DAY = 24L<em>3600</em>1000; long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; } </p>
<p>都可以避免此问题。</p>
<p>ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT</p>
<p>无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）</p>
<p>IM_AVERAGE_COMPUTATION_COULD_OVERFLOW</p>
<p>代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x &amp; 1 == 1, or x % 2 != 0来代替</p>
<p>IMC_IMMATURE_CLASS_PRINTSTACKTRACE</p>
<p>此方法将堆栈跟踪打印到控制台。这是不可配置的，并导致应用程序看起来不专业。切换到使用日志记录器，以便用户能够控制日志记录的内容和位置。</p>
<p>INT_VACUOUS_COMPARISON</p>
<p>整形数进行比较结果总是不变。例如：x &lt;= Integer.MAX_VALUE</p>
<p>MOM_MISLEADING_OVERLOAD_MODEL</p>
<p>该类用实例和静态版本“重载”相同的方法。由于这两种模型的使用是不同的，这将使这些方法的用户感到困惑。</p>
<p>MTIA_SUSPECT_SERVLET_INSTANCE_FIELD</p>
<p>这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。</p>
<p>MTIA_SUSPECT_STRUTS_INSTANCE_FIELD</p>
<p>类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。</p>
<p>NP_DEREFERENCE_OF_READLINE_VALUE</p>
<p>对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。</p>
<p>NP_IMMEDIATE_DEREFERENCE_OF_READLINE</p>
<p>对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。</p>
<p>NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE</p>
<p>方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。</p>
<p>NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE</p>
<p>参数值在任何情况下都不能为空，但是有明确的注释它可以为空。</p>
<p>NS_DANGEROUS_NON_SHORT_CIRCUIT</p>
<p>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，这会造成潜在的危险。</p>
<p>NS_NON_SHORT_CIRCUIT</p>
<p>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，会引起不安全的操作</p>
<p>PZLA_PREFER_ZERO_LENGTH_ARRAYS</p>
<p>考虑返回一个零长度的数组，而不是null值</p>
<p>QF_QUESTIONABLE_FOR_LOOP</p>
<p>确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。</p>
<p>RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE</p>
<p>方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。</p>
<p>RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES</p>
<p>方法中对两个null值进行比较</p>
<p>RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</p>
<p>方法中对不为空的值进行为空的判断。</p>
<p>REC_CATCH_EXCEPTION</p>
<p>在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获</p>
<p>RI_REDUNDANT_INTERFACES</p>
<p>子类和父类都实现了同一个接口，这种定义是多余的。</p>
<p>RV_DONT_JUST_NULL_CHECK_READLINE</p>
<p>readLine方法的结果不为空时被抛弃</p>
<p>RV_REM_OF_RANDOM_INT</p>
<p>此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。</p>
<p>RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT</p>
<p>这段代码调用一个方法并忽略返回值。然而，我们的分析表明，该方法(如果有的话，包括它在子类中的实现)除了返回值之外不会产生任何效果。因此可以删除这个调用。</p>
<p>可能是错误警告：-该方法旨在被覆盖，并在其他超出分析范围的项目中产生副作用。</p>
<p>-调用该方法来触发类加载，这可能会产生副作用。</p>
<p>-调用该方法只是为了获得一些异常。</p>
<p>可以使用@CheckReturnValue注释来指示FindBugs忽略该方法的返回值</p>
<p>SA_LOCAL_DOUBLE_ASSIGNMENT</p>
<p>为一个局部变量两次赋值，这样是没有意义的。例如：</p>
<p>public void foo() {</p>
<pre><code>int x,y;

x = x = 17;</code></pre><p>  }</p>
<p>SA_LOCAL_SELF_ASSIGNMENT</p>
<p>局部变量使用自身给自己赋值</p>
<p>public void foo() {</p>
<pre><code>int x = 3;

x = x;</code></pre><p>  }</p>
<p>SF_SWITCH_FALLTHROUGH</p>
<p>Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。</p>
<p>SF_SWITCH_NO_DEFAULT</p>
<p>Switch没有默认情况下执行的case语句。</p>
<p>SE_PRIVATE_READ_RESOLVE_NOT_INHERITED</p>
<p>声明为private的序列化方法被子类继承</p>
<p>UCF_USELESS_CONTROL_FLOW</p>
<p>没有任何作用的条件语句。</p>
<p>if (argv.length == 0) { // TODO: handle this case }</p>
<p>UCF_USELESS_CONTROL_FLOW_NEXT_LINE</p>
<p>无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。</p>
<p>if (argv.length == 1);</p>
<pre><code>    System.out.println("Hello, " + argv[0]);</code></pre><p>UP_UNUSED_PARAMETER</p>
<p>此方法定义了从未使用过的参数。由于此方法是静态的或私有的，且不能派生，因此删除这些参数并简化方法是安全的。虽然不太可能，但您应该考虑可以反射性地使用此方法，因此您也希望更改该调用。在这种情况下，很可能一旦删除了参数，就会有一系列方法调用花费时间创建该参数并将其传递下去。所有这些都可能被移除。</p>
<p>UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR</p>
<p>字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。</p>
<p>USBR_UNNECESSARY_STORE_BEFORE_RETURN<br>该方法将返回结果存储在局部变量中，然后立即返回局部变量。直接返回分配给局部变量的值会更简单。</p>
<p>Instead of the following:</p>
<p>public float average(int[] arr) {</p>
<pre><code>float sum = 0;

for (int i = 0; i &lt; arr.length; i++) {

    sum += arr[i];

}

float ave = sum / arr.length;

return ave;</code></pre><p>}</p>
<p>Simply change the method to return the result of the division:</p>
<p>public float average(int[] arr) {</p>
<pre><code>float sum = 0;

for (int i = 0; i &lt; arr.length; i++) {

    sum += arr[i];

}

return sum / arr.length; //Change</code></pre><p>}</p>
<p>XFB_XML_FACTORY_BYPASS</p>
<p>方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：</p>
<p>javax.xml.parsers.DocumentBuilderFactory</p>
<p>javax.xml.parsers.SAXParserFactory</p>
<p>javax.xml.transform.TransformerFactory</p>
<p>org.w3c.dom.Document.createXXXX</p>
<p>XSS_REQUEST_PARAMETER_TO_SEND_ERROR</p>
<p>在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。</p>
<p>XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER</p>
<p>代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。</p>
<p>OBL_UNSATISFIED_OBLIGATION 方法可能在清理流或资源时失败。</p>
<p>处理方式：使用try/finally块，在finally块中关闭流。</p>
<p>OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE</p>
<p>原因及处理方式：原因是in关闭异常之后，out可能就关闭失败。处理方式先关闭输出流，再关闭输入流。</p>
<p>OS</p>
<p>OS_OPEN_STREAM 方法可能在关闭流时失败</p>
<p>处理方式：使用try/finally块，在finally块中关闭流。</p>
<p>RV</p>
<p>RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT 有返回值，但是未使用。</p>
<p>处理方式：接收返回值，并且打印出来。logger.info()；</p>
<p>FindBugs是基于Bug Patterns概念，查找javabytecode（.class文件）中的潜在bug，主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等</p>
<p>一、Security 关于代码安全性防护<br>1.Dm: Hardcoded constant database password (DMI_CONSTANT_DB_PASSWORD)<br>代码中创建DB的密码时采用了写死的密码。<br>2.Dm: Empty database password (DMI_EMPTY_DB_PASSWORD)<br>创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。<br>3.HRS: HTTP cookie formed from untrusted input (HRS_REQUEST_PARAMETER_TO_COOKIE)<br>此代码使用不受信任的HTTP参数构造一个HTTP Cookie。<br>4.HRS: HTTP Response splitting vulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)<br>在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。<br>5.SQL: Nonconstant string passed to execute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)<br>该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。<br>6.XSS: JSP reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)<br>在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。<br>二、Experimental<br>1.LG: Potential lost logger changes due to weak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)<br>OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：<br>public static void initLogging() throws Exception {<br> Logger logger = Logger.getLogger(“edu.umd.cs”);<br> logger.addHandler(new FileHandler()); // call to change logger configuration<br> logger.setUseParentHandlers(false); // another call to change logger configuration<br>}<br>该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。<br>public static void main(String[] args) throws Exception {<br> initLogging(); // adds a file handler to the logger<br> System.gc(); // logger configuration lost<br> Logger.getLogger(“edu.umd.cs”).info(“Some message”); // this isn’t logged to the file as expected<br>}<br>2.OBL: Method may fail to clean up stream or resource (OBL_UNSATISFIED_OBLIGATION)<br>这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。<br>一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。</p>
<p>三、Bad practice代码实现中的一些坏习惯<br>1.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。<br>2.AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。<br>3.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)<br>equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。<br>4.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)<br>随机创建对象只使用过一次就抛弃<br>5.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK)<br>检查位操作符运行是否合理<br>((event.detail &amp; SWT.SELECTED) &gt; 0)<br>If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use ‘!= 0’ instead of ‘&gt; 0’.<br>6.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)<br>按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone<br>7.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)<br>一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。<br>8.CN: Class defines clone() but doesn’t implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)<br>类中定义了clone方法但是它没有实现Cloneable接口<br>9.Co: Abstract class defines covariant compareTo() method (CO_ABSTRACT_SELF)<br>抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：<br>int compareTo(T o)  比较此对象与指定对象的顺序。<br>10.Co: Covariant compareTo() method defined (CO_SELF_NO_OBJECT)<br>类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型<br>11.DE: Method might drop exception (DE_MIGHT_DROP)<br>方法可能抛出异常<br>12.DE: Method might ignore exception (DE_MIGHT_IGNORE)<br>方法可能忽略异常<br>13.DMI: Don’t use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)<br>不要用removeAll方法去clear一个集合<br>14.DP: Classloaders should only be created inside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)<br>类加载器只能建立在特殊的方法体内<br>15.Dm: Method invokes System.exit(…) (DM_EXIT)<br>在方法中调用System.exit(…)语句，考虑用RuntimeException来代替<br>16.Dm: Method invokes dangerous method runFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)<br>在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。<br>17.ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)<br>用==或者!=方法去比较String类型的参数<br>18.ES: Comparison of String objects using == or != (ES_COMPARING_STRINGS_WITH_EQ)<br>用==或者！=去比较String类型的对象<br>19.Eq: Abstract class defines covariant equals() method (EQ_ABSTRACT_SELF)<br>20.Eq: Equals checks for noncompatible operand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)<br>equals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。<br>public boolean equals(Object o) {<br>  if (o instanceof Foo)<br>    return name.equals(((Foo)o).name);<br>  else if (o instanceof String)<br>    return name.equals(o);<br>  else return false;<br>21.Eq: Class defines compareTo(…) and uses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)<br>类中定义了compareTo方法但是继承了Object中的compareTo方法<br>22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)<br>类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换<br>23.Eq: Covariant equals() method defined (EQ_SELF_NO_OBJECT)<br>类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。<br>24.FI: Empty finalizer should be deleted (FI_EMPTY)<br>为空的finalizer方法应该删除。一下关于finalizer的内容省略<br>25.GC: Unchecked type in generic call (GC_UNCHECKED_TYPE_IN_GENERIC_CALL)<br>This call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.<br>26.HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)<br>方法定义了equals方法却没有定义hashCode方法<br>27.HE: Class defines hashCode() but not equals() (HE_HASHCODE_NO_EQUALS)<br> 类定义了hashCode方法去没有定义equal方法<br>28.HE: Class defines equals() and uses Object.hashCode() (HE_EQUALS_USE_HASHCODE)<br>一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法<br>29.HE: Class inherits equals() and uses Object.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)<br>子类继承了父类的equals方法却使用了Object的hashCode方法<br>30.IC: Superclass uses subclass during initialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)<br>子类在父类未初始化之前使用父类对象实例<br>public class CircularClassInitialization {<br>    static class InnerClassSingleton extends CircularClassInitialization {<br>static InnerClassSingleton singleton = new InnerClassSingleton();<br>    }<br>    static CircularClassInitialization foo = InnerClassSingleton.singleton;<br>}<br>31.IMSE: Dubious catching of IllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)<br>捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法<br>32.ISC: Needless instantiation of class that only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)<br>为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。<br>33.It: Iterator next() method can’t throw NoSuchElementException (IT_NO_SUCH_ELEMENT)<br>迭代器的next方法不能够抛出NoSuchElementException<br>34.J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)<br>在HttpSession对象中保存非连续的对象<br>35.JCIP: Fields of immutable classes should be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)<br> The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .<br>36.NP: Method with Boolean return type returns explicit null (NP_BOOLEAN_RETURN_NULL)<br>返回值为boolean类型的方法直接返回null，这样会导致空指针异常<br>37.NP: equals() method does not check for null argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)<br>变量调用equals方法时没有进行是否为null的判断<br>38.NP: toString method may return null (NP_TOSTRING_COULD_RETURN_NULL)<br>toString方法可能返回null<br>39.Nm: Class names should start with an upper case letter (NM_CLASS_NAMING_CONVENTION)<br>类的名称以大写字母名称开头<br>40.Nm: Class is not derived from an Exception, even though it is named as such (NM_CLASS_NOT_EXCEPTION)<br>类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆<br>41.Nm: Confusing method names (NM_CONFUSING)<br>令人迷惑的方面命名<br>42.Nm: Field names should start with a lower case letter (NM_FIELD_NAMING_CONVENTION)<br>非final类型的字段需要遵循驼峰命名原则<br>43.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)<br>验证是否是java预留关键字<br>44.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)<br>验证是否时java中的关键字<br>45.Nm: Method names should start with a lower case letter (NM_METHOD_NAMING_CONVENTION)<br>方法名称以小写字母开头<br>46.Nm: Class names shouldn’t shadow simple name of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)<br>实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中<br>47.Nm: Class names shouldn’t shadow simple name of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)<br>继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中<br>48.Nm: Very confusing method names (but perhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)<br>很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。<br>49.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)<br>由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}<br>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>  public int f(alpha.Foo x) { return 27; }<br>}<br>50.ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)<br>方法中可能存在关闭数据连接失败的情况<br>51.OS: Method may fail to close stream (OS_OPEN_STREAM)<br>方法中可能存在关闭流失败的情况<br>52.OS: Method may fail to close stream on exception (OS_OPEN_STREAM_EXCEPTION_PATH)<br>方法中可能存在关闭流时出现异常情况<br>53.RC: Suspicious reference comparison to constant (RC_REF_COMPARISON_BAD_PRACTICE)<br>当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float<br>54.RC: Suspicious reference comparison of Boolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)<br>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。<br>55.RR: Method ignores results of InputStream.read() (RR_NOT_CHECKED)<br>InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。<br>56.RR: Method ignores results of InputStream.skip() (SR_NOT_CHECKED)<br>InputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况<br>57.RV: Method ignores exceptional return value (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)<br>方法忽略返回值的异常信息<br>58.SI: Static initializer creates instance before all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)<br>在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。<br>59.Se: Non-serializable value stored into instance field of a serializable class (SE_BAD_FIELD_STORE)<br>非序列化的值保存在声明为序列化的的非序列化字段中<br>60.Se: Comparator doesn’t implement Serializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)<br>Comparator接口没有实现Serializable接口<br>61.Se: Serializable inner class (SE_INNER_CLASS)<br>序列化内部类<br>62.Se: serialVersionUID isn’t final (SE_NONFINAL_SERIALVERSIONID)<br>关于UID类的检查内容省略<br>63.Se: Class is Serializable but its superclass doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)<br>子类序列化时父类没有提供一个void的构造函数<br>64.Se: Class is Externalizable but doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)<br>Externalizable 实例类没有定义一个void类型的构造函数<br>65.Se: The readResolve method must be declared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)<br>readResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象<br>66.Se: Transient field that isn’t set by deserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)<br>This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.<br>67.SnVI: Class is Serializable, but doesn’t define serialVersionUID (SE_NO_SERIALVERSIONID)<br>一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：<br> ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;<br>68.UI: Usage of GetResource may be unsafe if class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)<br>当一个类被子类继承后不要使用this.getClass().getResource(…)来获取资源<br>四、Correctness关于代码正确性相关方面的<br>1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)<br>不可能的类转换，执行时会抛出ClassCastException<br>2.BC: Impossible downcast (BC_IMPOSSIBLE_DOWNCAST)<br>父类在向下进行类型转换时抛出ClassCastException<br>3.BC: Impossible downcast of toArray() result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)<br>集合转换为数组元素时发生的类转换错误。<br>This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in:<br>String[] getAsArray(Collection<string> c) {<br>  return (String[]) c.toArray();<br>  }<br>This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can’t really do anything else, since the Collection object has no reference to the declared generic type of the collection.<br>The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient).<br>4.BC: instanceof will always return false (BC_IMPOSSIBLE_INSTANCEOF)<br>采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。<br>5.BIT: Incompatible bit masks (BIT_AND)<br>错误的使用&amp;位操作符，例如(e &amp; C)<br>6.BIT: Check to see if ((…) &amp; 0) == 0 (BIT_AND_ZZ)<br>检查恒等的逻辑错误<br>7.BIT: Incompatible bit masks (BIT_IOR)<br>错误的使用|位操作符，例如(e | C)<br>8.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK_HIGH_BIT)<br>检查逻辑运算符操作返回的标识。例如((event.detail &amp; SWT.SELECTED) &gt; 0)，建议采用!=0代替&gt;0<br>9.BOA: Class overrides a method implemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)<br>子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用<br>10.Bx: Primitive value is unboxed and coerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)<br>在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2<br>11.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)<br>以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。<br>12.DLS: Overwritten increment (DLS_OVERWRITTEN_INCREMENT)<br>覆写增量增加错误i = i++<br>13.DMI: Bad constant value for month (DMI_BAD_MONTH)<br>hashNext方法调用next方法。<br>14.DMI: Collections should not contain themselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)<br>集合没有包含他们自己本身。<br>15.DMI: Invocation of hashCode on an array (DMI_INVOKING_HASHCODE_ON_ARRAY)<br>数组直接使用hashCode方法来返回哈希码。<br>int [] a1 = new int[]{1,2,3,4};<br>    System.out.println(a1.hashCode());<br>    System.out.println(java.util.Arrays.hashCode(a1));<br>16.DMI: Double.longBitsToDouble invoked on an int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)<br>17.DMI: Vacuous call to collections (DMI_VACUOUS_SELF_COLLECTION_CALL)<br>集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。<br>18.Dm: Can’t use reflection to check for presence of annotation without runtime retention (DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)<br>Unless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can’t be observed using reflection (e.g., by using the isAnnotationPresent method). .<br>19.Dm: Useless/vacuous call to EasyMock method (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)<br>While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.<br>20.EC: equals() used to compare array and nonarray (EC_ARRAY_AND_NONARRAY)<br>数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);<br>21.EC: equals(…) used to compare incompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)<br>使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]<br>22.EC: Call to equals() with null argument (EC_NULL_ARG)<br>调用equals的对象为null<br>23.EC: Call to equals() comparing unrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)<br>使用equals方法比较不相关的类和接口<br>24.EC: Call to equals() comparing different interface types (EC_UNRELATED_INTERFACES)<br>调用equals方法比较不同类型的接口<br>25.EC: Call to equals() comparing different types (EC_UNRELATED_TYPES)<br>调用equals方法比较不同类型的类<br>26.EC: Using pointer equality to compare different types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)<br>This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.<br>27.Eq: equals method always returns false (EQ_ALWAYS_FALSE)<br>使用equals方法返回值总是false<br>28.Eq: equals method always returns true (EQ_ALWAYS_TRUE)<br>equals方法返回值总是true<br>29.Eq: equals method compares class names rather than class objects (EQ_COMPARING_CLASS_NAMES)<br>使用equals方法去比较一个类的实例和类的类型<br>30.Eq: Covariant equals() method defined for enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)<br>This class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don’t do it.<br>31.Eq: equals() method defined that doesn’t override equals(Object) (EQ_OTHER_NO_OBJECT)<br>类中定义的equals方法时不要覆写equals（Object）方法<br>32.Eq: equals() method defined that doesn’t override Object.equals(Object) (EQ_OTHER_USE_OBJECT)<br>类中定义的equals方法时不要覆写Object中的equals（Object）方法<br>33.Eq: equals method overrides equals in superclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)<br>34.Eq: Covariant equals() method defined, Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)<br>类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法<br>35.FE: Doomed test for equality to NaN (FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)<br>This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).<br>36.FS: Format string placeholder incompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)<br>错误使用参数类型来格式化字符串<br>37.FS: The type of a supplied argument doesn’t match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)<br>指定的格式字符串和参数类型不匹配，例如：String.format(“%d”, “1”)<br>38.FS: MessageFormat supplied where printf style format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)<br>但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。<br>39.FS: More arguments are passed than are actually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)<br>使用String的format方法时有非法的参数也经过了格式化操作。<br>40.FS: Illegal format string (VA_FORMAT_STRING_ILLEGAL)<br>格式化String对象语句错误<br>41.FS: Format string references missing argument (VA_FORMAT_STRING_MISSING_ARGUMENT)<br>String的format操作缺少必要的参数。<br>42.FS: No previous argument for format string (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)<br>格式字符串定义错误，例如：formatter.format(“%&lt;s %s”, “a”, “b”); 抛出MissingFormatArgumentException异常<br>43.GC: No relationship between generic parameter and method argument (GC_UNRELATED_TYPES)<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>44.HE: Signature declares use of unhashable class in hashed construct (HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)<br>A method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn’t fulfill the requirement that equal objects have equal hashCodes.<br>45.HE: Use of class without a hashCode() method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)<br>A class defines an equals(Object) method but not a hashCode() method, and thus doesn’t fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.<br>46.ICAST: integral value cast to double and then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)<br>integral的值转换为double后使用了Math.ceil方法<br>47.ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)<br>int 类型的值转换为float类型之后调用了Math.round方法<br>48.IJU: JUnit assertion in run method will not be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)<br>在JUnit中的断言在run方法中不会被告知<br>49.IJU: TestCase declares a bad suite method (IJU_BAD_SUITE_METHOD)<br>在一个JUnit类中声明的一个suite()方法必须声明为<br>public static junit.framework.Test suite()<br>或者<br>public static junit.framework.TestSuite suite()的形式。<br>50.IL: A collection is added to itself (IL_CONTAINER_ADDED_TO_ITSELF)<br>集合本身作为add方法的参数，这样会引起内容溢出。<br>51.IL: An apparent infinite loop (IL_INFINITE_LOOP)<br>方法的自调用引起的死循环<br>52.IM: Integer multiply of result of integer remainder (IM_MULTIPLYING_RESULT_OF_IREM)<br>和整数余数进行乘法运算。例如：i % 60 * 1000 是进行(i % 60) * 1000运算而不是 i % (60 * 1000)<br>53.INT: Bad comparison of nonnegative value with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)<br>保证非负数和负数进行比较<br>54.INT: Bad comparison of signed byte (INT_BAD_COMPARISON_WITH_SIGNED_BYTE)<br>比较有符合数，要先把有符号数转换为无符合数再进行比较<br>55.IO: Doomed attempt to append to an object output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)<br>宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。<br>56.IP: A parameter is dead upon entry to a method but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)<br>The initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.<br>传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者<br>57.MF: Class defines field that masks a superclass field (MF_CLASS_MASKS_FIELD)<br>子类中定义了和父类中同名的字段。在调用时会出错<br>58.MF: Method defines a variable that obscures a field (MF_METHOD_MASKS_FIELD)<br>在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。<br>59.NP: Null pointer dereference (NP_ALWAYS_NULL)<br>对象赋为null值后 没有被重新赋值<br>60.NP: Null pointer dereference in method on exception path (NP_ALWAYS_NULL_EXCEPTION)<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>空指针引用上调用去除引用方法，将发生空指针异常<br>61.NP: Method does not check for null argument (NP_ARGUMENT_MIGHT_BE_NULL)<br>方法没有判断参数是否为空<br>62.NP: close() invoked on a value that is always null (NP_CLOSING_NULL)<br>一个为空的对象调用close方法<br>63.NP: Null value is guaranteed to be dereferenced (NP_GUARANTEED_DEREF)<br>There is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>在正常的null判断分支上，对象去除引用操作是受保护的不允许的<br>64.NP: Value is null and guaranteed to be dereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>65.NP: Method call passes null to a nonnull parameter (NP_NONNULL_PARAM_VIOLATION)</string></string></p>
<p>方法中为null的参数没有被重新赋值</p>
<pre><code>void test(){</code></pre><p>String ss = null;</p>
<p>sya(ss);</p>
<pre><code>}    

public void sya(String ad){</code></pre><p>ad.getBytes();</p>
<pre><code>}</code></pre><p>66.NP: Method may return null, but is declared @NonNull (NP_NONNULL_RETURN_VIOLATION)</p>
<p>方法声明了返回值不能为空，但是方法中有可能返回null</p>
<p>67.NP: A known null value is checked to see if it is an instance of a type (NP_NULL_INSTANCEOF)</p>
<p>检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的</p>
<p>68.NP: Possible null pointer dereference (NP_NULL_ON_SOME_PATH)</p>
<p>对象可能没有重新赋值</p>
<p>69.NP: Possible null pointer dereference in method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION)</p>
<p>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.</p>
<p>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.</p>
<p>在异常null值处理分支调用的方法上，可能存在对象去除引用操作</p>
<p>70.NP: Method call passes null for nonnull parameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)</p>
<p>方法参数中声明为nonnull类型的参数为null</p>
<p>void test(){</p>
<p>String ss = null;</p>
<p>sya(ss);</p>
<pre><code>}    

public void sya(@nonnull String ad){</code></pre><p>ad.getBytes();</p>
<pre><code>}</code></pre><p>71.NP: Store of null value into field annotated NonNull (NP_STORE_INTO_NONNULL_FIELD)</p>
<p>为一个已经声明为不能为null值的属性赋值为null。</p>
<p>72.Nm: Class defines equal(Object); should it be equals(Object)? (NM_BAD_EQUAL)</p>
<p>类中定义了一个equal方法但是却不是覆写的Object对象的equals方法</p>
<p>73.Nm: Class defines hashcode(); should it be hashCode()? (NM_LCASE_HASHCODE)</p>
<p>类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法</p>
<p>74.Nm: Class defines tostring(); should it be toString()? (NM_LCASE_TOSTRING)</p>
<p>类中定义了一个toString方法但是却不是覆写的Object中的toString方法</p>
<p>75.Nm: Apparent method/constructor confusion (NM_METHOD_CONSTRUCTOR_CONFUSION)</p>
<p>构造方法定义混乱，保证一个标准的构造函数。    例如：</p>
<pre><code>SA(){    }

void SA(){

}</code></pre><p>76.Nm: Very confusing method names (NM_VERY_CONFUSING)</p>
<p>混乱的方法命名，如getName和getname方法同时出现的时候</p>
<p>77.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE)</p>
<p>方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法</p>
<p>import alpha.Foo;</p>
<p>public class A {</p>
<p>  public int f(Foo x) { return 17; }</p>
<p>}</p>
<p>import beta.Foo;</p>
<p>public class B extends A {</p>
<p>  public int f(Foo x) { return 42; }</p>
<p>}</p>
<p>78.QBA: Method assigns boolean literal in boolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)</p>
<p>再if或者while表达式中使用boolean类型的值时应该使用去判断，而不是采用=操作</p>
<p>79.RC: Suspicious reference comparison (RC_REF_COMPARISON)</p>
<p>比较两个对象值是否相等时应该采用equals方法，而不是方法</p>
<p>80.RE: Invalid syntax for regular expression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)</p>
<p>对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。</p>
<p>81.RE: File.separator used for regular expression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)</p>
<p>使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\’而应该使用’'</p>
<p>82.RV: Random value from 0 to 1 is coerced to the integer 0 (RV_01_TO_INT)</p>
<p>从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。</p>
<p>83.RV: Bad attempt to compute absolute value of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE)</p>
<p>此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。</p>
<p>在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。</p>
<p>84.RV: Bad attempt to compute absolute value of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT)</p>
<p>此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。</p>
<p>85.RV: Exception created and dropped rather than thrown (RV_EXCEPTION_NOT_THROWN)</p>
<p>此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x &lt; 0)</p>
<p>  new IllegalArgumentException(“x must be nonnegative”);</p>
<p>这可能是程序员的意图抛出创建的异常：</p>
<p>if (x &lt; 0)</p>
<p>  throw new IllegalArgumentException(“x must be nonnegative”);</p>
<p>86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)</p>
<p>该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);</p>
<p>dateString.trim();</p>
<p>程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：</p>
<p>String dateString = getHeaderField(name);</p>
<p>dateString = dateString.trim();</p>
<p>87.RpC: Repeated conditional tests (RpC_REPEATED_CONDITIONAL_TEST)</p>
<p>该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。</p>
<p>88.SA: Double assignment of field (SA_FIELD_DOUBLE_ASSIGNMENT)</p>
<p>方法中的字段包含了双重任务，例如： </p>
<p> int x;</p>
<p>  public void foo() {</p>
<p>   x = x = 17;</p>
<p>  }</p>
<p>这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。</p>
<p>89.SA: Self assignment of field (SA_FIELD_SELF_ASSIGNMENT)</p>
<p>方法中包含自己对自己赋值的字段。例如：</p>
<p>int x;</p>
<p>  public void foo() {</p>
<pre><code>x = x;</code></pre><p>  }</p>
<p>90.SA: Self comparison of field with itself (SA_FIELD_SELF_COMPARISON)</p>
<p>字段自己进行自比较可能表明错误或逻辑错误。</p>
<p>91.SA: Self comparison of value with itself (SA_LOCAL_SELF_COMPARISON)</p>
<p>方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。</p>
<p>92.SA: Nonsensical self computation involving a variable (e.g., x &amp; x) (SA_LOCAL_SELF_COMPUTATION)</p>
<p>此方法对同一变量执行了荒谬的计算（如x&amp;x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。</p>
<p>93.SF: Dead store due to switch statement fall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)</p>
<p>在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。</p>
<p>94.SF: Dead store due to switch statement fall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)</p>
<p>在swtich中因为出现异常而忽略了对case值的保存。</p>
<p>95.SIC: Deadly embrace of non-static inner class and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE)</p>
<p>如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。</p>
<p>96.SIO: Unnecessary type check done using instanceof operator (SIO_SUPERFLUOUS_INSTANCEOF)</p>
<p>在进行instanceof操作时进行没有必要的类型检查</p>
<p>97.STI: Unneeded use of currentThread() call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD)</p>
<p>此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。</p>
<p>98.STI: Static Thread.interrupted() method invoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD)</p>
<p>调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。</p>
<p>99.Se: Method must be private in order for serialization to work (SE_METHOD_MUST_BE_PRIVATE)</p>
<p>这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。</p>
<p>100.Se: The readResolve method must not be declared as a static method. (SE_READ_RESOLVE_IS_STATIC)</p>
<p>为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。</p>
<p>101.UMAC: Uncallable method defined in anonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)</p>
<p>在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。</p>
<p>102.UR: Uninitialized read of field in constructor (UR_UNINIT_READ)</p>
<p>此构造方法中使用了一个尚未赋值的字段或属性。</p>
<pre><code>String a;

public SA() {</code></pre><p>String abc = a;</p>
<p>System.out.println(abc);</p>
<pre><code>}</code></pre><p>103.UR: Uninitialized read of field method called from constructor of superclass (UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)</p>
<p>方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：</p>
<p>abstract class A {</p>
<p>  int hashCode;</p>
<p>  abstract Object getValue();</p>
<p>  A() {</p>
<pre><code>hashCode = getValue().hashCode();

}</code></pre><p>  }</p>
<p>class B extends A {</p>
<p>  Object value;</p>
<p>  B(Object v) {</p>
<pre><code>this.value = v;

}</code></pre><p>  Object getValue() {</p>
<pre><code>return value;</code></pre><p>  }</p>
<p>  }</p>
<p>当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。</p>
<p>104.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)</p>
<p>该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：</p>
<p>String[] a = { “a” };</p>
<p>System.out.println(a.toString());</p>
<p>//正确的使用为</p>
<p>System.out.println(Arrays.toString(a));</p>
<p>105.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ARRAY)</p>
<p>该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组</p>
<p>106.UwF: Field only ever set to null (UWF_NULL_FIELD)</p>
<p>字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。</p>
<p>107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD</p>
<p>此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。</p>
<p>五：Performance关于代码性能相关方面的<br>1.Bx: Primitive value is boxed and then immediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)<br>对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作<br>2.Bx: Primitive value is boxed then unboxed to perform primitive coercion (BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)<br>对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：<br>new Double(d).intValue()应该直接进行强制转换例如：(int) d<br>3.Bx: Method allocates a boxed primitive just to call toString (DM_BOXED_PRIMITIVE_TOSTRING)<br>仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：<br>new Integer(1).toString()    替换为   Integer.toString(1)<br>new Long(1).toString()    替换为   Long.toString(1)<br>new Float(1.0).toString()    替换为   Float.toString(1.0)<br>new Double(1.0).toString()    替换为   Double.toString(1.0)<br>new Byte(1).toString()    替换为   Byte.toString(1)<br>new Short(1).toString()    替换为   Short.toString(1)<br>new Boolean(true).toString()    替换为   Boolean.toString(true)<br>4.Bx: Method invokes inefficient floating-point Number constructor; use static valueOf instead (DM_FP_NUMBER_CTOR)<br>使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。<br>5.Bx: Method invokes inefficient Number constructor; use static valueOf instead (DM_NUMBER_CTOR)<br>使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。<br>6.Dm: The equals and hashCode methods of URL are blocking (DMI_BLOCKING_METHODS_ON_URL)<br>使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。<br>7.Dm: Maps and sets of URLs can be performance hogs (DMI_COLLECTION_OF_URLS)<br>方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。<br>8.Dm: Method invokes inefficient Boolean constructor; use Boolean.valueOf(…) instead (DM_BOOLEAN_CTOR)<br>使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。<br>9.Dm: Explicit garbage collection; extremely dubious except in benchmarking code (DM_GC)<br>在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。<br>10.Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE)<br> 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)<br>11.Dm: Method invokes inefficient new String(String) constructor (DM_STRING_CTOR)<br>使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式<br>12.Dm: Method invokes toString() method on a String (DM_STRING_TOSTRING)<br>调用String.toString()是多余的操作，只要使用String就可以了。<br>13.Dm: Method invokes inefficient new String() constructor (DM_STRING_VOID_CTOR)<br>使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。<br>14.ITA: Method uses toArray() with zero-length array argument (ITA_INEFFICIENT_TO_ARRAY)<br>当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是<br>myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。<br>15.SBSC: Method concatenates strings using + in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)<br>在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象<br>例如：<br>// This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }</p>
<p>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>16.SS: Unread field: should this field be static? (SS_SHOULD_BE_STATIC)<br>类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。<br>17.UM: Method calls static Math class method on a constant value (UM_UNNECESSARY_MATH)<br>在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。<br>Method Parameter<br>abs -any-<br>acos 0.0 or 1.0<br>asin 0.0 or 1.0<br>atan 0.0 or 1.0<br>atan2 0.0 cbrt 0.0 or 1.0<br>ceil -any-<br>cos 0.0<br>cosh 0.0<br>exp 0.0 or 1.0<br>expm1 0.0<br>floor -any-<br>log 0.0 or 1.0<br>log10 0.0 or 1.0<br>rint -any-<br>round -any-<br>sin 0.0<br>sinh 0.0<br>sqrt 0.0 or 1.0<br>tan 0.0<br>tanh 0.0<br>toDegrees 0.0 or 1.0<br>toRadians 0.0<br>18.UPM: Private method is never called (UPM_UNCALLED_PRIVATE_METHOD)<br>定义为Private类型方法从未被调用，应该被删除。<br>19.UrF: Unread field (URF_UNREAD_FIELD)<br>类中定义的属性从未被调用，建议删除。<br>20.UuF: Unused field (UUF_UNUSED_FIELD)<br>类中定义的属性从未被使用，建议删除。<br>21.WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)<br>当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。<br>六：Internationalization关于代码国际化相关方面的<br>Dm: Consider using Locale parameterized version of invoked method (DM_CONVERT_CASE)<br>使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换<br>String.toUpperCase( Locale l )<br>String.toLowerCase( Locale l )<br>七：Multithreaded correctness关于代码多线程正确性相关方面的<br>1.DL: Synchronization on Boolean could lead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)<br>该代码同步一个封装的原始常量，例如一个Boolean类型。<br>private static Boolean inited = Boolean.FALSE;<br>…<br>  synchronized(inited) {<br>    if (!inited) {<br>       init();<br>       inited = Boolean.TRUE;<br>       }<br>     }<br>…<br>由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>2.DL: Synchronization on boxed primitive could lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)<br>该代码同步一个封装的原始常量，例如一个Integer类型。<br>private static Integer count = 0;<br>…<br>  synchronized(count) {<br>     count++;<br>     }<br>…<br>由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>3.DL: Synchronization on interned String could lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)<br>同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。<br>4.DL: Synchronization on boxed primitive values (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)<br>同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：<br>private static final Integer fileLock = new Integer(1);<br>…<br>  synchronized(fileLock) {<br>     .. do something ..<br>     }<br>…<br>它最后被定义为以下方式来代替：private static final Object fileLock = new Object();</p>
<p>5.Dm: Monitor wait() called on Condition (DM_MONITOR_WAIT_ON_CONDITION)<br>方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。<br>6.Dm: A thread was created using the default empty run method (DM_USELESS_THREAD)<br>这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。<br>7.ESync: Empty synchronized block (ESync_EMPTY_SYNC)<br>该代码包含一个空的同步块：synchronized() {}<br>8.IS: Inconsistent synchronization (IS2_INCONSISTENT_SYNC)<br>不合理的同步<br>9.IS: Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED)<br>域不是良好的同步访问—</p>
<p>此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问<br>10.JLM: Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER)<br>实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。<br>11.LI: Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC)<br>静态域不正确的延迟初始化–<br>这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题<br>12.LI: Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC)<br>这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。<br>即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。<br>13.ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)<br>对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。<br>14.MSF: Mutable servlet field (MSF_MUTABLE_SERVLET_FIELD)<br>一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。<br>15.MWN: Mismatched notify() (MWN_MISMATCHED_NOTIFY)<br>此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>16.MWN: Mismatched wait() (MWN_MISMATCHED_WAIT)<br>此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>17.NP: Synchronize and null check on the same field. (NP_SYNC_AND_NULL_CHECK_FIELD)<br>如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。<br>18.No: Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL)<br>调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。<br>19.RS: Class’s readObject() method is synchronized (RS_READOBJECT_SYNC)<br>序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。<br>20.Ru: Invokes run on a thread (did you mean to start it instead?) (RU_INVOKE_RUN)<br>这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。<br>21.SC: Constructor invokes Thread.start() (SC_START_IN_CTOR)<br>在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。<br>22.SP: Method spins on field (SP_SPIN_ON_FIELD)<br>方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）<br>23.STCAL: Call to static Calendar (STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)<br>即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。<br>Calendar rightNow = Calendar.getInstance();<br>24.STCAL: Call to static DateFormat (STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)<br>在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。<br>myString = DateFormat.getDateInstance().format(myDate);</p>
<p>25.STCAL: Static Calendar (STCAL_STATIC_CALENDAR_INSTANCE)<br>Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。<br>26.STCAL: Static DateFormat (STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)<br>DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。<br>27.SWL: Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD)<br>当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。<br>28.UG: Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET)<br>这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。<br>29.UL: Method does not release lock on all paths (UL_UNRELEASED_LOCK)<br>方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>30.UL: Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)<br>方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>31.UW: Unconditional wait (UW_UNCOND_WAIT)<br>方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。<br>32.VO: A volatile reference to an array doesn’t treat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)<br>声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性<br>33.WL: Sychronization on getClass rather than class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)<br>实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：<br>     private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (getClass()) {<br>            return base + nameCounter++;<br>        }<br>     }<br>Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：<br>    private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (Label.class) {<br>            return base + nameCounter++;<br>        }<br>     }<br>34.WS: Class’s writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC)<br>这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。<br>35.Wa: Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP)<br>方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。<br>36.Wa: Wait not in loop (WA_NOT_IN_LOOP)<br>这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。<br>八：Malicious codevulnerability关于恶意破坏代码相关方面的<br>1.EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP)<br>返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。<br>2.EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2)<br>此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。<br>3.FI: Finalizer should be protected, not public (FI_PUBLIC_SHOULD_BE_PROTECTED)<br>一个类中的finalize（）方法必须声明为protected，而不能为public类型<br>4.MS: Public static method may expose internal representation by returning array (MS_EXPOSE_REP)<br>一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。<br>5.MS: Field should be both final and package protected (MS_FINAL_PKGPROTECT)<br>一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。<br>6.MS: Field is a mutable array (MS_MUTABLE_ARRAY)<br>一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。<br>7.MS: Field is a mutable Hashtable (MS_MUTABLE_HASHTABLE)<br>一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。<br>8.MS: Field should be moved out of an interface and made package protected (MS_OOI_PKGPROTECT)<br>将域尽量不要定义在接口中，并声明为包保护<br>在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。<br>9.MS: Field should be package protected (MS_PKGPROTECT)<br>一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。<br>十：Dodgy关于代码运行期安全方面的<br>1.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)<br>在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。<br>2.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)<br>代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。<br>3.BC: Questionable cast to abstract collection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)<br>在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。<br>4.BC: Questionable cast to concrete collection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)<br>代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。<br>5.BC: Unchecked/unconfirmed cast (BC_UNCONFIRMED_CAST)<br>强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。<br>6.BC: instanceof will always return true (BC_VACUOUS_INSTANCEOF)<br>instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。<br>7.BSHIFT: Unsigned right shift cast to short/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)<br>无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）<br>8.CI: Class is final but declares protected field (CI_CONFUSED_INHERITANCE)<br>这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。<br>9.DB: Method uses the same code for two branches (DB_DUPLICATE_BRANCHES)<br>此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。<br>10.DB: Method uses the same code for two switch clauses (DB_DUPLICATE_SWITCH_CLAUSES)<br>他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。<br>11.DLS: Dead store to local variable (DLS_DEAD_LOCAL_STORE)<br>该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。<br>12.DLS: Useless assignment in return statement (DLS_DEAD_LOCAL_STORE_IN_RETURN)<br>本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。<br>13.DLS: Dead store of null to local variable (DLS_DEAD_LOCAL_STORE_OF_NULL)<br>把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。<br>14.DMI: Code contains a hard coded reference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)<br>此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;<br>15.DMI: Non serializable object written to ObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)<br>代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。<br>16.DMI: Invocation of substring(0), which returns the original value (DMI_USELESS_SUBSTRING)<br>此代码调用了subString(0)方法，它将返回原来的值。<br>17.Eq: Class doesn’t override equals in superclass (EQ_DOESNT_OVERRIDE_EQUALS)<br>子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。<br>18.FE: Test for floating point equality (FE_FLOATING_POINT_EQUALITY)<br>此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较<br>19.FS: Non-Boolean argument formatted using %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)<br>使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false<br>20.IC: Initialization circularity (IC_INIT_CIRCULARITY)<br>在引用两个相互调用为环状static方法去初始化一个实例时是错误的。<br>21.ICAST: integral division result cast to double or float (ICAST_IDIV_CAST_TO_DOUBLE)<br>整形数除法强制转换为double或者float类型。<br>int x = 2;<br>int y = 5;<br>// Wrong: yields result 0.0<br>double value1 =  x / y;<br>// Right: yields result 0.4<br>double value2 =  x / (double) y;<br>22.ICAST: Result of integer multiplication cast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)<br>整形数做乘法运算结果转换为long值时如果采用<br>long convertDaysToMilliseconds(int days) { return 1000<em>3600</em>24<em>days; } 结果会因为超出整形的范围而出错。<br>如果使用：<br>long convertDaysToMilliseconds(int days) { return 1000L</em>3600<em>24</em>days; }<br>或者：<br>static final long MILLISECONDS_PER_DAY = 24L<em>3600</em>1000;<br>    long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }<br>都可以避免此问题。<br>23.IM: Computation of average could overflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)<br>代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x &amp; 1 == 1, or x % 2 != 0来代替<br>24.INT: Vacuous comparison of integer value (INT_VACUOUS_COMPARISON)<br>整形数进行比较结果总是不变。例如：x &lt;= Integer.MAX_VALUE<br>25.MTIA: Class extends Servlet class and uses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)<br>这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。<br>26.MTIA: Class extends Struts Action class and uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)<br>类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。<br>27.NP: Dereference of the result of readLine() without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)<br>对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。<br>28.NP: Immediate dereference of the result of readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)<br>对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。<br>29.NP: Possible null pointer dereference due to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)<br>方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。<br>30.NP: Parameter must be nonnull but is marked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)<br>参数值在任何情况下都不能为空，但是有明确的注释它可以为空。<br>31.NS: Potentially dangerous use of non-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，这会造成潜在的危险。<br>32.NS: Questionable use of non-short-circuit logic (NS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，会引起不安全的操作<br>33.PZLA: Consider returning a zero length array rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)<br>考虑返回一个零长度的数组，而不是null值<br>34.QF: Complicated, subtle or wrong increment in for-loop (QF_QUESTIONABLE_FOR_LOOP)<br>确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。<br>35.RCN: Redundant comparison of non-null value to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)<br>方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。<br>36.RCN: Redundant comparison of two null values (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)<br>方法中对两个null值进行比较<br>37.RCN: Redundant nullcheck of value known to be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)<br>方法中对不为空的值进行为空的判断。<br>38.REC: Exception is caught when Exception is not thrown (REC_CATCH_EXCEPTION)<br>在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获<br>39.RI: Class implements same interface as superclass (RI_REDUNDANT_INTERFACES)<br>子类和父类都实现了同一个接口，这种定义是多余的。<br>40.RV: Method discards result of readLine after checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)<br>readLine方法的结果不为空时被抛弃<br>41.RV: Remainder of 32-bit signed random integer (RV_REM_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。<br>42.SA: Double assignment of local variable (SA_LOCAL_DOUBLE_ASSIGNMENT)<br>为一个局部变量两次赋值，这样是没有意义的。例如：<br>public void foo() {<br>    int x,y;<br>    x = x = 17;<br>  }<br>43.SA: Self assignment of local variable (SA_LOCAL_SELF_ASSIGNMENT)<br>局部变量使用自身给自己赋值<br>public void foo() {<br>    int x = 3;<br>    x = x;<br>  }<br>44.SF: Switch statement found where one case falls through to the next case (SF_SWITCH_FALLTHROUGH)<br>Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。<br>45.SF: Switch statement found where default case is missing (SF_SWITCH_NO_DEFAULT)<br>Switch没有默认情况下执行的case语句。<br>46.Se: private readResolve method not inherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)<br>声明为private的序列化方法被子类继承<br>47.UCF: Useless control flow (UCF_USELESS_CONTROL_FLOW)<br>没有任何作用的条件语句。<br>if (argv.length == 0) {<br>    // TODO: handle this case<br>    }<br>48.UCF: Useless control flow to next line (UCF_USELESS_CONTROL_FLOW_NEXT_LINE)<br>无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。<br>if (argv.length == 1);<br>        System.out.println(“Hello, “ + argv[0]);<br>49.UwF: Field not initialized in constructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)<br>字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。<br>50.XFB: Method directly allocates a specific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)<br>方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：<br>javax.xml.parsers.DocumentBuilderFactory<br>javax.xml.parsers.SAXParserFactory<br>javax.xml.transform.TransformerFactory<br>org.w3c.dom.Document.createXXXX</p>
<p>6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ<br>     ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)</p>
<p>This code compares a java.lang.String parameter for reference equality using the == or != operators. Requiring callers to pass only String constants or interned strings to a method is unnecessarily fragile, and rarely leads to measurable performance gains. Consider using the equals(Object) method instead.</p>
<pre><code> 使用 == 或者 != 来比较字符串或interned字符串，不会获得显著的性能提升，同时并不可靠，请考虑使用equals()方法。</code></pre><p>6.2、       HE_EQUALS_NO_HASHCODE<br>     HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)</p>
<p>This class overrides equals(Object), but does not override hashCode().  Therefore, the class may violate the invariant that equal objects must have equal hashcodes.</p>
<pre><code> 类定义了equals()方法但没有重写hashCode()方法，这样违背了相同对象必须具有相同的hashcodes的原则</code></pre><p>6.3、       IT_NO_SUCH_ELEMENT<br>     It: Iterator next() method can’t throw NoSuchElement exception (IT_NO_SUCH_ELEMENT)</p>
<p>This class implements the java.util.Iterator interface.  However, its next() method is not capable of throwing java.util.NoSuchElementException.  The next() method should be changed so it throws NoSuchElementException if is called when there are no more elements to return.</p>
<pre><code> 迭代器Iterator无法抛出NoSuchElement异常，类实现了java.util.Iterator接口，但是next()方法无法抛出java.util.NoSuchElementException异常，因此，next()方法应该做如此修改，当被调用时，如果没有element返回，则抛出NoSuchElementException异常</code></pre><p>6.4、       J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION<br>     J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)</p>
<p>This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.</p>
<pre><code> 将没有实现serializable的对象放到HttpSession中，当这个session被钝化和迁移时，将会产生错误，建议放到HttpSession中的对象都实现serializable接口。</code></pre><p>6.5、       ODR_OPEN_DATABASE_RESOURCE<br>     ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)</p>
<p>The method creates a database resource (such as a database connection or row set), does not assign it to any fields, pass it to other methods, or return it, and does not appear to close the object on all paths out of the method.  Failure to close database resources on all paths out of a method may result in poor performance, and could cause the application to have problems communicating with the database.</p>
<pre><code> 方法可能未关闭数据库资源，未关闭数据库资源将会导致性能变差，还可能引起应用与服务器间的通讯问题。</code></pre><p>6.6、       OS_OPEN_STREAM<br>     OS: Method may fail to close stream (OS_OPEN_STREAM)</p>
<p>The method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed.</p>
<pre><code> 方法可能未关闭stream，方法产生了一个IO流，却未关闭，将会导致文件描绘符的泄漏，建议使用finally block来确保io stream被关闭。</code></pre><p>6.7、       DMI_CALLING_NEXT_FROM_HASNEXT<br>     DMI: hasNext method invokes next (DMI_CALLING_NEXT_FROM_HASNEXT)</p>
<p>The hasNext() method invokes the next() method. This is almost certainly wrong, since the hasNext() method is not supposed to change the state of the iterator, and the next method is supposed to change the state of the iterator.</p>
<p>6.8、       IL_INFINITE_LOOP<br>     IL: An apparent infinite loop (IL_INFINITE_LOOP)</p>
<p>This loop doesn’t seem to have a way to terminate (other than by perhaps throwing an exception).</p>
<pre><code> 明显的无限循环.</code></pre><p>6.9、       IL_INFINITE_RECURSIVE_LOOP<br>     IL: An apparent infinite recursive loop (IL_INFINITE_RECURSIVE_LOOP)</p>
<p>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.</p>
<pre><code> 明显的无限迭代循环,将导致堆栈溢出.</code></pre><p>6.10、   WMI_WRONG_MAP_ITERATOR<br>     WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)</p>
<p>This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.</p>
<pre><code> 使用了keySet iterator和Map.get(key)来获取Map值,这种方式效率低,建议使用entrySet的iterator效率更高.</code></pre><p>6.11、   IM_BAD_CHECK_FOR_ODD<br>     IM: Check for oddness that won’t work for negative numbers (IM_BAD_CHECK_FOR_ODD)</p>
<p>The code uses x % 2 == 1 to check to see if a value is odd, but this won’t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.</p>
<pre><code> 奇偶检测逻辑,未考虑负数情况.</code></pre><p>7.实际项目中Bug类型统计</p>
<p>7.1、       Call to equals() comparing different types<br>id : EC_UNRELATED_TYPES, type : EC, category : CORRECTNESS This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.</p>
<p>原因分析：</p>
<p>这缺陷的意思是，大部分都是类型永远不会有这种情况， 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的；</p>
<p>示例：if(“1”.equals(DAOValue.valueofSuccess()))</p>
<p>7.2、       Dead store to local variable<br>id: DLS_DEAD_LOCAL_STORE, type: DLS, category: STYLE</p>
<p>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.</p>
<p>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.</p>
<p>原因分析：</p>
<p>DLS问题指的是给本地变量赋了一个值，但随后的代码并没有用到这个值。</p>
<p>7.3、       Method call passes null for nonnull parameter<br>id: NP_NULL_PARAM_DEREF, type: NP, category: CORRECTNESS</p>
<p>This method call passes a null value for a nonnull method parameter. Either the parameter is annotated as a parameter that should always be nonnull, or analysis has shown that it will always be dereferenced.</p>
<p>原因分析：对参数为null的情况未作处理。</p>
<p>例如：</p>
<p>7.4、       Method with Boolean return type returns explicit null<br>id: NP_BOOLEAN_RETURN_NULL, type: NP, category: BAD_PRACTICE</p>
<p>A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.</p>
<p>原因分析：</p>
<p>方法如果定义为返回类型Boolean，则可以返回Boolean.TRUE, Boolean.FALSE or null （如果 return 的是 true or  false， 则AutoBoxing 成 Boolean.TRUE, Boolean.FALSE）。因为JDK 支持 基本类型和装箱类型的自动转化， 所以下面的代码中：</p>
<p>boolean result = test_NP_BOOLEAN_RETURN_NULL();</p>
<p>因为此时test_NP_BOOLEAN_RETURN_NULL() 返回的是NULL， 所以 JDK 做 automatic unboxing 的操作时， 即调用了 object. booleanValue() 方法时，抛出了空指针。</p>
<p>改成：boolean result = test_NP_BOOLEAN_RETURN_NULL()==null?false:true;</p>
<p>7.5、       No relationship between generic parameter and method argument<br>id: GC_UNRELATED_TYPES, type: GC, category: CORRECTNESS</p>
<p>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.</p>
<p>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.</p>
<p>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.</string></p>
<p>原因分析：调用Collection类中的contains方法比较时，所比较的两个参数类型不致；</p>
<p>例如：</p>
<p>修改后：</p>
<p>7.6、       Null pointer dereference in method on exception path<br>id: NP_ALWAYS_NULL_EXCEPTION, type: NP, category: CORRECTNESS</p>
<p>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.</p>
<p>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.</p>
<p>原因分析：在异常处理时，调用一个空对象的方法时可能引起空指针异常。</p>
<p>例如：</p>
<p>7.7、       Nullcheck of value previously dereferenced<br>id: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE, type:RCN, category: CORRECTNESS</p>
<p>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.</p>
<p>原因分析：前面获取的对象，现在引用的时候没有交验是否为null。</p>
<p>例如：</p>
<p>7.8、       Possible null pointer dereference<br>id: NP_NULL_ON_SOME_PATH, type: NP, category: CORRECTNESS</p>
<p>There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of FindBugs.</p>
<p>原因分析：可能存在空引用。</p>
<p>例如：</p>
<p>7.9、       Possible null pointer dereference in method on exception path<br>id: NP_NULL_ON_SOME_PATH_EXCEPTION, type: NP, category:CORRECTNESS</p>
<p>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.</p>
<p>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.</p>
<p>原因分析：</p>
<p>代码调用时， 遇到异常分支， 可能造成一个对象没有获得赋值依旧保持NULL空指针。 接下来如果对这个对象有引用， 可能造成NullPointerException 空指针异常。</p>
<p>例如：</p>
<p>7.10、   Test for floating point equality<br>id: FE_FLOATING_POINT_EQUALITY, type: FE, category: STYLE</p>
<p>This operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate. For values that must be precise, such as monetary values, consider using a fixed-precision type such as BigDecimal. For values that need not be precise, consider comparing for equality within some range, for example: if ( Math.abs(x - y) &lt; .0000001 ). See the Java Language Specification, section 4.2.4.</p>
<p>原因分析：</p>
<p>Float类型的数据比较时，会存在的定的误差值，用!=来比较不是很准确，建议比较两个数的绝对值是否在一定的范围内来进行比较。如，if ( Math.abs(x - y) &lt; .0000001 )</p>
<p>例如：</p>
<p>7.11、   Useless assignment in return statement<br>id: DLS_DEAD_LOCAL_STORE_IN_RETURN, type: DLS, category: STYLE</p>
<p>This statement assigns to a local variable in a return statement. This assignment has effect. Please verify that this statement does the right thing.</p>
<p>原因分析：</p>
<p>在return的对象中，没有必要通过对象赋值再进行返回。</p>
<p>例如：</p>
<p>7.12、   Write to static field from instance method<br>id: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD, type: ST, category:STYLE</p>
<p>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.</p>
<p>原因分析：向static字段中写入值。</p>
<p>例如：<br> private static DBRBO dbrBO;<br> public final void refresh() {<br>        danskeBankBO = null;<br>        dbrBO = null;<br>        fileAndPathBO = null;<br>    }<br>建议改为：去掉static。</p>
<p>7.13、   Incorrect lazy initialization and update of static field<br>id: LI_LAZY_INIT_UPDATE_STATIC, type: LI, category: MT_CORRECTNESS</p>
<p>This method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very seriousmultithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized.</p>
<p>Even if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized.</p>
<p>原因分析：</p>
<p>该方法的初始化中包含了一个迟缓初始化的静态变量。你的方法引用了一个静态变量，估计是类静态变量，那么多线程调用这个方法时，你的变量就会面临线程安全的问题了，除非别的东西阻止任何其他线程访问存储对象从直到它完全被初始化。</p>
<p>7.14、   Method ignores return value<br>id: RV_RETURN_VALUE_IGNORED, type: RV, category: CORRECTNESS</p>
<p>The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,</p>
<p>String dateString = getHeaderField(name);</p>
<p>dateString.trim();</p>
<p>the programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:</p>
<p>String dateString = getHeaderField(name);</p>
<p>dateString = dateString.trim();</p>
<p>原因分析：方法忽略了设置返回值。</p>
<p>例如：</p>
<p>7.15、   Method might ignore exception<br>id: DE_MIGHT_IGNORE, type: DE, category: BAD_PRACTICE</p>
<p>This method might ignore an exception.Â  In general, exceptions should be handled or reported in some way, or they should be thrown out of the method.</p>
<p>原因分析：应该将异常 处理、打印或者抛出</p>
<p>例如：</p>
<p>7.16、   Unwritten field<br>id: UWF_UNWRITTEN_FIELD, type: UwF, category: CORRECTNESS</p>
<p>This field is never written.Â  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.</p>
<p>原因分析：从未被初始化的变量，调用它时，将返回默认值，要么初始化，要么删掉它。</p>
<p>例如：</p>
<p>7.17、   Value is null and guaranteed to be dereferenced on exception path<br>id: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH, type: NP, category:CORRECTNESS</p>
<p>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).</p>
<p>原因分析：exception分支上，存在引用一个null对象的方法，引发空指针异常。</p>
<p>例如：</p>
<p>7.18、   Very confusing method names<br>id: NM_VERY_CONFUSING, type: Nm, category: CORRECTNESS</p>
<p>The referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.</p>
<p>原因分析：被引用的方法中存在容易混淆的变量。</p>
<p>例如：fzgsdm改成 fzgsDm 即可。</p>
<p>7.19、   Method invokes inefficient new String() constructor<br>id: DM_STRING_VOID_CTOR, type: Dm, category: Performance Creating a new java.lang.String object using the no-argument constructor wastes memory because the object so created will be functionally indistinguishable from the empty string constant “”.  Java guarantees that identical string constants will be represented by the same String object.  Therefore, you should just use the empty string constant directly.</p>
<p>原因分析：不使用new String()定义空的字符串</p>
<p>例如：</p>
<p>7.20、   Load of known null value<br>id: NP_LOAD_OF_KNOWN_NULL_VALUE, type: Np, category: Dodgy</p>
<p>The variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake (perhaps you intended to refer to a different variable, or perhaps the earlier check to see if the variable is null should have been a check to see if it was nonnull).</p>
<p>原因分析：null值的不当使用。</p>
<p>例如：</p>
<p>7.21、   Method concatenates strings using + in a loop<br>id: SBSC_USE_STRINGBUFFER_CONCATENATION, type: SBSC, category: Performance</p>
<p>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration. Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.</p>
<p>For example:</p>
<p>  // This is bad</p>
<p>  String s = “”;</p>
<p>  for (int i = 0; i &lt; field.length; ++i) {</p>
<pre><code>s = s + field[i];</code></pre><p>  }</p>
<p>  // This is better</p>
<p>  StringBuffer buf = new StringBuffer();</p>
<p>  for (int i = 0; i &lt; field.length; ++i) {</p>
<pre><code>buf.append(field[i]);</code></pre><p>  }</p>
<p>  String s = buf.toString();</p>
<p>原因分析：在循环里使用字符串连接，效率低，应该使用StringBuilder/StringBuffer</p>
<p>findbugs 错误分析日志 findbugs 出错类型及对应解释<br>终于 我们又开始使用FINDBUGS来检测代码的问题了 但因没又中文版和网上错误分析实际很少 所以自己边处理BUG边写文档<br>   首先在装好FINDBUGS后 在 project–&gt;properteis–&gt;findbugs里的2个框的勾点上可以让改正BUG后自动判断是否改正了 改正了就自动去掉BUG点</p>
<p>1、Dead store to local variable 本地变量存储了闲置不用的对象<br>举例：<br>List accountCoList = new ArrayList();<br>我们为accountCoList新建了一个对象，但是程序的后面并没有使用这个这个新建对象。<br>建议改为：<br>List accountCoList = null;</p>
<p>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent<br>instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is<br>a bytecode-based tool, there is no easy way to eliminate these false positives.<br>本地变量存储了闲置不用的对象，也就是说这个变量是多余的。<br>Hashtable   hTable = new  Hashtable();<br>Object   obj = new   Object();<br>obj =  hTable.put(“uuid”,   “abcd1234”);<br> String abc = “abc”;<br> String xyz = new String(“”);<br> xyz = abc;<br> System.out.println(xyz);<br>用findbug檢查會出現Dead store to local variable的錯誤，他的意思是“本地变量存储了闲置不用的对象”<br>為什么會出現這個原因呢？ 因為 String xyz = new String(“”);<br>  这一句执行3个动作：<br>  1)创建一个引用xyz<br>  2)创建一个String对象<br>  3)把String的引用赋值给xyz<br>  其中，后面两个动作是多余的，因为后面的程序中你没有使用这个新建的String对象，而是重新给xyz赋值，<br>xyz = abc;所以，只需要String xyz = abc; 就可以了。这样，findbugs就不会报了。</p>
<p>2、Write to static field from instance method 向static字段中写入值<br>举例：<br> private static DBRBO dbrBO;<br> public final void refresh() {<br>        danskeBankBO = null;<br>        dbrBO = null;<br>        fileAndPathBO = null;<br>    }<br>建议改为：<br>去掉static。</p>
<p>This instance method writes to a static field. This is tricky to get correct if multiple instances are<br>being manipulated, and generally bad practice.<br>向static字段中写入值，如：</p>
<p>private static Logger logger;<br> public XXXActionCtrl(){<br>  logger = Logger.getLogger(getClass());<br> }<br>可改为：private static Logger logger = Logger.getLogger(getClass());Unread field: should this field be static?<br>This class contains an instance final field that is initialized to a compile-time static value. Consider </p>
<p>3、Load of known null value 大体意思是加载了null的对象。<br>举例<br>        if (null == boList) {<br>            for (int i = 0; i &lt; boList.size(); i++) {<br>                entityList.add(productBOToEntity(boList.get(i)));<br>            }<br>        }</p>
<p>4、Exception is caught when Exception is not thrown<br>这个意思比较好理解：就是catch了异常但是try里并没有抛出异常<br>    异常被捕获但没抛出。。。。<br>     一般人都会这样写代码：<br>　　try{<br>　　　　//<br>　　}<br>　　catch(Exception ex){<br>　　　　//<br>　　}<br>    这样很省事，但是JAVA规范中并不推荐这样做，这样是属于“过泛地捕获异常”，因为try{}中可能出现的异常种类有很多，上面的做法不利于分别处理各种异常，<br>建议根     据业务需求，分别捕获需要特别处理的异常，例子如下：<br>　　try{<br>　　　　//<br>　　}<br>　　catch(SQLException ex){<br>　　　　//<br>　　}<br>　　catch(IOException ex){<br>　　　　//<br>　　}<br>　　catch(Exception ex){<br>　　　　//<br>　　}<br>    另外一个是，捕获到的Exception应尽量记录到LOG文件里。 </p>
<p>5、Method ignores exceptional return value<br>没有对方法的异常返回值进行检查</p>
<p>6、Comparison of String objects using == or !=<br>This code compares java.lang.String objects for reference equality using the == or != operators.<br>Unless both strings are either constants in a source file, or have been interned using the String.intern() method,<br> the same string value may be represented by two different String objects. Consider using the equals(Object) method<br>  instead.<br>  从字面意思可以理解String对象进行比较的时候：只有两种情况可以使用== or !=的，这两种情况是；在源文件中是个常数或者是调用<br>  String.intern()方法，使用String的规范化表示形式来进行比较,如果不是这两中情况的话推荐使用.equals(object)方式</p>
<p>7、Method names should start with a lower case letter<br>这个好理解方法名的第一个字母不能是大写 函数的首字母应该小写。</p>
<p>8、Non-transient non-serializable instance field in serializable class<br>This Serializable class defines a non-primitive instance field which is neither transient, Serializable,<br> or java.lang.Object, and does not appear to implement the Externalizable interface or the readObject()<br>  and writeObject() methods.? Objects of this class will not be deserialized correctly if a non-Serializable object<br>   is stored in this field.<br>这个错误的意思是：在可序列化的类中存在不能序列化或者不能暂存的数据<br>在可序列化的类中存在不能序列化或者不能暂存的数据</p>
<p>9.Call to equals() comparing different types<br>    大部分都是类型永远不会有这种情况 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的的<br>equals比较了不同的对象类型 说的是equals要比较相同的对象类型<br>This method calls equals(Object) on two references of different class types with no common subclasses.<br>Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some<br>application classes were not analyzed, or dynamic class loading can occur at runtime). According to the<br>contract of equals(), objects of different classes should always compare as unequal; therefore, according<br>to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be<br>false at runtime.<br>调用equals()比较不同的类型。<br>此方法调用相当于两个不同的类类型的引用，没有共同的子类（对象）。<br>因此，所比较的对象是不太可能在运行时相同的类成员（除非一些<br>应用类没有分析或动态类加载可以发生在运行时）。据<br>equals()的规则，不同类的对象应始终比较不平等，因此，根据<br>由java.lang.Object.equals定义的合同（对象），FALSE将永远是比较的结果<br>在运行时错误。</p>
<p>10.Class doesn’t override equals in superclass<br>  super.equals(obj) 调用父类equals方法 一般都是Object的方法，所以这个super可写可不写，一般都是 为了代码的可读性才加上去的<br>    一般就是重写equals(obj)即可 即public boolean equals(Object obj){ return super.equals(obj);}<br>    但是如果覆盖了equals()方法的话，则必须要覆盖hashCode()方法。否则FINDBUGS会出现下面的7号BUG:覆盖了equals()方法的话，则必须要覆盖hashCode()方法<br>    所以 public boolean equals(Object obj){ return super.equals(obj);}<br>         public int hashCode(){<br>   return super.hashCode();<br>}</p>
<p>11.Class is Serializable, but doesn’t define serialVersionUID<br>    serialVersionUID 用来表明类的不同版本间的兼容性<br>    简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，<br>JVM会把传来的字节流中的serialVersionUID与本地      相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，<br>可以进行反序列化，否则就会出现序列化版本不一致的异常。<br>    当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，<br>Java序列化机制会根据编译的class自动生成一个       serialVersionUID作序列化版本比较用，这种情况下，<br>只有同一次编译生成的class才会生成相同的serialVersionUID 。<br>    如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，<br>就需要显式地定义一个名为serialVersionUID，类型为long     的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。<br>    也就是这个错误 你要定义一个名为 serialVersionUID，类型为long的变量 按照新版Eclipse自动填写规则 就是：<br>     private static final long serialVersionUID = 1L;</p>
<p>12.Class names shouldn’t shadow simple name of superclass<br>   基本就是这个类的名字跟超类的名字一样但不在一个包里 所以就改下类名啦</p>
<p>13.Comparison of String parameter using == or !=<br>   原因：当比较两个字符串内容是否相同时，仅当两个字符串在源文件中都是常量时或者是使用intern()来比较才可以用==来比较，<br>   否则最好使用对象比较方法equal。附string比较：<br>    String str1 = “java”;<br>    String str2 = “java”;<br>    System.out.print(str1==str2);<br>    结果：true(二者都为常量)<br>    String str1 = new String(“java”);<br>    String str2 = new String(“java”);<br>    System.out.print(str1==str2);<br>    结果：false（二者为对象）<br>    String str1 = “java”;<br>    String str2 = “blog”;<br>    String s = str1+str2;<br>    System.out.print(s==”javablog”);<br>    结果：false(s不为常量，为对象)<br>    String s1 = “java”;<br>    String s2 = new String(“java”);<br>    System.out.print(s1.intern()==s2.intern());<br>    结果：true(但是intern（）方法在效率和实现方式上不统一)</p>
<p>14.Equals checks for noncompatible operand<br>    equals()方法比较的是值是否相同，而不是内存指向地址<br>   就实际情况来看 是因为<br>   public boolean equals(Object object) {<br>   if (!(object instanceof DmZzmm)) {<br>    return false;<br>   }<br>         Dxinfo rhs = (Dxinfo) object;<br>    return new EqualsBuilder().append(this.dxcount, rhs.dxcount).append(this.lxrsjh, rhs.lxrsjh)<br>      .append(this.dxnr, rhs.dxnr).append(this.fssj, rhs.fssj).append(this.fssl, rhs.fssl)<br>      .append(this.id,rhs.id).isEquals();<br>            。。。。<br>      }<br>      问题在那里？很简单 这个白痴是拷贝的代码 既然object 不为DmZzmm就为false<br> 而你要执行的是 Dxinfo rhs = (Dxinfo) object; 所以如果为DMZzmm进入代码<br> 会因为不是 Dxinfo 类型而不执行下面的代码 如果为Dxinfo 类型 它就直接执行为FALSE!!所以代码毫无意义 只会执行false!!<br>      所以只需要把<br>      public boolean equals(Object object) {<br>   if (object instanceof Dxinfo) {<br>    Dxinfo rhs = (Dxinfo) object;<br>    。。。。。。。<br>   }else{<br>    return false;<br>   }<br> 就可以了 说穿了 就是你准备用instanceof 匹配的类要跟你下面执行的类要一致。。。。</p>
<p>15.equals method always returns false<br>   equals始终返回false<br>      嘛。。。就是没继承超类的话要自己写个EQUALS。。。。别写的没意义只有false就是了。。<br>      public boolean equals(Object o) {<br>   return (this==o);<br>}</p>
<p>16.equals() method does not check for null argument<br>   equals（）方法没检查空参数<br>      2B错误完全不解释</p>
<p>17.Field names should start with a lower case letter<br>    字段名应该用小写</p>
<p>18.Can’t close pw since it is always null<br>    无法关闭【PW】因为总是为NULL</p>
<p>19.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)/AM:<br> Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)<br>示例代码：<br>ZipEntry entry = new ZipEntry(PATH);<br>zos.putNextEntry(entry);<br>zos.closeEntry();<br>原因：<br>代码中在调用putNextEntry()之后紧接着调用了closeEntry()函数，致使该jar文件内容为空，<br>因为打jar包的写内容是在putNextEntry()和closeEntry()两个函数调用之间来进行的。（有时候也许会有意的构建一个空目录，因此不一定就是bug）</p>
<p>20.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)<br>示例代码：<br>public class Foo {<br>   // some code<br>   public void equals(Object o) {<br>     Foo other = (Foo) o;<br>    // the real equals code<br>  }<br>}<br>原因：<br>当你在实现类的equals方法时，不应该对参数有任何的预先设定。如上代码所写，<br>则设定了参数o肯定是Foo类的一个对象.但是如果在函数调用时，参数o不是一个Foo类或其子类，<br>就会导致代码会抛出一个ClassCastException。因此在实现equals方法，应该加一个判断，如果参数o不是一个Foo类对象，则返回false。</p>
<p>21.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)<br>示例代码：<br>public int getRandom(int seed) {<br>    return new Random(seed).nextInt();<br>}<br>原因：<br>由于java.util.Random是一个伪随机函数，如果传入的seed值相同的话，返回的随机数者是相同的 。<br>因此没必要每次都new一个新的random出来计算随机数。如果你想真正地获得一个不可预知的随机数，<br>建议使用java.security.SecureRandom，该类继承自Random，是一个强随机数生成器 。因此上述代码可以修改为：<br>public class Test  extends Thread{<br>    private SecureRandom ran;<br>    Test(int seed){<br>        ran = new SecureRandom();<br>    }</p>
<pre><code>public int getRandom(int seed) {
    return ran.nextInt();
}</code></pre><p>}</p>
<p>22.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)<br>示例代码：<br>public class Foo implements Cloneable {<br>         public Object clone() throws CloneNotSupportedException {<br>                  return super.clone();<br>         }</p>
<p>}<br>原因：<br>类定义要实现了 Cloneable接口，却没有定义或使用 clone方法，即缺少红色字体部分。</p>
<p>23.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)<br>示例代码：<br>public class Foo implements Cloneable {<br>         public Object clone() throws CloneNotSupportedException {<br>                   return super.clone();<br>         }<br>}<br>原因：<br>clone方法没有调用super.clone()方法，如果没有调用，则会导致对象父子层级关系不能正确建立，最终导致无法正确组装对象。</p>
<p>24.CN: Class defines clone() but doesn’t implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)<br>示例代码：<br>public class Foo{<br>         public Object clone() throws CloneNotSupportedException {<br>                   return super.clone();<br>         }<br>}<br>原因：<br>这个用法的意义在于你可以规范该类的子类的clone的实现，如果你的确想这样做的话，这不是一个bug,否则的话是一个bug</p>
<p>25.DE: Method might drop exception (DE_MIGHT_DROP)/DE: Method might ignore exception (DE_MIGHT_IGNORE)<br>示例代码：<br>try{}catch(Exception ex){}<br>原因：<br>方法有可能抛异常或者忽略异常，需要对异常进行处理,即需要在catch体中对异常进行处理。</p>
<p>8.DMI: Don’t use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)<br>原因：<br>建议不要使用 collection.removeAll(collection)方法来删除 collection中的所有元素，而使用collection.clear()。比较二者的代码实现就可以看出：<br>removeAll()源码：<br>    public boolean removeAll(Collection<!--?--> c) {
              boolean modified = false;
              Iterator<!--?--> e = iterator();<br>              while (e.hasNext()) {<br>                    if (c.contains(e.next())) {<br>                                e.remove();<br>                                 modified = true;<br>                  }<br>              }<br>              return modified;<br>    }<br>clear()源码：<br>    public void clear() {<br>              Iterator<e> e = iterator();<br>              while (e.hasNext()) {<br>                  e.next();<br>                  e.remove();<br>              }<br>    }<br>前者是比较参数中的collection和要移除元素的collection中是否有交集，然后将交集元素删除；<br>后者是直接将collenction中的元素删除。显然后者要比前者高效，而且对于某些特殊的collenction还容易抛出一些异常，<br>如ConcurrentModificationException</e></p>
<p>26.May expose internal representation by incorporating reference to mutable object<br>    JAVA里，对象是引用传递的，setObj的时候，对象不要直接赋值(this.regDate = regDate)，可改为：this.regDate = (Date)regDate.clone();，</p>
<p>27.Uninitialized read of field in constructor<br>      构造函数没有初始化;</p>
<p>28.Method concatenates strings using + in a loop<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is<br>converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a<br>cost quadratic in the number of iterations, as the growing string is recopied in each iteration.<br>Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>字符串串联使用方法在一个循环+<br>该方法似乎是建立在循环使用字符串串联。在每次迭代中，字符串转换为一个StringBuffer / StringBuilder的，<br>附加到 并转换回为String。这可能导致成本的二次迭代，因为不断增长的字符串是在每次迭代中重新复制。<br>更好的性能，可使用StringBuffer（或StringBuilder的）会更好一些。<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();</p>
<p>29.<br>May expose internal representation by incorporating reference to mutable<br>object.This code stores a reference to an externally mutable<br>object into the internal representation of the object.If instances<br>are accessed by untrusted code,and unchecked changes to the mutable object would compromise security or<br>other important properties,you will need to do something different.<br>Storing a copy of the object is better approach in many situations.<br>可能因使引用可指向多个对象而暴露内部存储结构。<br>这代码使一个指向外部多个对象的引用指向了一个内部对象存储地址。<br>如果实例被未被信任代码访问或多个对象发生了未经检查的改变就会危及安全性或其它重要属性，<br>你需要去做一些不同的事情。存储一个对象的拷贝在许多情况下会是一个更好的方法。<br>网上findbug使用的介绍文章中写到,按下面修改findbug就没bug提示了,<br>为什么要放到一个临时变量中就可以了?<br>public class Test {<br>private String[] name;<br>public String[] getName() {<br>String[] temp = name;<br>return temp;<br>}public void setName(String[] name) {<br>String[] temp = name;<br>this.name = temp;<br>}<br>}<br>因为代码中会经常出现getter/setter，我觉得这个bug是不必要进行修改的。</p>
<p>30.<br>making the field static.<br>未读的领域：这个领域应该是静态的？<br>这个类包含一个实例的最后字段初始化为编译时静态值。考虑静态的领域。（findbugs建议修改该属性为static的）。<br>如：private final String FAIL_FLAG = “exit”;<br>改为：private static final String FAIL_FLAG = “exit”;</p>
<p>31.<br>Unread field<br>This field is never read.  Consider removing it from the class.<br>未读的领域（字段，属性）<br>类中声明了从未用过的字段。考虑从类中删除。</p>
<p>32.<br>Inefficient use of keySet iterator instead of entrySet iterator<br>This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator.<br>It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.<br>低效利用，使用keySet迭代器而不是entrySet迭代器。<br>使用entrySet效率会比keySet高。<br>keySet()迭代后只能通过get()取key。<br>entrySet()迭代后可以e.getKey()，e.getValue()取key和value，返回的是Entry接口。</p>
<p>33.<br>Field isn’t final but should be.<br>A mutable static field could be changed by malicious code or by accident from another package. The field<br>could be made final to avoid this vulnerability.<br>字段应该声明为final，实际上却未声明final。<br>一个易变的static字段可以被恶意代码改变，使用final关键字以避免此漏洞。</p>
<p>34.<br>Call to equals() with null argument.<br>This method calls equals(Object), passing a null value as the argument.<br>According to the contract of the equals() method, this call should always return false.<br>使用null参数调用equals()。<br>此方法调用等于（对象），作为参数传递一个空值。根据合同的equals（）方法，此调用应始终返回false。<br>如：queryStr.equals(null); 这样使用是不可取的，虽然能够通过编译。</p>
<p>35.<br>Invocation of toString on an array.<br>The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472.<br>Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array.<br>See Programming Puzzlers, chapter 3, puzzle 12.<br>对数组调用toString()方法。<br>代码在对数组调用toString()方法时，将产生一个相当无用的形如 [C@16f0472 的结果。考虑使用 Arrays.toString方法</p>
<p>将数组转化为一个可读的给出数组内容的字符串。<br>比如：在使用System.out.println(xx.readNext());时候会碰到这样的提示，readNext() 方法放回一个String[]。<br>可改为：<br>String[] arr = reader.readNext();<br>System.out.println(Arrays.asList(arr).toString());<br>（好像有点麻烦，没想到更简洁的办法）。</p>
<p>36.<br>Nullcheck of value previously dereferenced<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously<br>dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference.<br>Essentially, this code and the previous dereference disagree as to whether this value is allowed to be<br>null. Either the check is redundant or the previous dereference is erroneous.<br>此代码之前废弃null值检查。<br>一个值被选中这里看它是否是空的，但这个值不能为空，因为它在此之前废弃null值检查，而且如果它为null，空指针异<br>常将会发生在此处，如果它是空一空指针异常会发生在较早取消引用。<br>从本质上讲，此代码和前边废弃的null值检查将会出现不一致，是否这个值是容许<br>空。<br>出现该bug有两种情况：多余的null检查；前边废弃null值检查的。<br>比如：我们经常会这个使用ActionForm，<br>String clazzId = request.getParameter(“clazzId”);// script1<br>studentForm.setClazzID(clazzId);// script2<br>往往会在script2会出现该错误，因为在script1出未检查clazzId是否为null才导致的。<br>修改为 ：<br>if(clazzId != null) {<br>studentForm.setClazzID(clazzId);<br>}<br>在设置使用clazzId之前先判断其是否为null。</p>
<p>37.<br>Possible null pointer dereference in method on exception path<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>在异常部分放弃null值检查，可能会导致后面的代码出现空指针异常。如：<br>md = null;<br>try {<br>   md = MessageDigest.getInstance(“SHA-256”);<br>   md.update(bt);<br>  } catch (NoSuchAlgorithmException e) {<br>   e.printStackTrace();// script1<br>  }<br>  byte[] digest = md.digest();// script2<br>bug出现在script2处，在script1处处理相应的exception即可，如throw 或 return； </p>
<p>Possible null pointer dereference<br>There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of FindBugs.<br>可能的空指针引用。<br>如在JDBC编程时候，在关闭ResultSet时候(rs.close())，经常会出现这个bug，解决办法很容易想到，判断是否为null或</p>
<p>使用try…catch…finally。</p>
<hr>
<p>相关资料：</p>
<p>1：hyddd的FindBugs分析记录<br>用FindBugs分析代码漏洞 hyddd  阅读:6139 评论:13<br><a href="http://www.cnblogs.com/hyddd/tag/hyddd%E7%9A%84FindBugs%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/tag/hyddd%E7%9A%84FindBugs%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/</a> </p>
<p>1.[hyddd的FindBugs分析记录][H STCAL] Call to static DateFormat<br>上面的英文解释其实应该说得比较清楚，在Java文档中，已经明确说明了DateFormats 是非线程安全的，<br>而在SimpleDateFormat的Jdk 的Source文件中，我们也找到这么一段注释，说明它不是线程安全的。<br>导致SimpleDateFormat出现多线程安全问题的原因，是因为：SimpleDateFormat处理复杂，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。<br>而Findbugs所说的“Call to static DateFormat”，其实就是一些人：<br>为了渐少new 的次数而把SimpleDateFormat做成成员或者静态成员，上面已经说了，这样做是不安全的。</p>
<p>2.[hyddd的FindBugs分析记录][M S XSS] Class defines clone() but doesn’t implement Cloneable<br>[H B CN] Class defines clone() but doesn’t implement Cloneable [CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE]<br>This class defines a clone() method but the class doesn’t implement Cloneable.<br>There are some situations in which this is OK (e.g., you want to control how subclasses can clone themselves),<br>but just make sure that this is what you intended.<br>　　什么代码会引起这个问题呢？先看下面：<br>  1: class MyTest {<br>  2: public MyTest clone(){<br>  3: MyTest test = new MyTest();<br>  4: return test;<br>  5: }<br>  6: }<br>这段代码会引起FindBugs的这个警告，为什么？请看下面解释：<br>1.根据FindBugs的说明，如果一个类重写clone()函数，而不继承Cloneable接口，是一定有问题的，如果clone()方法只是简单进行克隆，<br>如：new一个对象并初始化，然后返回这个新创建的对象的话，不继承Cloneable接口也是可以的。<br>2.如果是上面这样的话，为什么还要继承Cloneable接口呢？稍微说一下，Cloneable接口是不包含任何方法的！<br>其实这个接口仅仅是一个标志，而且这个标志也仅仅是针对Object类中clone()方法的，如果clone类没有实现 Cloneable接口，<br>并调用了Object的clone()方法（也就是调用了super.Clone()方法），那么Object的clone() 方法就会抛出CloneNotSupportedException异常。<br>3.所以这里建议是：规范写法，如果重写clone()，最好请继承Cloneable接口。</p>
<p>3.[hyddd的FindBugs分析记录][M S XSS] Servlet reflected cross site scripting vulnerability<br>[M S XSS] Servlet reflected cross site scripting vulnerability [XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER]<br>This code directly writes an HTTP parameter to Servlet output, which allows for a reflected cross site scripting vulnerability.<br>See <a href="http://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Cross-site_scripting</a> for more information.<br>FindBugs looks only for the most blatant, obvious cases of cross site scripting. If FindBugs found any,<br>you almost certainly have more cross site scripting vulnerabilities that FindBugs doesn’t report. If you are concerned about cross site scripting, you should seriously consider using a commercial static analysis or pen-testing tool.<br>先看下面代码：<br>public void doGet(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException{<br>　　//<br>　　String v = request.getParameter(“v”);<br>　　//<br>　　PrintWriter out = response.getWriter();<br>　　out.print(“协议版本号不对,v=”+v);<br>　　out.close();<br>　　//<br>}<br>这里字符串v没有作过滤，直接返回给用户，有可能操作XSS攻击。具体关于XSS攻击的资料，可以参考上面Findbugs说明中的连接，这里就不多说了。</p>
<p>4.[hyddd的FindBugs分析记录]M D ICAST] Result of integer multiplication cast to long<br>[M D ICAST] Result of integer multiplication cast to long [ICAST_INTEGER_MULTIPLY_CAST_TO_LONG]<br>This code performs integer multiply and then converts the result to a long, as in:<br>  long convertDaysToMilliseconds(int days) { return 1000<em>3600</em>24<em>days; }<br>If the multiplication is done using long arithmetic, you can avoid the possibility that the result will overflow.<br>For example, you could fix the above code to:<br>long convertDaysToMilliseconds(int days) { return 1000L</em>3600<em>24</em>days; }<br>or<br>static final long MILLISECONDS_PER_DAY = 24L<em>3600</em>1000; long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }<br>其实看上面的例子可以看到了<br>long convertDaysToMilliseconds(int days) { return 1000<em>3600</em>24<em>days; }<br>这段代码是有可能溢出的，建议把代码改为下面：<br>long convertDaysToMilliseconds(int days) { return 1000L</em>3600<em>24</em>days; }<br>用过VB6的人应该了解为什么会这样，因为在VB6里面一不小心就有可能出现这种溢出，在这里，JAVA认为：int * int *<br> …..它的结果还是一个int！为什么编译器不能自动识别呢？答案是：很麻烦，并且这会使用编译器的效率非常低！<br> 对于有汇编经验的人来说，应该了解用汇编实现动态判断一个结果应该分配到一个long的空间还是int的空间有多复杂吧，<br> 而编译器有不能随便随便把int * int 的结果分配一个long空间，因为这会非常浪费内存，所以出于对效率和资源的考虑，<br> 最后的决定就是，凡是int * int * ….这样的计算结果一律都存放到int空间里，如果是long * int * …..则一律存放到long空间里，<br> 这就解释了为什么上面要在1000后面加个”L”了。:&gt;</p>
<p>[hyddd的FindBugs分析记录][M B DE] Method might ignore exception<br>This method might ignore an exception.  In general, exceptions should be handled or reported in some way,<br>or they should be thrown out of the method.<br>try{<br>//<br>}<br>Catch(Execption ex){}<br>//<br>上面这段代码没有对ex进行任何处理。Findbugs在这里想说明的就是上面这个问题。</p>
<p>5.[hyddd的FindBugs分析记录][M M IS] Inconsistent synchronization追加说明 </p>
<p>6.[hyddd的FindBugs分析记录][M B Eq] Class defines compareTo(…) and uses Object.equals()<br>重写compareTo有一定的风险，因为你不知道JDK内部做对象对比时，到底使用了compareTo还是equals。<br>例如：在JAVA5 里，PriorityQueue.remove中使用了compareTo，但JAVA6中，PriorityQueue.remove使用了equals方法。<br>　　这里Findbugs强烈建议：(x.compareTo(y)==0) == (x.equals(y))，当你重写compareTo的时候，请记得这一点:&gt;，当然这个只是建议，不是绝对的。</p>
<p>7.[hyddd的FindBugs分析记录][H C EC] equals() used to compare array and nonarray<br>This method invokes the .equals(Object o) to compare an array and a reference that doesn’t seem to be an array.<br>If things being compared are of different types, they are guaranteed to be unequal and the comparison is almost certainly an error.<br>Even if they are both arrays, the equals method on arrays only determines of the two arrays are the same object.<br>To compare the contents of the arrays, use java.util.Arrays.equals(Object[], Object[]).<br>先看下面一段代码：<br>String[] strs = {“1”};<br>//.<br>If(“1”.equals(strs)){<br>//todo<br>}<br>上面这段代码，if里面的代码是永远都不会被执行的，因为我们用了一个非数据（nonarray）和一个数组(array)做equals()，这里估计是写代码时的笔误。</p>
<p>8.[hyddd的FindBugs分析记录][H C FS] Format string references missing argument<br>Not enough arguments are passed to satisfy a placeholder in the format string.<br>A runtime exception will occur when this statement is executed.<br>看实例代码：<br>public static void main(String args[]) throws Exception{<br>    String sqlrightDate = “select state from right where user_id = ‘%s’ and soft_code =’%s’ and right_name = ‘%s’ “;<br>    String str = String.format(sqlrightDate,”1” ,”2”);<br>    System.out.println(str);<br>}<br>对，你没有眼花，format里面只传了两个参数，但sqlrightData需要的是三个参数！这可能值是你的一个笔误，<br>相信没人会故意写这样的代码，但编译器检查不出这种问题，这导致运行时这里会抛异常，所以用FindBugs扫扫代码还是有点用处的～！</p>
<p>9.[hyddd的FindBugs分析记录][M B Nm] Class names should start with an upper case letter<br>JAVA里，类的首字母需要大写，这个不多说了。</p>
<p>10.[hyddd的FindBugs分析记录][H B BC] Random object created and used only once<br>1.new一个Random的对象，保存之，然后每次都使用这个对象去获取随机数，而不要每次new一个Random对象去获取。<br>2.FindBugs强烈推荐使用java.security.SecureRandom代替Random。</p>
<p>11.[hyddd的FindBugs分析记录][M D REC] Exception is caught when Exception is not thrown<br>略 上有</p>
<p>12.[hyddd的FindBugs分析记录][M D DLS] Dead store to local variable<br>略 上有</p>
<p>13.[hyddd的FindBugs分析记录][M P UuF] Unused field<br>说明某个类里的某个变量没有被使用。FindBugs建议你把无用东西去除掉。</p>
<p>14.[hyddd的FindBugs分析记录][M B ODR] Method may fail to close database resource<br>请参考：[M X OBL] Method may fail to clean up stream or resource<br>注意：同一个问题可能引发两个不同的BUG警告～！</p>
<p>15.[hyddd的FindBugs分析记录][M X OBL] Method may fail to clean up stream or resource<br>[M X OBL] Method may fail to clean up stream or resource [OBL_UNSATISFIED_OBLIGATION]<br>This method may fail to clean up (close, dispose of) a stream, database object, or other resource requiring an explicit cleanup operation.<br>In general, if a method opens a stream or other resource, the method should use a try/finally block to ensure that the stream<br> or resource is cleaned up before the method returns.<br>This bug pattern is essentially the same as the OS_OPEN_STREAM and ODR_OPEN_DATABASE_RESOURCE bug patterns,<br>but is based on a different (and hopefully better) static analysis technique. We are interested is getting feedback about the<br>usefulness of this bug pattern. To send feedback, either:<br>send email to <a href="mailto:findbugs@cs.umd.edu">findbugs@cs.umd.edu</a><br>file a bug report: <a href="http://findbugs.sourceforge.net/reportingBugs.html" target="_blank" rel="noopener">http://findbugs.sourceforge.net/reportingBugs.html</a><br>In particular, the false-positive suppression heuristics for this bug pattern have not been extensively tuned,<br>so reports about false positives are helpful to us.<br>See Weimer and Necula, Finding and Preventing Run-Time Error Handling Mistakes, for a description of the analysis technique.<br>这个BUG想说明的是：有些资源打开了，但在函数结束的时候却没有关闭。比如：数据库连接……<br>虽然JAVA有垃圾回收机制，但是，自己打开的资源需要自己手动关闭，否则有可能直到程序退出，JRE才会清理你打开的资源。<br>这里FindBugs建议在try/finally里面关闭打开的资源，在关闭之前，还要判断资源是否为Null，或者再加一层异常捕获处理噢～<br>以下是一些可能关闭资源失败的例子<br>———————————————–情况1—————————————–<br>//<br>FileOutputStream fs = null;<br>try{<br>　　fs = new FileOutputStream(clearTableFile);<br>　　fs.close();    //当出异常时候fs关闭失败，所以应该在finally中关闭<br>}<br>catch(){<br>//<br>}<br>———————————————–情况2—————————————–<br>//<br>Properties props = new Properties();<br>try{<br>　　props.store(new FileOutputStream(configFile), configFile);　　//new FileOutputStream(configFile)没有释放。<br>}<br>catch(){<br>　　//<br>}<br>———————————————–情况3—————————————–<br>　　//<br>　　FileOutputStream fs = new FileOutputStream(clearTableFile);<br>　　//    (里没有做异常处理，如果中间出异常了，异常会抛往上层，这时fs就没能释放了。<br>　　fs.close();<br>　　//</p>
<p>16.[hyddd的FindBugs分析记录][M M NP] Synchronize and null check on the same field<br> [M M NP] Synchronize and null check on the same field. [NP_SYNC_AND_NULL_CHECK_FIELD]<br>Since the field is synchronized on, it seems not likely to be null. If it is null and then synchronized on a<br>NullPointerException will be thrown and the check would be pointless. Better to synchronize on another field.<br>先看一段代码：<br>public static Timestamp getTableLastUpdateTime(String tableName) {<br>    Timestamp time = null;<br>    synchronized (GoodsSysConfig.tableLastUpdateTime) {<br>　　　    if (GoodsSysConfig.tableLastUpdateTime != null) {　　//这句判断是多余的，可以去掉！<br>　　　　　　　time = GoodsSysConfig.tableLastUpdateTime.get(tableName);<br>　　　　　　}<br>　　　　　　else {<br>　        　log.error(“GoodsSysConfig.tableLastUpdateTime 为空!”);<br>        }<br>    }<br>    return time;<br>}</p>
<p>这段代码会引发两个BUG警告，一个是：[H C RCN] Nullcheck of value previously dereferenced，<br>另外一个就是这里要介绍的[M M NP] Synchronize and null check on the same field。其实，<br>在[H C RCN] Nullcheck of value previously dereferenced的介绍里面已经提到Synchronize and null check on the same field这个问题了，<br>出现这个BUG的原因是：synchronized (GoodsSysConfig.tableLastUpdateTime) 这里已经对GoodsSysConfig.tableLastUpdateTime这个变量进行了是否为Null的判断，<br>如果为Null，synchronized (…)会抛异常，并且经过synchronized (…)后，GoodsSysConfig.tableLastUpdateTime已经被独占，<br>所以 if (GoodsSysConfig.tableLastUpdateTime != null) 这句可以看作是多余的，因为GoodsSysConfig.tableLastUpdateTime不可能为Null。</p>
<p>17.[hyddd的FindBugs分析记录][M V MS] Public static method may expose internal representation by returning array<br>[M V MS] Public static method may expose internal representation by returning array [MS_EXPOSE_REP]<br>A public static method returns a reference to an array that is part of the static state of the class.<br>Any code that calls this method can freely modify the underlying array. One fix is to return a copy of the array.<br>一个静态的公共函数，它返回了一个私有的静态数组的引用。任何调用这个静态公共函数的代码，都有可能改变这个私有的静态数组。实例代码如下：<br>public static void main(String args[]) throws Exception{<br>        String[] strs = Test.getStrs();<br>        strs[0] = “123”;<br>        Test.myTest();<br>}<br>public class Test {<br>    private static String[] strs = new String[10];</p>
<pre><code>public static String[] getStr(){
    return strs;
}
public static void myTest(){
    System.out.println(strs[0]);
}</code></pre><p>}<br>运行结果是：123<br>防止这种问题的方法是：返回一个数组的拷贝，而不直接返回数组引用。如：<br>public static String[] getStr(){<br>        return strs.clone();<br>}<br>注意：这个BUG和下面这两个BUG比较类似，可以比较一下:&gt;<br>[M V EI2] May expose internal representation by incorporating reference to mutable object<br>[M V EI] May expose internal representation by returning reference to mutable object</p>
<p>18.[hyddd的FindBugs分析记录][M C NP] Possible null pointer dereference<br>[M C NP] Possible null pointer dereference [NP_NULL_ON_SOME_PATH]<br>There is a branch of statement that, if executed, guarantees that a null value will be dereferenced,<br>which would generate a NullPointerException when the code is executed. Of course,<br>the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed;<br>deciding that is beyond the ability of FindBugs.<br>看一段代码：<br>public void test(){<br>  //<br>  ResultSet rs = cmd.executeQuery();<br>  if (rs != null &amp;&amp; rs.next()) {<br>    goodsId = rs.getInt(“goods_id”);<br>  }<br>  rs.close();　　//rs可能为null<br>  //<br>}<br>这里不多解释，更正代码的方法很多，可以用try…catch…finally…处理可能出现的异常，也可以在rs.close之前，先判断rs是否为null。</p>
<p>19.[hyddd的FindBugs分析记录][M B Nm] Method names should start with a lower case letter<br>在Java里，函数的首字母应该小写。<br>而.Net和Java不同，它要求函数的首字母必须大写。<br>这个问题是个规范问题，这里就不提供实例代码了。</p>
<p>20.[hyddd的FindBugs分析记录][M P Dm] Method invokes toString() method on a String<br>[M P Dm] Method invokes toString() method on a String [DM_STRING_TOSTRING]<br>Calling String.toString() is just a redundant operation. Just use the String.<br>对一个String对象使用了toString()方法，这种操作是多余的，完全可以去掉。<br>public static void main(String args[]) throws Exception{<br>        String str = “123”;<br>        System.out.println(str.toString());<br>}</p>
<p>21.[hyddd的FindBugs分析记录][M P Bx] Method invokes inefficient Number constructor; use static valueOf instead<br> [M P Bx] Method invokes inefficient Number constructor; use static valueOf instead [DM_NUMBER_CTOR]<br>Using new Integer(int) is guaranteed to always result in a new object whereas Integer.valueOf(int)<br>allows caching of values to be done by the compiler, class library, or JVM.<br>Using of cached values avoids object allocation and the code will be faster.<br>Values between -128 and 127 are guaranteed to have corresponding cached instances and using valueOf is<br>approximately 3.5 times faster than using constructor. For values outside the constant range the performance of both styles is the same.<br>Unless the class must be compatible with JVMs predating Java 1.5, use either autoboxing or the valueOf() method when creating instances of Long,<br>Integer, Short, Character, and Byte.<br>这里，FindBugs推荐使用Integer.ValueOf(int)代替new Integer(int)，因为这样可以提高性能。<br>如果当你的int值介于-128～127时，Integer.ValueOf(int)的效率比Integer(int)快大约3.5倍。<br>下面看看JDK的源码，看看到Integer.ValueOf(int)里面做了什么优化：<br>public static Integer valueOf(int i) {<br>  final int offset = 128;<br>  if (i &gt;= -128 &amp;&amp; i &lt;= 127) { // must cache<br>    return IntegerCache.cache[i + offset];<br>  }<br>  return new Integer(i);<br>}<br>private static class IntegerCache {<br>  private IntegerCache(){}</p>
<p>  static final Integer cache[] = new Integer[-(-128) + 127 + 1];<br>  static {<br>  for(int i = 0; i &lt; cache.length; i++)<br>     cache = new Integer(i - 128);<br>  }<br>}<br>从源代码可以知道，ValueOf对-128～127这256个值做了缓存(IntegerCache)，如果int值的范围是：-128～127，在ValueOf(int)时，<br>他会直接返回IntegerCache的缓存给你。<br>所以你会看到这样的一个现象：<br>public static void main(String []args) {<br>     Integer a = 100;<br>     Integer b = 100;<br>     System.out.println(a==b);</p>
<pre><code> Integer c = new Integer(100);
 Integer d = new Integer(100);
 System.out.println(c==d);</code></pre><p>}<br>结果是：<br>true<br>false<br>因为：java在编译的时候 Integer a = 100; 被翻译成-&gt; Integer a = Integer.valueOf(100);，<br>所以a和b得到都是一个Cache对象，并且是同一个！而c和d是新创建的两个不同的对象，所以c自然不等于d。<br>再看看这段代码：<br>public static void main(String args[]) throws Exception{<br>        Integer a = 100;<br>        Integer b = a;<br>        a = a + 1;　　//或者a++;<br>        System.out.println(a==b);<br>}<br>结果是：false<br>因为在对a操作时(a=a+1或者a++)，a重新创建了一个对象，而b对应的还是缓存里的100，所以输出的结果为false。</p>
<p>22.[hyddd的FindBugs分析记录][M C NP] Method call passes null for unconditionally dereferenced parameter<br>[M C NP] Method call passes null for unconditionally dereferenced parameter [NP_NULL_PARAM_DEREF]<br>This method call passes a null value to a method which might dereference it unconditionally.<br>这里FindBugs的解释是：你传入参数的值，有可能是一个NULL。下面看一段代码：<br>public boolean accept(File dir, String name) {<br>            String reg = null;<br>            if (this.type == ChangeConfigUtil.windowsType) {<br>                reg = “^(\S+)” + ChangeConfigUtil.windowsTypeTag<br>                        + “\.(\S<em>)$”;<br>            } else if (this.type == ChangeConfigUtil.linuxType) {<br>                reg = “^(\S+)” + ChangeConfigUtil.linuxTypeTag + “\.(\S</em>)$”;<br>            }</p>
<pre><code>        Pattern p = Pattern.compile(reg, Pattern.MULTILINE);　　//这里reg可能为空
        Matcher m = p.matcher(name);
        if (m.find()) {
            return true;
        } else {
            return false;
        }</code></pre><p>}<br>这里Pattern p = Pattern.compile(reg, Pattern.MULTILINE);可能会出现问题。<br>如果this.type既不等于windows，也不等于linux，那么reg=null，这会导致Pattern.compile(reg, Pattern.MULTILINE);抛异常。<br>这里，FindBugs想说明的就是这个问题。</p>
<p>23.[hyddd的FindBugs分析记录][M V EI] May expose internal representation by returning reference to mutable object<br> 这个问题的解决方案和[M V EI2] May expose internal representation by incorporating reference to mutable object很类似，<br> 可以参考：<a href="http://www.cnblogs.com/hyddd/articles/1391118.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/articles/1391118.html</a></p>
<p>24.[hyddd的FindBugs分析记录][M V EI2] May expose internal representation by incorporating reference to mutable object<br>[M V EI2] May expose internal representation by incorporating reference to mutable object [EI_EXPOSE_REP2]<br>This code stores a reference to an externally mutable object into the internal representation of the object.<br> If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties,<br>you will need to do something different. Storing a copy of the object is better approach in many situations.<br>这个问题和Inconsistent synchronization描述的问题很类似，解决方案也很类似，可以参考看看：<a href="http://www.cnblogs.com/hyddd/articles/1391098.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/articles/1391098.html</a><br>先看一段代码：<br>public class Test  extends Thread{<br>    public static void main(String args[]) throws Exception{<br>        Test3 obj = new Test3();<br>        Date now = new Date();</p>
<pre><code>    obj.setRegDate(now);    
    now.setYear(4000);　　//问题所在！

    System.out.println(obj.getRegDate());
}</code></pre><p>}<br>public class Test3 {<br>    private Date regDate ;<br>    public void setRegDate(Date regDate) {<br>        this.regDate = regDate;<br>    }<br>    public Date getRegDate() {<br>        return regDate;<br>    }<br>}<br>这段代码的输出是：Thu Feb 15 21:47:13 CST 5900<br>如果main里面不加now.setYear(4000);这句代码呢，结果是：Sun Feb 15 21:47:31 CST 2009<br>从这里我们发现了，修改一个对象，可能会引起其他对象的修改，因为JAVA里，对象是引用传递的……所以这里我的建议是：<br>setObj的时候，对象不要直接赋值(this.regDate = regDate)，而是赋值传入对象的拷贝(this.regDate = (Date)regDate.clone();)。<br>OK~现在我们把代码this.regDate = regDate替换成this.regDate = (Date)regDate.clone();，<br>运行一下看看结果，噢，输出是：Sun Feb 15 21:47:31 CST 2009。</p>
<p>25.[hyddd的FindBugs分析记录][M M IS] Inconsistent synchronization<br>[M M IS] Inconsistent synchronization [IS2_INCONSISTENT_SYNC]<br>The fields of this class appear to be accessed inconsistently with respect to synchronization.<br>This bug report indicates that the bug pattern detector judged that<br>The class contains a mix of locked and unlocked accesses,<br>At least one locked access was performed by one of the class’s own methods, and<br>The number of unsynchronized field accesses (reads and writes) was no more than one third of all accesses,<br> with writes being weighed twice as high as reads<br>A typical bug matching this bug pattern is forgetting to synchronize one of the methods in a class that is intended to be thread-safe.<br>You can select the nodes labeled “Unsynchronized access” to show the code locations where the detector believed that a<br>field was accessed without synchronization.<br>Note that there are various sources of inaccuracy in this detector; for example, the detector cannot statically detect all<br> situations in which a lock is held.  Also, even when the detector is accurate in distinguishing locked vs. unlocked accesses,<br> the code in question may still be correct.<br>先上一段代码：<br>public class Test  extends Thread{<br>    public static void main(String args[]) throws InterruptedException{<br>        ObjectClass obj = new ObjectClass();<br>        Thread t2 = new ChangeValue(obj);<br>        t2.start();<br>        Thread t1 = new AlwaysRun(obj);<br>        t1.start();<br>        sleep(10000);<br>        t1.stop();<br>    }<br>}<br>class AlwaysRun extends Thread{<br>    ObjectClass obj;<br>    public AlwaysRun(ObjectClass obj) {<br>        // TODO Auto-generated constructor stub<br>        this.obj = obj;<br>    }<br>    public void run() {<br>        obj.Loop();<br>    }<br>}<br>class ChangeValue extends Thread{<br>    ObjectClass obj;<br>    ChangeValue(ObjectClass obj){<br>        this.obj = obj;<br>    }</p>
<pre><code>public void run() {
    System.out.println("Thread2");
    ObjClass2 obj2 = obj.getObj();
    try {
        sleep(1500);
    } catch (InterruptedException e) {
        System.out.println("Error!");
    }
           obj2.str = "aaa";
    System.out.println("Thread2 Finish!");
}</code></pre><p>}<br>public class ObjectClass extends Thread {</p>
<pre><code>private ObjClass2 obj;
private Object lockTable = new Object();

public ObjectClass() {
    // TODO Auto-generated constructor stub
    obj = new ObjClass2();
}
public void setObj(ObjClass2 obj){
    synchronized (lockTable){
        this.obj = obj;      
    }
}

public ObjClass2 getObj(){
    synchronized (lockTable){
        return this.obj;      //出问题处！！
    }
}

public void Loop(){
    synchronized (lockTable){
        while(true){
            System.out.println(obj.str);
        }
    }
}    </code></pre><p>}<br>public class ObjClass2 {<br>    public String str = “ddddddd”;<br>}<br>看看运行的结果：<br>Thread2<br>ddddddd<br>ddddddd<br>ddddddd<br>ddddddd<br>ddddddd<br>ddddddd<br>ddddddd<br>Thread2 Finish!<br>aaa<br>aaa<br>aaa<br>aaa<br>aaa<br>aaa<br>….</p>
<p>如果看明白代码，你应该会知道问题出再哪里了，为什么Loop使用了synchronized (lockTable)，但是obj.str还是被修改了？！<br>因为getObj()这个函数把obj对象返回了给外面，JAVA里面对象的传递是使用引用传递，如果对象传递到外面并且在做修改obj的时候没有加锁操作，<br>就是引起刚才的问题。所以如果getObj()函数返回的是对象，那么，请返回一个拷贝，而不要直接返回引用。<br>这里再总结一下值得注意问题：<br>1.看下面代码：<br>    public ObjClass2 getObj(){<br>        synchronized (lockTable){<br>            return this.obj;<br>        }<br>    }<br>synchronized (lockTable)不能阻止外面的函数修改obj，即：obj=getObj();当赋值完毕后，synchronized (lockTable)无效了，<br>如果后面需要修改obj的值，那么就得注意了！！！<br>另外建议的是，不直接返回this.obj，而是返回一个this.obj的拷贝。这样可以根本上避免出现上面的问题！<br>2.同理，在setObj(…)的时候，如果传入的是个对象，也建议是存储传入对象的拷贝，而不（this.obj=obj）这样直接赋值。<br>3.注意对竞争的资源都使用synchronized (lockTable)，不要像上面的Demo代码那样，一处用了，一处没有！</p>
<p>26.[hyddd的FindBugs分析记录][M D RCN] Redundant nullcheck of value known to be non-null<br>参考文档：[hyddd的FindBugs分析记录][M C RCN] Nullcheck of value previously dereferenced</p>
<p>27.[hyddd的FindBugs分析记录][M D RCN] Repeated conditional tests<br>[M C RpC] Repeated conditional tests [RpC_REPEATED_CONDITIONAL_TEST]<br>The code contains a conditional test is performed twice, one right after the other (e.g., x == 0 || x == 0).<br>Perhaps the second occurrence is intended to be something else (e.g., x == 0 || y == 0).<br>这个不解释，一看代码就知道：<br>    public void test{<br>　　　　String str = “123”;<br>            if(str!=null){<br>                if(str!=null){　　//重复了<br>                 System.out.println(“123”);<br>                }<br>            }<br>    }</p>
<p>28.[hyddd的FindBugs分析记录][M C RCN] Nullcheck of value previously dereferenced<br>[M C RCN] Nullcheck of value previously dereferenced [RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE]<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously<br>dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference.Essentially,<br>this code and the previous dereference disagree as to whether this value is allowed to be null.<br>Either the check is redundant or the previous dereference is erroneous.<br>先看一段代码：<br>public class MyTest {<br>    private String str = “123”;<br>    public void setStr(String str){<br>        this.str = str;<br>    }<br>    public String getStr(){<br>        return this.str;<br>    }<br>    public void test(){<br>        String str2 = “123”;<br>        synchronized (str) {<br>            if (str != null) {<br>                str2 =”123”;<br>            } else {<br>                str2 =”456”;<br>            }<br>            System.out.println(str2);<br>        }<br>    }<br>}<br>这个时候这段代码就会报Nullcheck of value previously dereferenced这个Bug，看Bug定位，<br>发现问题出现在synchronized (str) 这里，str没有检查是否为NULL?!OK，我现在改用getStr()这个函数代替直接使用str，<br>即：synchronized (getStr())，重新FindBug……居然没有发现错误-_-，但事实上getStr()并没有检查str是否为Null！！<br>　　现在我换另外一种写法，代码如下：<br>public class MyTest {<br>    private String str = “123”;<br>    public void setStr(String str){<br>        this.str = str;<br>    }<br>    public String getStr(){<br>        return this.str;<br>    }</p>
<pre><code>public void test(){
    String str2 = "123";


    if(str != null){　　　　　　　　//tag2
        synchronized (str) {
            if (str != null) {　　　　//tag1
                str2 ="123";
            } else {
                str2 ="456";
            }           
            System.out.println(str2);
        }
    }

}</code></pre><p>}<br>这次我在tag2处加了一行检查str是否为NULL的代码，看FindBugs结果，<br>出现了另外一个中等BUG：[M D RCN]Redundant nullcheck of value known to be non-null，跟踪发现是tag1处的代码是多余的，<br>因为tag2处已经检查了一遍，并且在synchronized (str)后，str被独占，它不可能被修改，也就是说synchronized (str)后，根本不需要检查str是否为空，<br>tag1处的代码是多余的。如果把tag1处代码去掉，[M D RCN]警告就没有了。<br>　　不知道大家有没有发现，上面的代码还有个问题，看这段代码：<br>if(str != null){<br>        synchronized (str) {<br>            System.out.println(“123”);<br>        }<br>}<br>如果是多线程运行时，你不能排除它会if(str != null)和synchronized(str)之间进行线程切换，<br>然后把str至为null！所以上面这样写其实也是有可能出现问题的！只是FindBugs没有找出来。<br>我觉得最好的写法还是：<br>    public void test() throws Exception{<br>        try{<br>            String str2 = “123”;<br>            synchronized (getStr()) {<br>                str2 =”456”;<br>                System.out.println(str2);<br>            }<br>        }<br>        catch(Exception ex){<br>            throw ex;<br>        }<br>　　　//Do other things….<br>    }<br>其实synchronized (getStr()) 换成synchronized (str) 也是可以的，FindBugs不会再报Bug了。<br>总结一下，我觉得FindBugs之所以会报[H C RCN] Nullcheck of value previously dereferenced，是因为我没有检查str的值是否为Null，<br>并且没有注意对可能出现的Exception的截获。而简单使用getStr()，不检查str的值，不作异常捕获，也能躲过这个Bug，<br>我觉得可能是FindBugs的一个BUG:&lt;，因为估计它会认为，getStr()这个函数里面会检查str的值……但这个仅仅是个人认为而已。</p>
<p>29.[hyddd的FindBugs分析记录][H C FS] More arguments are passed that are actually used in the format string<br>[H C FS] More arguments are passed that are actually used in the format string [VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED]<br>A format-string method with a variable number of arguments is called, but more arguments are passed than are actually used by the format string.<br>This won’t cause a runtime exception, but the code may be silently omitting information that was intended to be included in the formatted string.<br>这个错误很简单，是使用String.format的时候出了问题，format里面的参数没有被全部用上。<br>看下面一段代码：<br>public void test(){<br>    String str1 = “123”;<br>    String str2 = “456”;<br>    String str3 = String.format(“{0} {1}” , str1 ,str2);<br>    System.out.println(str3);<br>}<br>输出的结果是：{0} {1}<br>这个Bug描述就是这种问题，str1和str2根本没有被用上！{0}{1}这种Format格式是.NET上面的用法，java里面应该是%s %s。<br>这个是一个代码逻辑问题，可能是你写代码时不小心导致的，它在这段代码里不会导致异常，但往往会很可能导致其他地方异常，那时候你可能会百思不得其解。</p>
<p>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.<br>修改建议：使用Long.ParseLong，避免自动装箱再拆箱<br>问题原因：<br>Long.ParseLong(String)方法，将 string 参数解析为有符号十进制 ，返回一个long的基本类型值<br>Long.ValueOf(String) ,方法得到的值非常相似。只是最后被转换为一个Long的包装类<br>This class is an inner class, but does not use its embedded reference to the object which created it. This reference makes the instances of the class larger, and may keep the reference to the creator object alive longer than necessary. If possible, the class should be made static.<br>修改建议：若成员类中未访问外围类的非静态成员，为避免额外的空间和时间开销，建议改用静态成员类。<br>问题原因：<br>非静态成员类和静态成员类的区别在于，非静态成员类是对象的，静态成员类是类的。非静态成员类可以访问外围类的任何成员，但前提是必须存在外围类对象。JAVA需要额外维护非静态成员类和外围类对象的关系。<br>This code generates a hashcode and then computes the absolute value of that hashcode. If the hashcode is Integer.MIN_VALUE, then the result will be negative as well (since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE).<br>One out of 2^32 strings have a hashCode of Integer.MIN_VALUE, including “polygenelubricants” “GydZG_” and “”DESIGNING WORKHOUSES”.<br>修改建议：在使用之前判断一下是否是为Integer.MIN_VALUE<br>问题原因：<br>此代码产生哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负的（因为Math.abs（Integer.MIN_VALUE）==Integer.MIN_VALUE）。<br>A boxed value is unboxed and then immediately reboxed.<br>修改建议：三元运算符两个分支的返回类型保持一致。<br>问题原因：<br>装箱的值被拆箱，然后立刻重新装箱<br>This class defines a field with the same name as a visible instance field in a superclass. This is confusing, and may indicate an error if methods update or access one of the fields when they wanted the other.<br>修改建议：要么去掉其中一个字段，要么重新命名。<br>问题原因：<br>变量与超类中的可访问静态变量重名，使用时会造成迷惑</p>
<p>This private method is never called. Although it is possible that the method will be invoked through reflection, it is more likely that the method is never used, and should be removed.<br>修改建议：删除该方法<br>问题原因：<br>这个私有方法没有被调用。虽然可能通过反射的方法将被调用，更可能从未使用过，应该被删除。</p>
<p>This method calls equals(Object) on two references of different class types and analysis suggests they will be to objects of different classes at runtime. Further, examination of the equals methods that would be invoked suggest that either this call will always return false, or else the equals method is not be symmetric (which is a property required by the contract for equals in class Object).<br>修改建议：<br>去除这种无意义的判断<br>问题原因：<br>两个不同类型实例通过equals方法，通常情况下都会判断为非相同对象，其返回值也将始终为false。<br>例如，调用string的equals方法比较double类型，永远都会返回false，如果把这个作为逻辑判断是没有意义的</p>
<p>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.<br>Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>修改建议：使用StringBuilder/StringBuffer<br>问题原因：<br>在循环里使用字符串连接，效率低<br>A reference value which is null on some exception control path is dereferenced here. This may lead to a NullPointerException when the code is executed. Note that because SpotBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that SpotBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>修改建议：对引用对象进行判空<br>问题原因：<br>代码调用时，遇到异常分支，可能造成一个对象没有获得赋值依旧保持NULL空指针。接下来如果对这个对象有引用，可能造成NullPointerException空指针异常。<br>A String function is being invoked and “.” or “|” is being passed to a parameter that takes a regular expression as an argument. Is this what you intended? For example</p>
<ul>
<li>s.replaceAll(“.”, “/”) will return a String in which every character has been replaced by a ‘/’ character</li>
<li>s.split(“.”) always returns a zero length array of String</li>
<li>“ab|cd”.replaceAll(“|”, “/”) will return “/a/b/|/c/d/”</li>
<li>“ab|cd”.split(“|”) will return array with six (!) elements: [, a, b, |, c, d]<br>修改建议：<br>在前面加上“\”转义符。<br>问题原因：<br>String的split方法传递的参数是正则表达式，正则表达式本身用到的字符需要转义，如：句点符号“.”，美元符号“$”，乘方符号“^”，大括号“{}”，方括号“[]”，圆括号“()” ，竖线“|”，星号“*”，加号“+”，问号“?”等等，这些需要在前面加上“\”转义符。<br>There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of SpotBugs.<br>修改建议：<br>判断header是否为null或使用try…catch…finally。<br>问题原因：可能存在空引用<br>This method call passes a null value for a non-null method parameter. Either the parameter is annotated as a parameter that should always be non-null, or analysis has shown that it will always be dereferenced.<br>修改建议：赋予函数参数默认值。<br>问题原因：传递了一个空值给函数参数<br>The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,<br>String dateString = getHeaderField(name);<br>dateString.trim();<br>the programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:<br>String dateString = getHeaderField(name);<br>dateString = dateString.trim();<br>修改建议：定义变量接收方法的返回值<br>问题原因：忽略了该方法的返回值<br>This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.<br>修改建议：遍历entry（桶）然后直接从entry得到value<br>问题原因：<br>很多人都这样遍历Map，没错，但是效率很低，先一个一个的把key遍历，然后在根据key去查找value，这不是多此一举么，为什么不遍历entry（桶）然后直接从entry得到value呢？它们的执行效率大概为1.5:1<br>This code creates an exception (or error) object, but doesn’t do anything with it. For example, something like</li>
</ul>
<p>if (x &lt; 0) {<br>    new IllegalArgumentException(“x must be nonnegative”);<br>}<br>It was probably the intent of the programmer to throw the created exception:</p>
<p>if (x &lt; 0) {<br>    throw new IllegalArgumentException(“x must be nonnegative”);<br>}</p>
<p>修改建议：将创建的异常抛出<br>问题原因：创建了一个异常对象，但是没有对它做任何操作</p>
<p>Using the java.lang.String(String) constructor wastes memory because the object so constructed will be functionally indistinguishable from the String passed as a parameter. Just use the argument String directly.<br>修改建议：直接使用其参数<br>问题原因：这里调用了String的构造函数来新建一个字符串，浪费内存</p>
<p>This code contains a sequence of calls to a concurrent abstraction (such as a concurrent hash map). These calls will not be executed atomically.<br>修改建议：使用putIfAbsent()保证操作是原子级的<br>问题原因：在多线程访问的情况下，它是不安全的</p>
<p>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous<br>修改建议：在使用变量之前先判断其是否为null<br>问题原因：出现该bug有两种情况，多余的null检查或者没有进行null值检查。</p>
<p>As the JavaDoc states, DateFormats are inherently unsafe for multithreaded use. The detector has found a call to an instance of DateFormat that has been obtained via a static field. This looks suspicious.<br>修改建议：使用ThreadLocal: 每个线程都将拥有自己的SimpleDateFormat对象副本。<br>问题原因：SimpleDateFormat不是线程安全的<br>————————————————</p>
<p>-============================================================================================================</p>
<p>FindBugs Bug Descriptions (推荐)<br><a href="http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_PARAM_DEREF" target="_blank" rel="noopener">http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_PARAM_DEREF</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/findbugs/" rel="tag"># findbugs</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/03/shua-ti-zong-jie/" rel="prev" title="刷题总结">
      <i class="fa fa-chevron-left"></i> 刷题总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/19/dan-ji-yu-fen-bu-shi-ling-pai-xian-liu/" rel="next" title="单机与分布式令牌限流">
      单机与分布式令牌限流 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Damin ZHOU"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Damin ZHOU</p>
  <div class="site-description" itemprop="description">Goals determine <br/> what you are going to be .</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Damin ZHOU</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
