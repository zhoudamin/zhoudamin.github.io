{"meta":{"title":"Notes","subtitle":"Learn Practice Summary","description":"Goals determine <br/> what you are going to be .","author":"Damin ZHOU","url":"http://www.zhoudamin.com","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-01T03:19:47.203Z","comments":true,"path":"about/index.html","permalink":"http://www.zhoudamin.com/about/index.html","excerpt":"","text":"关于我欢迎来到我的博客！ From zhoudamin Email: daminzhou@foxmail.com 中山大学→华为 技能树：1.QRcode 研发 2.Spring-boot后台开发 3.数学建模 4.Java，C#、Python、C 5.目前正在算法里摸爬滚打~ 相册毕业~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"books","date":"2020-05-31T11:49:33.000Z","updated":"2020-05-31T11:56:17.676Z","comments":true,"path":"books/index.html","permalink":"http://www.zhoudamin.com/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-05-01T03:26:01.187Z","comments":true,"path":"categories/index.html","permalink":"http://www.zhoudamin.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-05-01T03:23:49.963Z","comments":true,"path":"friends/index.html","permalink":"http://www.zhoudamin.com/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-05-01T03:19:06.907Z","comments":true,"path":"tags/index.html","permalink":"http://www.zhoudamin.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"guestbook","date":"2017-03-09T04:38:23.000Z","updated":"2017-03-09T07:01:43.189Z","comments":true,"path":"guestbook/index.html","permalink":"http://www.zhoudamin.com/guestbook/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"单机与分布式令牌限流","slug":"单机与分布式令牌限流","date":"2020-07-19T03:39:45.000Z","updated":"2020-07-26T12:56:26.814Z","comments":true,"path":"2020/07/19/dan-ji-yu-fen-bu-shi-ling-pai-xian-liu/","link":"","permalink":"http://www.zhoudamin.com/2020/07/19/dan-ji-yu-fen-bu-shi-ling-pai-xian-liu/","excerpt":"限流是指对某一时间内的请求数进行限制，保持系统的可用性和稳定性。常用的限流算法有令牌桶和漏桶，我们主要讲讲令牌桶的实现。","text":"限流是指对某一时间内的请求数进行限制，保持系统的可用性和稳定性。常用的限流算法有令牌桶和漏桶，我们主要讲讲令牌桶的实现。 单节点限流 RateLimiterGoogle开源项目Guava中的RateLimiter原理就是一个叫令牌桶的流控算法。RateLimiter先定义一个桶（对象），然后按照一定的频率往桶里面扔令牌，请求的线程拿到令牌才可以执行，比如，我们希望北向请求QPS不要超过10000，那么RateLimiter设置为10000的速率后，就会每秒往桶里面扔10000个令牌。而我们如果要引入这个组件，也很简单。只要做三步即可。 pom引入依赖包 com.google.guava guava 29.0-jre 29.0-android 设置桶（对象）的map，key可以对应全接口、单接口、用户级，value对应qps。 创建桶 createpublic static RateLimiter create(double permitsPerSecond) 监控线程从桶里面取令牌public boolean tryAcquire(long timeout,TimeUnit unit) 分布式限流单节点限流我们用对象存储令牌，对于分布式系统来说，采用原生的ratelimiter做到让总体限流和我们的限流值保持一致是困难的。那么我们就需要采用redis做限流。开发思路主要有几点： 令牌存放到Redis，而不是对象里面。 取令牌的时间由上一次消费的预期时间和需要等待的时间改为桶里面放置令牌的时间，我们不让之前的接口去预消费。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"应用开发","slug":"应用开发","permalink":"http://www.zhoudamin.com/tags/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"findbugs clean","slug":"findbugs-clean","date":"2020-05-13T13:57:43.000Z","updated":"2020-05-13T14:12:00.308Z","comments":true,"path":"2020/05/13/findbugs-clean/","link":"","permalink":"http://www.zhoudamin.com/2020/05/13/findbugs-clean/","excerpt":"收集的findbugs清理指导！","text":"收集的findbugs清理指导！ 1、Bug: Hard coded reference to an absolute pathnameBUG描述：This code constructs a File object using a hard coded to an absolute pathname（此代码包含文件对象为一个绝对路径名） 问题原因：硬编码指向绝对路径。 File preFile = new File(PREFERENCES_FILE_FULL_PATH); 而private static final String PREFERENCES_FILE_FULL_PATH = \"/data/data/com.android.mms/shared_prefs/auto_downLoad.xml\";PREFERENCES_FILE_FULL_PATH声明为了final型，不可变的。如果后续文件路径有变更，引用不到了，但路径又不可更改，就会引入问题。 解决方法：去掉final。 2、Bug: Pattern: Dead store to local variable BUG描述：This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. （该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。） 问题原因：锁屏中提示Dead store to velocityX，分析代码 case MotionEvent.ACTION_POINTER_1_UP语句中定义了局部变量velocityX，并且只在if ((mDirectionFlag &amp;&amp; velocityX &gt; 0)||(!mDirectionFlag &amp;&amp; velocityX &lt; 0)) velocityX = -velocityX;中赋值后并未再使用。因此没有赋值的必要，并且分析代码不需要该变量，可以去除。解决方法：去掉velocityX变量的定义及赋值。 3、BUG: Inconsistent synchronizationBUG描述：The fields of this class appear to be accessed inconsistently with respect to synchronization. （不合理的同步） 问题原因：根据描述ConfigLoader文件中mUnlockAppDataMap在46%的时间内都是处于被锁状态。分析代码mUnlockAppDataMap是在checkUnlockAppConfigChange这个函数中被锁的。而该方法public synchronized boolean checkUnlockAppConfigChange(Context context)没有地方调用。 解决方法：去掉synchronized关键字。 4、BUG: Incorrect lazy initialization of static field BUG描述：This method contains an unsynchronized lazy initialization of a non-volatile static field. Because the compiler or processor may reorder instructions, threads are not guaranteed to see a completely initialized object, if the method can be called by multiple threads.（这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。） 问题原因：sInstance 是static型，clean()方法可能被多个线程调用，在sInstance判断为非空后，再清空置null时可能会有问题。 解决方法：给clean()加上关键字synchronized .public static synchronized void clean() 5、BUG: Redundant nullcheck of value known to be non-null BUG描述：This method contains a redundant check of a known non-null value against the constant null.(方法中对不为空的值进行为空的判断。) 问题原因：分析findbugs报错的这段代码 if(mInputStream == null){ Log.i(TAG , “ mInputStream is null “); return; } mDBuilder = mDBuilderFactory.newDocumentBuilder(); if(mInputStream != null) { mDocument = mDBuilder.parse(mInputStream); }else { Log.i(TAG , “mInputStream == null”); return; } mInputStream若为null，则直接返回。后面不需要再有if(mInputStream != null)的判断。 解决方法：在mInputStream判空后不再重复判空，将后面if判断中的mInputStream改为mDBuilder。 6、BUG: Should be a static inner class BUG描述：This class is an inner class, but does not use its embedded reference to the object which created it. This reference makes the instances of the class larger, and may keep the reference to the creator object alive longer than necessary. If possible, the class should be made static.（若成员类中未访问外围类的非静态成员，为避免额外的空间和时间开销，建议改用静态成员类。） 问题原因：非静态成员类和静态成员类的区别在于，非静态成员类是对象的，静态成员类是类的。非静态成员类可以访问外围类的任何成员，但前提是必须存在外围类对象。JAVA需要额外维护非静态成员类和外围类对象的关系。分析代码private class IccText和private class MediaMetadata {没有访问到外围类的非静态成员，所以findbugs建议将其设为static型。 解决方法：将这2个内部类改为static型。 7、BUG: Switch statement found where one case falls through to the next caseBUG描述：This method contains a switch statement where one case branch will fall through to the next case. Usually you need to end this case with a break or return.（Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break或者return语句来跳出。） 问题原因：case MotionEvent.ACTION_UP执行完之后没有break，会继续走case MotionEvent.ACTION_CANCEL分支。分析代码逻辑，手指抬起后，锁屏图标需要回到初始位置，而回到初始位置的逻辑是在ACTION_CANCEL里做的。即ACTION_UP后的逻辑还需要ACTION_CANCEL里面的逻辑。 解决方法：将ACTION_CANCEL中的逻辑拉出来做成一个函数，ACTION_UP逻辑后调用这个函数后再做break操作。 8、BUG: Unread fieldBUG描述：This field is never read. Consider removing it from the class.（类中定义的属性从未被调用，建议删除。） 问题原因：在类中定义了成员变量private HwViewProperty mCondition = null;代码中只有赋值操作mCondition = new HwViewProperty(mContext,value, ViewPropertyType.TYPE_CONDITION, mCallback);但没有使用这个变量mCondition的地方。 解决方法：去掉mCondition的定义及赋值语句。但需注意，mCondition = new HwViewProperty(mContext,value, ViewPropertyType.TYPE_CONDITION, mCallback);赋值中，虽然mCondition变量后续没有使用到，但new HwViewProperty对象调用HwViewProperty的构造方法时，其实是做了功能操作的。因此，去掉mCondition，但需要保留new HwViewProperty(mContext,value, ViewPropertyType.TYPE_CONDITION, mCallback); 9、BUG: Write to static field from instance methodBUG描述：This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.（实例方法直接写静态变量。） 问题原因：sInstance是类的静态成员变量，非静态方法unregisterCallbaks直接对其赋值，非静态方法是与对象相关联的，当多个对象同时对该变量进行赋值时可能出现问题。 解决方法：在使用静态成员变量时使用get和set方法。 May expose internal representation by incorporating reference to mutable object分析主要是针对Date类的get/set方法，涉及了深拷贝和浅拷贝的问题。解决方法：public Date getCreateDate() { return (Date) createDate.clone(); } public void setCreateDate(Date createDate) { this.createDate = (Date) createDate.clone(); } Write to static field from instance method原因：在其他类对static属性进行直接修改解决方法：将static属性设置为private或者protected形式，使用set/get方法进行修改和获取。 Field should be package protectedA mutable static field could be changed by malicious code or by accident. The field could be made package protected to avoid this vulnerability. 一、Security 关于代码安全性防护 DMI_CONSTANT_DB_PASSWORD代码中创建DB的密码时采用了写死的密码。 DMI_EMPTY_DB_PASSWORD创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。 HRS_REQUEST_PARAMETER_TO_COOKIE此代码使用不受信任的HTTP参数构造一个HTTP Cookie。 HRS_REQUEST_PARAMETER_TO_HTTP_HEADER在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。 SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。 XSS_REQUEST_PARAMETER_TO_JSP_WRITER在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。 二、Experimental 关于代码实验性问题LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCEOpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如： public static void initLogging() throws Exception { Logger logger = Logger.getLogger(“edu.umd.cs”); logger.addHandler(new FileHandler()); // call to change logger configuration logger.setUseParentHandlers(false); // another call to change logger configuration } 该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。 public static void main(String[] args) throws Exception { initLogging(); // adds a file handler to the logger System.gc(); // logger configuration lost Logger.getLogger(“edu.umd.cs”).info(“Some message”); // this isn’t logged to the file as expected } OBL_UNSATISFIED_OBLIGATION这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。 一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。 三、Bad practice代码实现中的一些坏习惯AM_CREATES_EMPTY_JAR_FILE_ENTRY调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。 AM_CREATES_EMPTY_ZIP_FILE_ENTRY调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。 BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTSequals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。 DMI_RANDOM_USED_ONLY_ONCE随机创建对象只使用过一次就抛弃 BIT_SIGNED_CHECK检查位操作符运行是否合理 ((event.detail &amp; SWT.SELECTED) &gt; 0) If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use ‘!= 0’ instead of ‘&gt; 0’. CN_IDIOM按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone CN_IDIOM_NO_SUPER_CALL一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。 CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE类中定义了clone方法但是它没有实现Cloneable接口 CO_ABSTRACT_SELF抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例： int compareTo(T o) 比较此对象与指定对象的顺序。 CO_SELF_NO_OBJECT类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型 DE_MIGHT_DROP方法可能抛出异常 DE_MIGHT_IGNORE此方法可能忽略异常。通常，应该以某种方式处理或报告异常，或者将异常抛出方法。 DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION不要用removeAll方法去clear一个集合 DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED类加载器只能建立在特殊的方法体内 DM_EXIT在方法中调用System.exit(…)语句，考虑用RuntimeException来代替 DM_RUN_FINALIZERS_ON_EXIT在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。 ES_COMPARING_PARAMETER_STRING_WITH_EQ用==或者!=方法去比较String类型的参数 ES_COMPARING_STRINGS_WITH_EQ用==或者！=去比较String类型的对象 EQ_ABSTRACT_SELFThis class defines a covariant version of equals(). To correctly override the equals() method in java.lang.Object, the parameter of equals() must have type java.lang.Object. 这个类定义了equals()方法，但是参数却是Object的子类。正确覆盖equals()方法，参数必须是Object EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THISequals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。 public boolean equals(Object o) { if (o instanceof Foo) return name.equals(((Foo)o).name); else if (o instanceof String) return name.equals(o); else return false; EQ_COMPARETO_USE_OBJECT_EQUALS类中定义了compareTo方法但是继承了Object中的compareTo方法 22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT) 类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换 EQ_SELF_NO_OBJECT类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。 FI_EMPTY为空的finalizer方法应该删除。一下关于finalizer的内容省略 GC_UNCHECKED_TYPE_IN_GENERIC_CALLThis call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type. 此对泛型集合方法的调用在编译类型对象时传递一个参数，其中预期泛型类型参数中的特定类型。因此，标准Java类型系统和静态分析都不能提供关于作为参数传递的对象是否属于适当类型的有用信息。 HE_EQUALS_NO_HASHCODE方法定义了equals方法却没有定义hashCode方法 HE_HASHCODE_NO_EQUALS 类定义了hashCode方法去没有定义equal方法 HE_EQUALS_USE_HASHCODE一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法 HE_INHERITS_EQUALS_USE_HASHCODE子类继承了父类的equals方法却使用了Object的hashCode方法 IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION子类在父类未初始化之前使用父类对象实例 public class CircularClassInitialization { static class InnerClassSingleton extends CircularClassInitialization { static InnerClassSingleton singleton = new InnerClassSingleton(); } static CircularClassInitialization foo = InnerClassSingleton.singleton; } IMSE_DONT_CATCH_IMSE捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法 ISC_INSTANTIATE_STATIC_CLASS为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。 IT_NO_SUCH_ELEMENT迭代器的next方法不能够抛出NoSuchElementException J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION在HttpSession对象中保存非连续的对象 JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. . 该类使用net.jcip.annotations进行注释。不可变的，该注释的规则要求所有字段都是final NP_BOOLEAN_RETURN_NULL返回值为boolean类型的方法直接返回null，这样会导致空指针异常 NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT变量调用equals方法时没有进行是否为null的判断 NP_TOSTRING_COULD_RETURN_NULLtoString方法可能返回null NM_CLASS_NAMING_CONVENTION类的名称以大写字母名称开头 NM_CLASS_NOT_EXCEPTION类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆 NM_CONFUSING令人迷惑的方面命名 NM_FIELD_NAMING_CONVENTION非final类型的字段需要遵循驼峰命名原则 NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER验证是否是java预留关键字 NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER验证是否时java中的关键字 NM_METHOD_NAMING_CONVENTION方法名称以小写字母开头 NM_SAME_SIMPLE_NAME_AS_INTERFACE实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中 NM_SAME_SIMPLE_NAME_AS_SUPERCLASS继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中 NM_VERY_CONFUSING_INTENTIONAL很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。 NM_WRONG_PACKAGE_INTENTIONAL由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法 import alpha.Foo; public class A { public int f(Foo x) { return 17; } } import beta.Foo; public class B extends A { public int f(Foo x) { return 42; } public int f(alpha.Foo x) { return 27; } } ODR_OPEN_DATABASE_RESOURCE方法中可能存在关闭数据连接失败的情况 OS_OPEN_STREAM方法中可能存在关闭流失败的情况 OS_OPEN_STREAM_EXCEPTION_PATH方法中可能存在关闭流时出现异常情况 RC_REF_COMPARISON_BAD_PRACTICE当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。 RR_NOT_CHECKEDInputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。 SR_NOT_CHECKEDInputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况 RV_RETURN_VALUE_IGNORED_BAD_PRACTICE方法忽略返回值的异常信息 SI_INSTANCE_BEFORE_FINALS_ASSIGNED在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。 SE_BAD_FIELD_STORE非序列化的值保存在声明为序列化的的非序列化字段中 SE_COMPARATOR_SHOULD_BE_SERIALIZABLEComparator接口没有实现Serializable接口 SE_INNER_CLASS序列化内部类 SE_NONFINAL_SERIALVERSIONID关于UID类的检查内容省略 SE_NO_SUITABLE_CONSTRUCTOR子类序列化时父类没有提供一个void的构造函数 SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATIONExternalizable 实例类没有定义一个void类型的构造函数 SE_READ_RESOLVE_MUST_RETURN_OBJECTreadResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象 SE_TRANSIENT_FIELD_NOT_RESTOREDThis class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class. 该类包含一个在类中的多个位置更新的字段，因此它似乎是类状态的一部分。但是，由于字段被标记为transient，并且没有在readObject或readResolve中设置，所以它将在类的任何反序列化实例中包含默认值。 SE_NO_SERIALVERSIONID一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID： ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L; UI_INHERITANCE_UNSAFE_GETRESOURCE当一个类被子类继承后不要使用this.getClass().getResource(…)来获取资源 四、Correctness关于代码正确性相关方面的BC_IMPOSSIBLE_CAST不可能的类转换，执行时会抛出ClassCastException BC_IMPOSSIBLE_DOWNCAST父类在向下进行类型转换时抛出ClassCastException BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY集合转换为数组元素时发生的类转换错误。 This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in: String[] getAsArray(Collection c) { return (String[]) c.toArray(); } This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can’t really do anything else, since the Collection object has no reference to the declared generic type of the collection. The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient). BC_IMPOSSIBLE_INSTANCEOF采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。 BIT_AND错误的使用&amp;位操作符，例如(e &amp; C) BIT_AND_ZZ检查恒等的逻辑错误 BIT_IOR错误的使用|位操作符，例如(e | C) BIT_SIGNED_CHECK_HIGH_BIT检查逻辑运算符操作返回的标识。例如((event.detail &amp; SWT.SELECTED) &gt; 0)，建议采用!=0代替&gt;0 BOA_BADLY_OVERRIDDEN_ADAPTER子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用 BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2 DLS_DEAD_STORE_OF_CLASS_LITERAL以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。 DLS_OVERWRITTEN_INCREMENT覆写增量增加错误i = i++ DMI_BAD_MONTHhashNext方法调用next方法。 DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES集合没有包含他们自己本身。 DMI_INVOKING_HASHCODE_ON_ARRAY数组直接使用hashCode方法来返回哈希码。 int [] a1 = new int[]{1,2,3,4}; System.out.println(a1.hashCode()); System.out.println(java.util.Arrays.hashCode(a1)); DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INTDouble.longBitsToDouble invoked on an int在int上调用了Double.longBitsToDouble DMI_VACUOUS_SELF_COLLECTION_CALL集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。 DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTIONUnless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can’t be observed using reflection (e.g., by using the isAnnotationPresent method). . 除非注释本身使用@Retention(RetentionPolicy.RUNTIME)进行了注释，否则不能使用反射(例如，使用isAnnotationPresent方法)观察注释。 DMI_VACUOUS_CALL_TO_EASYMOCK_METHODWhile ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect. 虽然ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，但是一些继承的调优方法对它并不有用。特别是，由于它使用corePoolSize线程和无界队列充当固定大小的池，所以对maximumPoolSize的调整没有任何有用的效果。 EC_ARRAY_AND_NONARRAY数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]); EC_INCOMPATIBLE_ARRAY_COMPARE使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[] EC_NULL_ARG调用equals的对象为null EC_UNRELATED_CLASS_AND_INTERFACE使用equals方法比较不相关的类和接口 EC_UNRELATED_INTERFACES调用equals方法比较不同类型的接口 EC_UNRELATED_TYPES调用equals方法比较不同类型的类 EC_UNRELATED_TYPES_USING_POINTER_EQUALITYThis method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime. 该方法使用指针相等来比较两个似乎属于不同类型的引用。这个比较的结果在运行时总是错误的。 EQ_ALWAYS_FALSE使用equals方法返回值总是false EQ_ALWAYS_TRUEequals方法返回值总是true EQ_COMPARING_CLASS_NAMES使用equals方法去比较一个类的实例和类的类型 EQ_DONT_DEFINE_EQUALS_FOR_ENUMThis class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don’t do it. 该类定义枚举，并且使用对象标识定义枚举上的等式。为枚举值定义一个协变等于方法是一个非常糟糕的实践，因为它可能会导致使用协变枚举方法将两个不同的枚举值作为等于进行比较，而在正常情况下比较时作为不相等。不要这样做。 EQ_OTHER_NO_OBJECT类中定义的equals方法时不要覆写equals（Object）方法 EQ_OTHER_USE_OBJECT类中定义的equals方法时不要覆写Object中的equals（Object）方法 EQ_OVERRIDING_EQUALS_NOT_SYMMETRICname=错误用法 - equals方法覆盖了父类的equals可能功能不符 EQ_SELF_USE_OBJECT类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法 FE_TEST_IF_EQUAL_TO_NOT_A_NUMBERThis code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision). name=错误用法 - 测试是否与NaN相等 VA_FORMAT_STRING_BAD_ARGUMENT错误使用参数类型来格式化字符串 VA_FORMAT_STRING_BAD_CONVERSION指定的格式字符串和参数类型不匹配，例如：String.format(“%d”, “1”) VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。 VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED使用String的format方法时有非法的参数也经过了格式化操作。 VA_FORMAT_STRING_ILLEGAL格式化String对象语句错误 VA_FORMAT_STRING_MISSING_ARGUMENTString的format操作缺少必要的参数。 VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT格式字符串定义错误，例如：formatter.format(“%&lt;s %s”, “a”, “b”); 抛出MissingFormatArgumentException异常 GC_UNRELATED_TYPESThis call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method. In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String. In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks. 这个对泛型集合方法的调用包含一个与集合的参数(即，参数的类型既不是相应泛型类型参数的超类型，也不是相应泛型类型参数的子类型)。因此，集合不太可能包含与这里使用的方法参数相同的任何对象。很可能，传递给方法的值是错误的。 HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASSA method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn’t fulfill the requirement that equal objects have equal hashCodes. 方法、字段或类声明一个泛型签名，其中在需要可耐洗类的上下文中使用不可耐洗类。声明equals方法但从对象继承hashCode()方法的类是不可挂起的，因为它不满足equal对象具有相等hashCode的要求。 HE_USE_OF_UNHASHABLE_CLASSA class defines an equals(Object) method but not a hashCode() method, and thus doesn’t fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance. 类定义了equals(Object)方法，但没有定义hashCode()方法，因此不能满足equal对象具有相等hashCode的要求。该类的一个实例用于哈希数据结构中，这使得修复这个问题变得极为重要。 ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEILintegral的值转换为double后使用了Math.ceil方法 ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUNDint 类型的值转换为float类型之后调用了Math.round方法 IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD在JUnit中的断言在run方法中不会被告知 IJU_BAD_SUITE_METHOD在一个JUnit类中声明的一个suite()方法必须声明为 public static junit.framework.Test suite() 或者 public static junit.framework.TestSuite suite()的形式。 IL_CONTAINER_ADDED_TO_ITSELF集合本身作为add方法的参数，这样会引起内容溢出。 IL_INFINITE_LOOP方法的自调用引起的死循环 IM_MULTIPLYING_RESULT_OF_IREM和整数余数进行乘法运算。例如：i % 60 * 1000 是进行(i % 60) * 1000运算而不是 i % (60 * 1000) INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE保证非负数和负数进行比较 INT_BAD_COMPARISON_WITH_SIGNED_BYTE比较有符合数，要先把有符号数转换为无符合数再进行比较 IO_APPENDING_TO_OBJECT_OUTPUT_STREAM宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。 IP_PARAMETER_IS_DEAD_BUT_OVERWRITTENThe initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller. 传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者 MF_CLASS_MASKS_FIELD子类中定义了和父类中同名的字段。在调用时会出错 MF_METHOD_MASKS_FIELD在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。 NP_ALWAYS_NULL对象赋为null值后 没有被重新赋值 NP_ALWAYS_NULL_EXCEPTIONA pointer which is null on an exception path is dereferenced here. This will lead to a NullPointerException when the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning. Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible. 空指针引用上调用去除引用方法，将发生空指针异常 NP_ARGUMENT_MIGHT_BE_NULL方法没有判断参数是否为空 NP_CLOSING_NULL一个为空的对象调用close方法 NP_GUARANTEED_DEREFThere is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions). 在正常的null判断分支上，对象去除引用操作是受保护的不允许的 NP_GUARANTEED_DEREF_ON_EXCEPTION_PATHThere is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions). 异常路径上有一个语句或分支，如果执行该语句或分支，则该语句或分支将确保此时值为空，并且该值将被取消引用(涉及运行时异常的正向路径除外)。 NP_NONNULL_PARAM_VIOLATION方法中为null的参数没有被重新赋值 void test(){ String ss = null; sya(ss); } public void sya(String ad){ ad.getBytes(); } NP_NONNULL_RETURN_VIOLATION方法声明了返回值不能为空，但是方法中有可能返回null NP_NULL_INSTANCEOF检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的 NP_NULL_ON_SOME_PATH对象可能没有重新赋值 NP_NULL_ON_SOME_PATH_EXCEPTIONA reference value which is null on some exception control path is dereferenced here. This may lead to a NullPointerException when the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning. Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible. 在异常null值处理分支调用的方法上，可能存在对象去除引用操作 NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS方法参数中声明为nonnull类型的参数为null void test(){ String ss = null; sya(ss); } public void sya(@nonnull String ad){ ad.getBytes(); } NP_STORE_INTO_NONNULL_FIELD为一个已经声明为不能为null值的属性赋值为null。 NM_BAD_EQUAL类中定义了一个equal方法但是却不是覆写的Object对象的equals方法 NM_LCASE_HASHCODE类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法 NM_LCASE_TOSTRING类中定义了一个toString方法但是却不是覆写的Object中的toString方法 NM_METHOD_CONSTRUCTOR_CONFUSION构造方法定义混乱，保证一个标准的构造函数。 例如： SA(){ } void SA(){ } NM_VERY_CONFUSING混乱的方法命名，如getName和getname方法同时出现的时候 NM_WRONG_PACKAGE方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法 import alpha.Foo; public class A { public int f(Foo x) { return 17; } } import beta.Foo; public class B extends A { public int f(Foo x) { return 42; } } QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作 RC_REF_COMPARISON比较两个对象值是否相等时应该采用equals方法，而不是==方法 RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。 RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\\’而应该使用’\\‘ RV_01_TO_INT从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。 RV_ABSOLUTE_VALUE_OF_HASHCODE此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。 在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。 RV_ABSOLUTE_VALUE_OF_RANDOM_INT此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。 RV_EXCEPTION_NOT_THROWN此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x &lt; 0) new IllegalArgumentException(“x must be nonnegative”); 这可能是程序员的意图抛出创建的异常： if (x &lt; 0) throw new IllegalArgumentException(“x must be nonnegative”); 86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name); dateString.trim(); 程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正： String dateString = getHeaderField(name); dateString = dateString.trim(); RpC_REPEATED_CONDITIONAL_TEST该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。 SA_FIELD_DOUBLE_ASSIGNMENT方法中的字段包含了双重任务，例如： int x; public void foo() { x = x = 17; } 这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。 SA_FIELD_SELF_ASSIGNMENT方法中包含自己对自己赋值的字段。例如： int x; public void foo() { x = x; } SA_FIELD_SELF_COMPARISON字段自己进行自比较可能表明错误或逻辑错误。 SA_LOCAL_SELF_COMPARISON方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。 SA_LOCAL_SELF_COMPUTATION此方法对同一变量执行了荒谬的计算（如x&amp;x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。 SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。 SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW在swtich中因为出现异常而忽略了对case值的保存。 SIC_THREADLOCAL_DEADLY_EMBRACE如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。 SIO_SUPERFLUOUS_INSTANCEOF在进行instanceof操作时进行没有必要的类型检查 STI_INTERRUPTED_ON_CURRENTTHREAD此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。 STI_INTERRUPTED_ON_UNKNOWNTHREAD调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。 SE_METHOD_MUST_BE_PRIVATE这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。 SE_READ_RESOLVE_IS_STATIC为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。 UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。 UR_UNINIT_READ此构造方法中使用了一个尚未赋值的字段或属性。 String a; public SA() { String abc = a; System.out.println(abc); } UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如： abstract class A { int hashCode; abstract Object getValue(); A() { hashCode = getValue().hashCode(); } } class B extends A { Object value; B(Object v) { this.value = v; } Object getValue() { return value; } } 当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。 DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如： String[] a = { “a” }; System.out.println(a.toString()); //正确的使用为 System.out.println(Arrays.toString(a)); DMI_INVOKING_TOSTRING_ON_ARRAY该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组 UWF_NULL_FIELD字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。 107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD)此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。 五：Performance关于代码性能相关方面的BX_UNBOXING_IMMEDIATELY_REBOXED 装箱的值被取消装箱，然后立即重新装箱 BX_BOXING_IMMEDIATELY_UNBOXED 对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作 BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION 对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如： new Double(d).intValue()应该直接进行强制转换例如：(int) d DM_BOXED_PRIMITIVE_TOSTRING 仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如： new Integer(1).toString() 替换为 Integer.toString(1) new Long(1).toString() 替换为 Long.toString(1) new Float(1.0).toString() 替换为 Float.toString(1.0) new Double(1.0).toString() 替换为 Double.toString(1.0) new Byte(1).toString() 替换为 Byte.toString(1) new Short(1).toString() 替换为 Short.toString(1) new Boolean(true).toString() 替换为 Boolean.toString(true) DM_FP_NUMBER_CTOR 使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能 除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。 DM_NUMBER_CTOR 使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能 除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。 DMI_BLOCKING_METHODS_ON_URL 使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。 DMI_COLLECTION_OF_URLS 方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。 DM_BOOLEAN_CTOR 使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。 DM_GC 在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。 DM_NEXTINT_VIA_NEXTDOUBLE 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n) DM_STRING_CTOR 使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式 DM_STRING_TOSTRING 调用String.toString()是多余的操作，只要使用String就可以了。 DM_STRING_VOID_CTOR 使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。 ITA_INEFFICIENT_TO_ARRAY 当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是 myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。 LO_APPENDED_STRING_IN_FORMAT_STRING 此方法使用SLF4J记录器记录一个字符串，其中第一个（格式）字符串是使用串联创建的。您应该使用{}标记将动态内容注入到字符串中，以便延迟String的构建，直到需要实际的日志字符串为止。如果日志级别足够高，以致不使用此日志语句，则将永远不会执行附加操作。 NAB_NEEDLESS_BOXING_VALUEOF 此方法将String传递给包装的原始对象的parse方法，该方法又调用valueOf（）方法以转换为装箱的原始对象。当需要从String转换为装箱的原始对象时，使用BoxedPrimitive.valueOf（String）方法更简单。 而不是这样的： Boolean bo = Boolean.valueOf(Boolean.parseBoolean(“true”)); Float f = Float.valueOf(Float.parseFloat(“1.234”)); 只需做： Boolean bo = Boolean.valueOf(“true”); Float f = Float.valueOf(“1.234”); NAB_NEEDLESS_BOXING_PARSE 该方法将String传递给包装的原始对象的valueOf方法，该方法进而调用boxedValue（）方法以转换为原始对象。当需要从String转换为原始值时，使用BoxedPrimitive.parseBoxedPrimitive（String）方法更简单。 而不是这样的： public int someMethod(String data) { long l = Long.valueOf(data).longValue(); float f = Float.valueOf(data).floatValue(); return Integer.valueOf(data); // There is an implicit .intValue() call } 只需做： public int someMethod(String data) { long l = Long.parseLong(data); float f = Float.parseFloat(data); return Integer.parseInt(data); } NAB_NEEDLESS_BOOLEAN_CONSTANT_CONVERSION 此方法将一个装箱的布尔常量分配给一个原始布尔变量，或将一个装箱的布尔常量分配给一个装箱的布尔变量。对需要的变量使用正确的常数 PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS 此方法在相同实例上使用相同的常量参数连续两次调用相同的方法，而无需对对象进行任何中间更改。如果此方法未对对象进行更改（看上去没有更改），则进行两次调用将很浪费。通过将结果分配给一个临时变量，然后第二次使用该变量，可以合并这些方法调用。 PSC_PRESIZE_COLLECTIONS 这个方法使用默认构造函数分配集合，即使它预先知道集合中将放置多少项(或者至少可以合理地猜测)，从而不必要地导致集合的中间重新分配。 您可以使用具有初始大小的构造函数，这样会好得多，但是由于映射和集合的加载因子，甚至这也不是一个正确的估计值。 如果您正在使用Guava，请使用它的方法来分配具有预先确定大小的映射和集合，以获得不重新分配的最佳机会，例如: Sets.newHashSetWithExpectedSize (int) Maps.newHashMapWithExpectedSize (int) 如果没有，一个很好的估计值应该是expectedSize / {LOADING_FACTOR}默认值为0.75 SBSC_USE_STRINGBUFFER_CONCATENATION 在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象 例如： // This is bad String s = “”; for (int i = 0; i &lt; field.length; ++i) { s = s + field[i]; } // This is better StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; field.length; ++i) { buf.append(field[i]); } String s = buf.toString(); SEO_SUBOPTIMAL_EXPRESSION_ORDER 例如，此方法在if或while语句中构建条件表达式，该表达式既包含简单的局部变量比较，又包含方法调用的比较。表达式对这些命令进行排序，以便在简单的局部变量比较之前进行方法调用。这导致方法调用在不需要的条件下执行，因此有可能导致大量代码无执行。通过对表达式进行排序，以便首先包含局部变量条件的简单条件，可以消除这种浪费。假定方法调用没有副作用。如果该方法确实有副作用，则最好将这些调用从条件中拉出并先执行，然后将值分配给局部变量。 例： if ((calculateHaltingProbability() &gt; 0) &amp;&amp; shouldCalcHalting) { } Better： if (shouldCalcHalting &amp;&amp; (calculateHaltingProbability() &gt; 0) { } SS_SHOULD_BE_STATIC 类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。 SPP_STRINGBUFFER_WITH_EMPTY_STRING 这个方法调用StringBuffer或StringBuilder构造函数，传入一个常量空字符串(“”)。这与调用默认构造函数相同，但是会使代码更加困难。考虑传入一个默认大小。 UCPM_USE_CHARACTER_PARAMETERIZED_METHOD 此方法将String长度为1 的常量文字作为参数传递给方法，该方法公开了一个类似的方法，该方法采用char。处理一个字符而不是一个字符串更简单方便。 而不是像这样： String myString = … if (myString.indexOf(“e”) != -1) { int i = myString.lastIndexOf(\"e\"); System.out.println(myString + \":\" + i); //the Java compiler will use a StringBuilder internally here [builder.append(\":\")] ... return myString.replace(\"m\",\"z\");} 将单字母Strings 替换为它们的char等价物，如下所示： String myString = … if (myString.indexOf(‘e’) != -1) { int i = myString.lastIndexOf('e'); System.out.println(myString + ':' + i); //the Java compiler will use a StringBuilder internally here [builder.append(':')] ... return myString.replace('m','z');} UM_UNNECESSARY_MATH 在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。 Method Parameter abs -any- acos 0.0 or 1.0 asin 0.0 or 1.0 atan 0.0 or 1.0 atan2 0.0 cbrt 0.0 or 1.0 ceil -any- cos 0.0 cosh 0.0 exp 0.0 or 1.0 expm1 0.0 floor -any- log 0.0 or 1.0 log10 0.0 or 1.0 rint -any- round -any- sin 0.0 sinh 0.0 sqrt 0.0 or 1.0 tan 0.0 tanh 0.0 toDegrees 0.0 or 1.0 toRadians 0.0 UPM_UNCALLED_PRIVATE_METHOD 定义为Private类型方法从未被调用，应该被删除。 URF_UNREAD_FIELD 类中定义的属性从未被调用，建议删除。 UUF_UNUSED_FIELD 类中定义的属性从未被使用，建议删除。 WMI_WRONG_MAP_ITERATOR 当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。 六：Internationalization关于代码国际化相关方面的DM_CONVERT_CASE 使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换 String.toUpperCase( Locale l ) String.toLowerCase( Locale l ) 七：Multithreaded correctness关于代码多线程正确性相关方面的DL_SYNCHRONIZATION_ON_BOOLEAN 该代码同步一个封装的原始常量，例如一个Boolean类型。 private static Boolean inited = Boolean.FALSE; … synchronized(inited) { if (!inited) { init(); inited = Boolean.TRUE; } }… 由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁 DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE 该代码同步一个封装的原始常量，例如一个Integer类型。 private static Integer count = 0; … synchronized(count) { count++; }… 由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁 DL_SYNCHRONIZATION_ON_SHARED_CONSTANT 同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。 DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE 同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如： private static final Integer fileLock = new Integer(1); … synchronized(fileLock) { .. do something .. }… 它最后被定义为以下方式来代替：private static final Object fileLock = new Object(); DM_MONITOR_WAIT_ON_CONDITION 方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。 DM_USELESS_THREAD 这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。 ESync_EMPTY_SYNC 该代码包含一个空的同步块：synchronized() {} IS2_INCONSISTENT_SYNC 不合理的同步 IS_FIELD_NOT_GUARDED 域不是良好的同步访问— 此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问 JLM_JSR166_LOCK_MONITORENTER 实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。 LI_LAZY_INIT_STATIC 静态域不正确的延迟初始化– 这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题 LI_LAZY_INIT_UPDATE_STATIC 这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。 即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。 ML_SYNC_ON_UPDATED_FIELD 对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。 MSF_MUTABLE_SERVLET_FIELD 一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。 MWN_MISMATCHED_NOTIFY 此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。 MWN_MISMATCHED_WAIT 此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。 NP_SYNC_AND_NULL_CHECK_FIELD 如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。 NO_NOTIFY_NOT_NOTIFYALL 调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。 RS_READOBJECT_SYNC 序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。 RU_INVOKE_RUN 这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。 SC_START_IN_CTOR 在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。 SP_SPIN_ON_FIELD 方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求） STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE 即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。 Calendar rightNow = Calendar.getInstance(); STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE 在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。 myString = DateFormat.getDateInstance().format(myDate); STCAL_STATIC_CALENDAR_INSTANCE Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。 STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。 SWL_SLEEP_WITH_LOCK_HELD 当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。 UG_SYNC_SET_UNSYNC_GET 这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。 UL_UNRELEASED_LOCK 方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下： Lock l = …; l.lock(); try { // do something } finally { l.unlock();} UL_UNRELEASED_LOCK_EXCEPTION_PATH 方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下： Lock l = …; l.lock(); try { // do something } finally { l.unlock();} UW_UNCOND_WAIT) 方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。 VO_VOLATILE_REFERENCE_TO_ARRAY 声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性 WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL 实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码： private static final String base = \"label\"; private static int nameCounter = 0; String constructComponentName() { synchronized (getClass()) { return base + nameCounter++; } }Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为： private static final String base = \"label\"; private static int nameCounter = 0; String constructComponentName() { synchronized (Label.class) { return base + nameCounter++; } }WS_WRITEOBJECT_SYNC 这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。 WA_AWAIT_NOT_IN_LOOP 方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。 WA_NOT_IN_LOOP 这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。 八：Malicious codevulnerability关于恶意破坏代码相关方面的EI_EXPOSE_REP 返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。 EI_EXPOSE_REP2 此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。 FI_PUBLIC_SHOULD_BE_PROTECTED 一个类中的finalize（）方法必须声明为protected，而不能为public类型 MS_EXPOSE_REP 一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。 MS_FINAL_PKGPROTECT 一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。 MS_MUTABLE_ARRAY 一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。 MS_MUTABLE_HASHTABLE 一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。 MS_OOI_PKGPROTECT 将域尽量不要定义在接口中，并声明为包保护 在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。 MS_PKGPROTECT 一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。 九：Dodgy、style糟糕的代码 BC_BAD_CAST_TO_ABSTRACT_COLLECTION 在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。 BC_BAD_CAST_TO_CONCRETE_COLLECTION 代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。 BC_UNCONFIRMED_CAST 强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。 BC_VACUOUS_INSTANCEOF instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。 CC_CYCLOMATIC_COMPLEXITY 该方法具有较高的圈复杂度，可以计算出分支点的个数。它很可能难以测试，并且很容易更改。考虑将此方法重构为多个方法以降低风险。 CFS_CONFUSING_FUNCTION_SEMANTICS 此方法将修改参数，然后将此参数作为方法的返回值返回。这将使这个方法的调用者感到困惑，因为传入参数的“原始”显然也不会更改。如果此方法的目的是更改参数，则将该方法更改为具有空返回值的a会更清楚。如果由于接口或超类契约需要返回类型，则可能应该复制该参数。 CI_CONFUSED_INHERITANCE 这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。 DB_DUPLICATE_BRANCHES 此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。 DB_DUPLICATE_SWITCH_CLAUSES 他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。 DLS_DEAD_LOCAL_STORE 该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。 DLS_DEAD_LOCAL_STORE_IN_RETURN 本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。 DLS_DEAD_LOCAL_STORE_OF_NULL 把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。 DMI_HARDCODED_ABSOLUTE_FILENAME 此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）; DMI_NONSERIALIZABLE_OBJECT_WRITTEN 代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。 DMI_USELESS_SUBSTRING 此代码调用了subString(0)方法，它将返回原来的值。 EXS_EXCEPTION_SOFTENING_HAS_CHECKED 此方法的异常签名受超类接口的约束，不抛出已捕获的已检查异常。因此，此异常被转换为未检查异常并引发。最好抛出最近的已检查异常，并使用初始原因字段用原始异常注释新异常。 EQ_DOESNT_OVERRIDE_EQUALS 该类扩展了定义equals方法的类并添加字段，但本身不定义equals方法。因此，该类实例上的等式将忽略子类的标识和添加的字段。确保这是您想要的，并且您不需要覆盖equals方法。即使不需要重写equals方法，也可以考虑重写它，以记录这样一个事实:子类的equals方法只返回调用super.equals(o)的结果。 FE_FLOATING_POINT_EQUALITY 此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较 VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN 使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false IC_INIT_CIRCULARITY 在引用两个相互调用为环状static方法去初始化一个实例时是错误的。 ICAST_IDIV_CAST_TO_DOUBLE 整形数除法强制转换为double或者float类型。 int x = 2; int y = 5; // Wrong: yields result 0.0 double value1 = x / y; // Right: yields result 0.4 double value2 = x / (double) y; ICAST_INTEGER_MULTIPLY_CAST_TO_LONG 整形数做乘法运算结果转换为long值时如果采用 long convertDaysToMilliseconds(int days) { return 1000360024*days; } 结果会因为超出整形的范围而出错。 如果使用： long convertDaysToMilliseconds(int days) { return 1000L360024*days; } 或者： static final long MILLISECONDS_PER_DAY = 24L36001000; long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; } 都可以避免此问题。 ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT 无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小） IM_AVERAGE_COMPUTATION_COULD_OVERFLOW 代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x &amp; 1 == 1, or x % 2 != 0来代替 IMC_IMMATURE_CLASS_PRINTSTACKTRACE 此方法将堆栈跟踪打印到控制台。这是不可配置的，并导致应用程序看起来不专业。切换到使用日志记录器，以便用户能够控制日志记录的内容和位置。 INT_VACUOUS_COMPARISON 整形数进行比较结果总是不变。例如：x &lt;= Integer.MAX_VALUE MOM_MISLEADING_OVERLOAD_MODEL 该类用实例和静态版本“重载”相同的方法。由于这两种模型的使用是不同的，这将使这些方法的用户感到困惑。 MTIA_SUSPECT_SERVLET_INSTANCE_FIELD 这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。 MTIA_SUSPECT_STRUTS_INSTANCE_FIELD 类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。 NP_DEREFERENCE_OF_READLINE_VALUE 对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。 NP_IMMEDIATE_DEREFERENCE_OF_READLINE 对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。 NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE 方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。 NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE 参数值在任何情况下都不能为空，但是有明确的注释它可以为空。 NS_DANGEROUS_NON_SHORT_CIRCUIT 代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，这会造成潜在的危险。 NS_NON_SHORT_CIRCUIT 代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，会引起不安全的操作 PZLA_PREFER_ZERO_LENGTH_ARRAYS 考虑返回一个零长度的数组，而不是null值 QF_QUESTIONABLE_FOR_LOOP 确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。 RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE 方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。 RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES 方法中对两个null值进行比较 RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE 方法中对不为空的值进行为空的判断。 REC_CATCH_EXCEPTION 在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获 RI_REDUNDANT_INTERFACES 子类和父类都实现了同一个接口，这种定义是多余的。 RV_DONT_JUST_NULL_CHECK_READLINE readLine方法的结果不为空时被抛弃 RV_REM_OF_RANDOM_INT 此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。 RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT 这段代码调用一个方法并忽略返回值。然而，我们的分析表明，该方法(如果有的话，包括它在子类中的实现)除了返回值之外不会产生任何效果。因此可以删除这个调用。 可能是错误警告：-该方法旨在被覆盖，并在其他超出分析范围的项目中产生副作用。 -调用该方法来触发类加载，这可能会产生副作用。 -调用该方法只是为了获得一些异常。 可以使用@CheckReturnValue注释来指示FindBugs忽略该方法的返回值 SA_LOCAL_DOUBLE_ASSIGNMENT 为一个局部变量两次赋值，这样是没有意义的。例如： public void foo() { int x,y; x = x = 17; } SA_LOCAL_SELF_ASSIGNMENT 局部变量使用自身给自己赋值 public void foo() { int x = 3; x = x; } SF_SWITCH_FALLTHROUGH Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。 SF_SWITCH_NO_DEFAULT Switch没有默认情况下执行的case语句。 SE_PRIVATE_READ_RESOLVE_NOT_INHERITED 声明为private的序列化方法被子类继承 UCF_USELESS_CONTROL_FLOW 没有任何作用的条件语句。 if (argv.length == 0) { // TODO: handle this case } UCF_USELESS_CONTROL_FLOW_NEXT_LINE 无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。 if (argv.length == 1); System.out.println(\"Hello, \" + argv[0]);UP_UNUSED_PARAMETER 此方法定义了从未使用过的参数。由于此方法是静态的或私有的，且不能派生，因此删除这些参数并简化方法是安全的。虽然不太可能，但您应该考虑可以反射性地使用此方法，因此您也希望更改该调用。在这种情况下，很可能一旦删除了参数，就会有一系列方法调用花费时间创建该参数并将其传递下去。所有这些都可能被移除。 UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR 字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。 USBR_UNNECESSARY_STORE_BEFORE_RETURN该方法将返回结果存储在局部变量中，然后立即返回局部变量。直接返回分配给局部变量的值会更简单。 Instead of the following: public float average(int[] arr) { float sum = 0; for (int i = 0; i &lt; arr.length; i++) { sum += arr[i]; } float ave = sum / arr.length; return ave;} Simply change the method to return the result of the division: public float average(int[] arr) { float sum = 0; for (int i = 0; i &lt; arr.length; i++) { sum += arr[i]; } return sum / arr.length; //Change} XFB_XML_FACTORY_BYPASS 方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如： javax.xml.parsers.DocumentBuilderFactory javax.xml.parsers.SAXParserFactory javax.xml.transform.TransformerFactory org.w3c.dom.Document.createXXXX XSS_REQUEST_PARAMETER_TO_SEND_ERROR 在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。 XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER 代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。 OBL_UNSATISFIED_OBLIGATION 方法可能在清理流或资源时失败。 处理方式：使用try/finally块，在finally块中关闭流。 OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE 原因及处理方式：原因是in关闭异常之后，out可能就关闭失败。处理方式先关闭输出流，再关闭输入流。 OS OS_OPEN_STREAM 方法可能在关闭流时失败 处理方式：使用try/finally块，在finally块中关闭流。 RV RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT 有返回值，但是未使用。 处理方式：接收返回值，并且打印出来。logger.info()； FindBugs是基于Bug Patterns概念，查找javabytecode（.class文件）中的潜在bug，主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等 一、Security 关于代码安全性防护1.Dm: Hardcoded constant database password (DMI_CONSTANT_DB_PASSWORD)代码中创建DB的密码时采用了写死的密码。2.Dm: Empty database password (DMI_EMPTY_DB_PASSWORD)创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。3.HRS: HTTP cookie formed from untrusted input (HRS_REQUEST_PARAMETER_TO_COOKIE)此代码使用不受信任的HTTP参数构造一个HTTP Cookie。4.HRS: HTTP Response splitting vulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。5.SQL: Nonconstant string passed to execute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。6.XSS: JSP reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。二、Experimental1.LG: Potential lost logger changes due to weak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：public static void initLogging() throws Exception { Logger logger = Logger.getLogger(“edu.umd.cs”); logger.addHandler(new FileHandler()); // call to change logger configuration logger.setUseParentHandlers(false); // another call to change logger configuration}该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。public static void main(String[] args) throws Exception { initLogging(); // adds a file handler to the logger System.gc(); // logger configuration lost Logger.getLogger(“edu.umd.cs”).info(“Some message”); // this isn’t logged to the file as expected}2.OBL: Method may fail to clean up stream or resource (OBL_UNSATISFIED_OBLIGATION)这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。 三、Bad practice代码实现中的一些坏习惯1.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。2.AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。3.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。4.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)随机创建对象只使用过一次就抛弃5.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK)检查位操作符运行是否合理((event.detail &amp; SWT.SELECTED) &gt; 0)If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use ‘!= 0’ instead of ‘&gt; 0’.6.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone7.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。8.CN: Class defines clone() but doesn’t implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)类中定义了clone方法但是它没有实现Cloneable接口9.Co: Abstract class defines covariant compareTo() method (CO_ABSTRACT_SELF)抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：int compareTo(T o) 比较此对象与指定对象的顺序。10.Co: Covariant compareTo() method defined (CO_SELF_NO_OBJECT)类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型11.DE: Method might drop exception (DE_MIGHT_DROP)方法可能抛出异常12.DE: Method might ignore exception (DE_MIGHT_IGNORE)方法可能忽略异常13.DMI: Don’t use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)不要用removeAll方法去clear一个集合14.DP: Classloaders should only be created inside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)类加载器只能建立在特殊的方法体内15.Dm: Method invokes System.exit(…) (DM_EXIT)在方法中调用System.exit(…)语句，考虑用RuntimeException来代替16.Dm: Method invokes dangerous method runFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。17.ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)用==或者!=方法去比较String类型的参数18.ES: Comparison of String objects using == or != (ES_COMPARING_STRINGS_WITH_EQ)用==或者！=去比较String类型的对象19.Eq: Abstract class defines covariant equals() method (EQ_ABSTRACT_SELF)20.Eq: Equals checks for noncompatible operand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)equals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。public boolean equals(Object o) { if (o instanceof Foo) return name.equals(((Foo)o).name); else if (o instanceof String) return name.equals(o); else return false;21.Eq: Class defines compareTo(…) and uses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)类中定义了compareTo方法但是继承了Object中的compareTo方法22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换23.Eq: Covariant equals() method defined (EQ_SELF_NO_OBJECT)类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。24.FI: Empty finalizer should be deleted (FI_EMPTY)为空的finalizer方法应该删除。一下关于finalizer的内容省略25.GC: Unchecked type in generic call (GC_UNCHECKED_TYPE_IN_GENERIC_CALL)This call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.26.HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)方法定义了equals方法却没有定义hashCode方法27.HE: Class defines hashCode() but not equals() (HE_HASHCODE_NO_EQUALS) 类定义了hashCode方法去没有定义equal方法28.HE: Class defines equals() and uses Object.hashCode() (HE_EQUALS_USE_HASHCODE)一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法29.HE: Class inherits equals() and uses Object.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)子类继承了父类的equals方法却使用了Object的hashCode方法30.IC: Superclass uses subclass during initialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)子类在父类未初始化之前使用父类对象实例public class CircularClassInitialization { static class InnerClassSingleton extends CircularClassInitialization {static InnerClassSingleton singleton = new InnerClassSingleton(); } static CircularClassInitialization foo = InnerClassSingleton.singleton;}31.IMSE: Dubious catching of IllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法32.ISC: Needless instantiation of class that only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。33.It: Iterator next() method can’t throw NoSuchElementException (IT_NO_SUCH_ELEMENT)迭代器的next方法不能够抛出NoSuchElementException34.J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)在HttpSession对象中保存非连续的对象35.JCIP: Fields of immutable classes should be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS) The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .36.NP: Method with Boolean return type returns explicit null (NP_BOOLEAN_RETURN_NULL)返回值为boolean类型的方法直接返回null，这样会导致空指针异常37.NP: equals() method does not check for null argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)变量调用equals方法时没有进行是否为null的判断38.NP: toString method may return null (NP_TOSTRING_COULD_RETURN_NULL)toString方法可能返回null39.Nm: Class names should start with an upper case letter (NM_CLASS_NAMING_CONVENTION)类的名称以大写字母名称开头40.Nm: Class is not derived from an Exception, even though it is named as such (NM_CLASS_NOT_EXCEPTION)类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆41.Nm: Confusing method names (NM_CONFUSING)令人迷惑的方面命名42.Nm: Field names should start with a lower case letter (NM_FIELD_NAMING_CONVENTION)非final类型的字段需要遵循驼峰命名原则43.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)验证是否是java预留关键字44.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)验证是否时java中的关键字45.Nm: Method names should start with a lower case letter (NM_METHOD_NAMING_CONVENTION)方法名称以小写字母开头46.Nm: Class names shouldn’t shadow simple name of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中47.Nm: Class names shouldn’t shadow simple name of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中48.Nm: Very confusing method names (but perhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。49.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法import alpha.Foo;public class A { public int f(Foo x) { return 17; }}import beta.Foo;public class B extends A { public int f(Foo x) { return 42; } public int f(alpha.Foo x) { return 27; }}50.ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)方法中可能存在关闭数据连接失败的情况51.OS: Method may fail to close stream (OS_OPEN_STREAM)方法中可能存在关闭流失败的情况52.OS: Method may fail to close stream on exception (OS_OPEN_STREAM_EXCEPTION_PATH)方法中可能存在关闭流时出现异常情况53.RC: Suspicious reference comparison to constant (RC_REF_COMPARISON_BAD_PRACTICE)当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float54.RC: Suspicious reference comparison of Boolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。55.RR: Method ignores results of InputStream.read() (RR_NOT_CHECKED)InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。56.RR: Method ignores results of InputStream.skip() (SR_NOT_CHECKED)InputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况57.RV: Method ignores exceptional return value (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)方法忽略返回值的异常信息58.SI: Static initializer creates instance before all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。59.Se: Non-serializable value stored into instance field of a serializable class (SE_BAD_FIELD_STORE)非序列化的值保存在声明为序列化的的非序列化字段中60.Se: Comparator doesn’t implement Serializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)Comparator接口没有实现Serializable接口61.Se: Serializable inner class (SE_INNER_CLASS)序列化内部类62.Se: serialVersionUID isn’t final (SE_NONFINAL_SERIALVERSIONID)关于UID类的检查内容省略63.Se: Class is Serializable but its superclass doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)子类序列化时父类没有提供一个void的构造函数64.Se: Class is Externalizable but doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)Externalizable 实例类没有定义一个void类型的构造函数65.Se: The readResolve method must be declared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)readResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象66.Se: Transient field that isn’t set by deserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.67.SnVI: Class is Serializable, but doesn’t define serialVersionUID (SE_NO_SERIALVERSIONID)一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID： ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;68.UI: Usage of GetResource may be unsafe if class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)当一个类被子类继承后不要使用this.getClass().getResource(…)来获取资源四、Correctness关于代码正确性相关方面的1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)不可能的类转换，执行时会抛出ClassCastException2.BC: Impossible downcast (BC_IMPOSSIBLE_DOWNCAST)父类在向下进行类型转换时抛出ClassCastException3.BC: Impossible downcast of toArray() result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)集合转换为数组元素时发生的类转换错误。This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in:String[] getAsArray(Collection c) { return (String[]) c.toArray(); }This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can’t really do anything else, since the Collection object has no reference to the declared generic type of the collection.The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient).4.BC: instanceof will always return false (BC_IMPOSSIBLE_INSTANCEOF)采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。5.BIT: Incompatible bit masks (BIT_AND)错误的使用&amp;位操作符，例如(e &amp; C)6.BIT: Check to see if ((…) &amp; 0) == 0 (BIT_AND_ZZ)检查恒等的逻辑错误7.BIT: Incompatible bit masks (BIT_IOR)错误的使用|位操作符，例如(e | C)8.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK_HIGH_BIT)检查逻辑运算符操作返回的标识。例如((event.detail &amp; SWT.SELECTED) &gt; 0)，建议采用!=0代替&gt;09.BOA: Class overrides a method implemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用10.Bx: Primitive value is unboxed and coerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e211.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。12.DLS: Overwritten increment (DLS_OVERWRITTEN_INCREMENT)覆写增量增加错误i = i++13.DMI: Bad constant value for month (DMI_BAD_MONTH)hashNext方法调用next方法。14.DMI: Collections should not contain themselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)集合没有包含他们自己本身。15.DMI: Invocation of hashCode on an array (DMI_INVOKING_HASHCODE_ON_ARRAY)数组直接使用hashCode方法来返回哈希码。int [] a1 = new int[]{1,2,3,4}; System.out.println(a1.hashCode()); System.out.println(java.util.Arrays.hashCode(a1));16.DMI: Double.longBitsToDouble invoked on an int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)17.DMI: Vacuous call to collections (DMI_VACUOUS_SELF_COLLECTION_CALL)集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。18.Dm: Can’t use reflection to check for presence of annotation without runtime retention (DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)Unless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can’t be observed using reflection (e.g., by using the isAnnotationPresent method). .19.Dm: Useless/vacuous call to EasyMock method (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.20.EC: equals() used to compare array and nonarray (EC_ARRAY_AND_NONARRAY)数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);21.EC: equals(…) used to compare incompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]22.EC: Call to equals() with null argument (EC_NULL_ARG)调用equals的对象为null23.EC: Call to equals() comparing unrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)使用equals方法比较不相关的类和接口24.EC: Call to equals() comparing different interface types (EC_UNRELATED_INTERFACES)调用equals方法比较不同类型的接口25.EC: Call to equals() comparing different types (EC_UNRELATED_TYPES)调用equals方法比较不同类型的类26.EC: Using pointer equality to compare different types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.27.Eq: equals method always returns false (EQ_ALWAYS_FALSE)使用equals方法返回值总是false28.Eq: equals method always returns true (EQ_ALWAYS_TRUE)equals方法返回值总是true29.Eq: equals method compares class names rather than class objects (EQ_COMPARING_CLASS_NAMES)使用equals方法去比较一个类的实例和类的类型30.Eq: Covariant equals() method defined for enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)This class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don’t do it.31.Eq: equals() method defined that doesn’t override equals(Object) (EQ_OTHER_NO_OBJECT)类中定义的equals方法时不要覆写equals（Object）方法32.Eq: equals() method defined that doesn’t override Object.equals(Object) (EQ_OTHER_USE_OBJECT)类中定义的equals方法时不要覆写Object中的equals（Object）方法33.Eq: equals method overrides equals in superclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)34.Eq: Covariant equals() method defined, Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法35.FE: Doomed test for equality to NaN (FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).36.FS: Format string placeholder incompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)错误使用参数类型来格式化字符串37.FS: The type of a supplied argument doesn’t match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)指定的格式字符串和参数类型不匹配，例如：String.format(“%d”, “1”)38.FS: MessageFormat supplied where printf style format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。39.FS: More arguments are passed than are actually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)使用String的format方法时有非法的参数也经过了格式化操作。40.FS: Illegal format string (VA_FORMAT_STRING_ILLEGAL)格式化String对象语句错误41.FS: Format string references missing argument (VA_FORMAT_STRING_MISSING_ARGUMENT)String的format操作缺少必要的参数。42.FS: No previous argument for format string (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)格式字符串定义错误，例如：formatter.format(“%&lt;s %s”, “a”, “b”); 抛出MissingFormatArgumentException异常43.GC: No relationship between generic parameter and method argument (GC_UNRELATED_TYPES)This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.44.HE: Signature declares use of unhashable class in hashed construct (HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)A method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn’t fulfill the requirement that equal objects have equal hashCodes.45.HE: Use of class without a hashCode() method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)A class defines an equals(Object) method but not a hashCode() method, and thus doesn’t fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.46.ICAST: integral value cast to double and then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)integral的值转换为double后使用了Math.ceil方法47.ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)int 类型的值转换为float类型之后调用了Math.round方法48.IJU: JUnit assertion in run method will not be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)在JUnit中的断言在run方法中不会被告知49.IJU: TestCase declares a bad suite method (IJU_BAD_SUITE_METHOD)在一个JUnit类中声明的一个suite()方法必须声明为public static junit.framework.Test suite()或者public static junit.framework.TestSuite suite()的形式。50.IL: A collection is added to itself (IL_CONTAINER_ADDED_TO_ITSELF)集合本身作为add方法的参数，这样会引起内容溢出。51.IL: An apparent infinite loop (IL_INFINITE_LOOP)方法的自调用引起的死循环52.IM: Integer multiply of result of integer remainder (IM_MULTIPLYING_RESULT_OF_IREM)和整数余数进行乘法运算。例如：i % 60 * 1000 是进行(i % 60) * 1000运算而不是 i % (60 * 1000)53.INT: Bad comparison of nonnegative value with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)保证非负数和负数进行比较54.INT: Bad comparison of signed byte (INT_BAD_COMPARISON_WITH_SIGNED_BYTE)比较有符合数，要先把有符号数转换为无符合数再进行比较55.IO: Doomed attempt to append to an object output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。56.IP: A parameter is dead upon entry to a method but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)The initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者57.MF: Class defines field that masks a superclass field (MF_CLASS_MASKS_FIELD)子类中定义了和父类中同名的字段。在调用时会出错58.MF: Method defines a variable that obscures a field (MF_METHOD_MASKS_FIELD)在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。59.NP: Null pointer dereference (NP_ALWAYS_NULL)对象赋为null值后 没有被重新赋值60.NP: Null pointer dereference in method on exception path (NP_ALWAYS_NULL_EXCEPTION)A pointer which is null on an exception path is dereferenced here. This will lead to a NullPointerException when the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.空指针引用上调用去除引用方法，将发生空指针异常61.NP: Method does not check for null argument (NP_ARGUMENT_MIGHT_BE_NULL)方法没有判断参数是否为空62.NP: close() invoked on a value that is always null (NP_CLOSING_NULL)一个为空的对象调用close方法63.NP: Null value is guaranteed to be dereferenced (NP_GUARANTEED_DEREF)There is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).在正常的null判断分支上，对象去除引用操作是受保护的不允许的64.NP: Value is null and guaranteed to be dereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).65.NP: Method call passes null to a nonnull parameter (NP_NONNULL_PARAM_VIOLATION) 方法中为null的参数没有被重新赋值 void test(){String ss = null; sya(ss); } public void sya(String ad){ad.getBytes(); }66.NP: Method may return null, but is declared @NonNull (NP_NONNULL_RETURN_VIOLATION) 方法声明了返回值不能为空，但是方法中有可能返回null 67.NP: A known null value is checked to see if it is an instance of a type (NP_NULL_INSTANCEOF) 检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的 68.NP: Possible null pointer dereference (NP_NULL_ON_SOME_PATH) 对象可能没有重新赋值 69.NP: Possible null pointer dereference in method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION) A reference value which is null on some exception control path is dereferenced here. This may lead to a NullPointerException when the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning. Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible. 在异常null值处理分支调用的方法上，可能存在对象去除引用操作 70.NP: Method call passes null for nonnull parameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS) 方法参数中声明为nonnull类型的参数为null void test(){ String ss = null; sya(ss); } public void sya(@nonnull String ad){ad.getBytes(); }71.NP: Store of null value into field annotated NonNull (NP_STORE_INTO_NONNULL_FIELD) 为一个已经声明为不能为null值的属性赋值为null。 72.Nm: Class defines equal(Object); should it be equals(Object)? (NM_BAD_EQUAL) 类中定义了一个equal方法但是却不是覆写的Object对象的equals方法 73.Nm: Class defines hashcode(); should it be hashCode()? (NM_LCASE_HASHCODE) 类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法 74.Nm: Class defines tostring(); should it be toString()? (NM_LCASE_TOSTRING) 类中定义了一个toString方法但是却不是覆写的Object中的toString方法 75.Nm: Apparent method/constructor confusion (NM_METHOD_CONSTRUCTOR_CONFUSION) 构造方法定义混乱，保证一个标准的构造函数。 例如： SA(){ } void SA(){ }76.Nm: Very confusing method names (NM_VERY_CONFUSING) 混乱的方法命名，如getName和getname方法同时出现的时候 77.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE) 方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法 import alpha.Foo; public class A { public int f(Foo x) { return 17; } } import beta.Foo; public class B extends A { public int f(Foo x) { return 42; } } 78.QBA: Method assigns boolean literal in boolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT) 再if或者while表达式中使用boolean类型的值时应该使用去判断，而不是采用=操作 79.RC: Suspicious reference comparison (RC_REF_COMPARISON) 比较两个对象值是否相等时应该采用equals方法，而不是方法 80.RE: Invalid syntax for regular expression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION) 对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。 81.RE: File.separator used for regular expression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION) 使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\\’而应该使用’' 82.RV: Random value from 0 to 1 is coerced to the integer 0 (RV_01_TO_INT) 从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。 83.RV: Bad attempt to compute absolute value of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE) 此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。 在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。 84.RV: Bad attempt to compute absolute value of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT) 此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。 85.RV: Exception created and dropped rather than thrown (RV_EXCEPTION_NOT_THROWN) 此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x &lt; 0) new IllegalArgumentException(“x must be nonnegative”); 这可能是程序员的意图抛出创建的异常： if (x &lt; 0) throw new IllegalArgumentException(“x must be nonnegative”); 86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED) 该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name); dateString.trim(); 程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正： String dateString = getHeaderField(name); dateString = dateString.trim(); 87.RpC: Repeated conditional tests (RpC_REPEATED_CONDITIONAL_TEST) 该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。 88.SA: Double assignment of field (SA_FIELD_DOUBLE_ASSIGNMENT) 方法中的字段包含了双重任务，例如： int x; public void foo() { x = x = 17; } 这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。 89.SA: Self assignment of field (SA_FIELD_SELF_ASSIGNMENT) 方法中包含自己对自己赋值的字段。例如： int x; public void foo() { x = x; } 90.SA: Self comparison of field with itself (SA_FIELD_SELF_COMPARISON) 字段自己进行自比较可能表明错误或逻辑错误。 91.SA: Self comparison of value with itself (SA_LOCAL_SELF_COMPARISON) 方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。 92.SA: Nonsensical self computation involving a variable (e.g., x &amp; x) (SA_LOCAL_SELF_COMPUTATION) 此方法对同一变量执行了荒谬的计算（如x&amp;x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。 93.SF: Dead store due to switch statement fall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH) 在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。 94.SF: Dead store due to switch statement fall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW) 在swtich中因为出现异常而忽略了对case值的保存。 95.SIC: Deadly embrace of non-static inner class and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE) 如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。 96.SIO: Unnecessary type check done using instanceof operator (SIO_SUPERFLUOUS_INSTANCEOF) 在进行instanceof操作时进行没有必要的类型检查 97.STI: Unneeded use of currentThread() call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD) 此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。 98.STI: Static Thread.interrupted() method invoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD) 调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。 99.Se: Method must be private in order for serialization to work (SE_METHOD_MUST_BE_PRIVATE) 这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。 100.Se: The readResolve method must not be declared as a static method. (SE_READ_RESOLVE_IS_STATIC) 为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。 101.UMAC: Uncallable method defined in anonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS) 在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。 102.UR: Uninitialized read of field in constructor (UR_UNINIT_READ) 此构造方法中使用了一个尚未赋值的字段或属性。 String a; public SA() {String abc = a; System.out.println(abc); }103.UR: Uninitialized read of field method called from constructor of superclass (UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR) 方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如： abstract class A { int hashCode; abstract Object getValue(); A() { hashCode = getValue().hashCode(); } } class B extends A { Object value; B(Object v) { this.value = v; } Object getValue() { return value; } } 当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。 104.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY) 该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如： String[] a = { “a” }; System.out.println(a.toString()); //正确的使用为 System.out.println(Arrays.toString(a)); 105.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ARRAY) 该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组 106.UwF: Field only ever set to null (UWF_NULL_FIELD) 字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。 107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD 此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。 五：Performance关于代码性能相关方面的1.Bx: Primitive value is boxed and then immediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作2.Bx: Primitive value is boxed then unboxed to perform primitive coercion (BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：new Double(d).intValue()应该直接进行强制转换例如：(int) d3.Bx: Method allocates a boxed primitive just to call toString (DM_BOXED_PRIMITIVE_TOSTRING)仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：new Integer(1).toString() 替换为 Integer.toString(1)new Long(1).toString() 替换为 Long.toString(1)new Float(1.0).toString() 替换为 Float.toString(1.0)new Double(1.0).toString() 替换为 Double.toString(1.0)new Byte(1).toString() 替换为 Byte.toString(1)new Short(1).toString() 替换为 Short.toString(1)new Boolean(true).toString() 替换为 Boolean.toString(true)4.Bx: Method invokes inefficient floating-point Number constructor; use static valueOf instead (DM_FP_NUMBER_CTOR)使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。5.Bx: Method invokes inefficient Number constructor; use static valueOf instead (DM_NUMBER_CTOR)使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。6.Dm: The equals and hashCode methods of URL are blocking (DMI_BLOCKING_METHODS_ON_URL)使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。7.Dm: Maps and sets of URLs can be performance hogs (DMI_COLLECTION_OF_URLS)方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。8.Dm: Method invokes inefficient Boolean constructor; use Boolean.valueOf(…) instead (DM_BOOLEAN_CTOR)使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。9.Dm: Explicit garbage collection; extremely dubious except in benchmarking code (DM_GC)在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。10.Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE) 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)11.Dm: Method invokes inefficient new String(String) constructor (DM_STRING_CTOR)使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式12.Dm: Method invokes toString() method on a String (DM_STRING_TOSTRING)调用String.toString()是多余的操作，只要使用String就可以了。13.Dm: Method invokes inefficient new String() constructor (DM_STRING_VOID_CTOR)使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。14.ITA: Method uses toArray() with zero-length array argument (ITA_INEFFICIENT_TO_ARRAY)当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。15.SBSC: Method concatenates strings using + in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象例如：// This is bad String s = “”; for (int i = 0; i &lt; field.length; ++i) { s = s + field[i]; } // This is better StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; field.length; ++i) { buf.append(field[i]); } String s = buf.toString();16.SS: Unread field: should this field be static? (SS_SHOULD_BE_STATIC)类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。17.UM: Method calls static Math class method on a constant value (UM_UNNECESSARY_MATH)在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。Method Parameterabs -any-acos 0.0 or 1.0asin 0.0 or 1.0atan 0.0 or 1.0atan2 0.0 cbrt 0.0 or 1.0ceil -any-cos 0.0cosh 0.0exp 0.0 or 1.0expm1 0.0floor -any-log 0.0 or 1.0log10 0.0 or 1.0rint -any-round -any-sin 0.0sinh 0.0sqrt 0.0 or 1.0tan 0.0tanh 0.0toDegrees 0.0 or 1.0toRadians 0.018.UPM: Private method is never called (UPM_UNCALLED_PRIVATE_METHOD)定义为Private类型方法从未被调用，应该被删除。19.UrF: Unread field (URF_UNREAD_FIELD)类中定义的属性从未被调用，建议删除。20.UuF: Unused field (UUF_UNUSED_FIELD)类中定义的属性从未被使用，建议删除。21.WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。六：Internationalization关于代码国际化相关方面的Dm: Consider using Locale parameterized version of invoked method (DM_CONVERT_CASE)使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换String.toUpperCase( Locale l )String.toLowerCase( Locale l )七：Multithreaded correctness关于代码多线程正确性相关方面的1.DL: Synchronization on Boolean could lead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)该代码同步一个封装的原始常量，例如一个Boolean类型。private static Boolean inited = Boolean.FALSE;… synchronized(inited) { if (!inited) { init(); inited = Boolean.TRUE; } }…由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁2.DL: Synchronization on boxed primitive could lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)该代码同步一个封装的原始常量，例如一个Integer类型。private static Integer count = 0;… synchronized(count) { count++; }…由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁3.DL: Synchronization on interned String could lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。4.DL: Synchronization on boxed primitive values (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：private static final Integer fileLock = new Integer(1);… synchronized(fileLock) { .. do something .. }…它最后被定义为以下方式来代替：private static final Object fileLock = new Object(); 5.Dm: Monitor wait() called on Condition (DM_MONITOR_WAIT_ON_CONDITION)方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。6.Dm: A thread was created using the default empty run method (DM_USELESS_THREAD)这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。7.ESync: Empty synchronized block (ESync_EMPTY_SYNC)该代码包含一个空的同步块：synchronized() {}8.IS: Inconsistent synchronization (IS2_INCONSISTENT_SYNC)不合理的同步9.IS: Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED)域不是良好的同步访问— 此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问10.JLM: Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER)实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。11.LI: Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC)静态域不正确的延迟初始化–这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题12.LI: Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC)这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。13.ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。14.MSF: Mutable servlet field (MSF_MUTABLE_SERVLET_FIELD)一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。15.MWN: Mismatched notify() (MWN_MISMATCHED_NOTIFY)此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。16.MWN: Mismatched wait() (MWN_MISMATCHED_WAIT)此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。17.NP: Synchronize and null check on the same field. (NP_SYNC_AND_NULL_CHECK_FIELD)如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。18.No: Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL)调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。19.RS: Class’s readObject() method is synchronized (RS_READOBJECT_SYNC)序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。20.Ru: Invokes run on a thread (did you mean to start it instead?) (RU_INVOKE_RUN)这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。21.SC: Constructor invokes Thread.start() (SC_START_IN_CTOR)在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。22.SP: Method spins on field (SP_SPIN_ON_FIELD)方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）23.STCAL: Call to static Calendar (STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。Calendar rightNow = Calendar.getInstance();24.STCAL: Call to static DateFormat (STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。myString = DateFormat.getDateInstance().format(myDate); 25.STCAL: Static Calendar (STCAL_STATIC_CALENDAR_INSTANCE)Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。26.STCAL: Static DateFormat (STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。27.SWL: Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD)当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。28.UG: Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET)这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。29.UL: Method does not release lock on all paths (UL_UNRELEASED_LOCK)方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下： Lock l = …; l.lock(); try { // do something } finally { l.unlock(); }30.UL: Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下： Lock l = …; l.lock(); try { // do something } finally { l.unlock(); }31.UW: Unconditional wait (UW_UNCOND_WAIT)方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。32.VO: A volatile reference to an array doesn’t treat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性33.WL: Sychronization on getClass rather than class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码： private static final String base = “label”; private static int nameCounter = 0; String constructComponentName() { synchronized (getClass()) { return base + nameCounter++; } }Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为： private static final String base = “label”; private static int nameCounter = 0; String constructComponentName() { synchronized (Label.class) { return base + nameCounter++; } }34.WS: Class’s writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC)这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。35.Wa: Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP)方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。36.Wa: Wait not in loop (WA_NOT_IN_LOOP)这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。八：Malicious codevulnerability关于恶意破坏代码相关方面的1.EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP)返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。2.EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2)此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。3.FI: Finalizer should be protected, not public (FI_PUBLIC_SHOULD_BE_PROTECTED)一个类中的finalize（）方法必须声明为protected，而不能为public类型4.MS: Public static method may expose internal representation by returning array (MS_EXPOSE_REP)一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。5.MS: Field should be both final and package protected (MS_FINAL_PKGPROTECT)一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。6.MS: Field is a mutable array (MS_MUTABLE_ARRAY)一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。7.MS: Field is a mutable Hashtable (MS_MUTABLE_HASHTABLE)一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。8.MS: Field should be moved out of an interface and made package protected (MS_OOI_PKGPROTECT)将域尽量不要定义在接口中，并声明为包保护在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。9.MS: Field should be package protected (MS_PKGPROTECT)一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。十：Dodgy关于代码运行期安全方面的1.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。2.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。3.BC: Questionable cast to abstract collection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。4.BC: Questionable cast to concrete collection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。5.BC: Unchecked/unconfirmed cast (BC_UNCONFIRMED_CAST)强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。6.BC: instanceof will always return true (BC_VACUOUS_INSTANCEOF)instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。7.BSHIFT: Unsigned right shift cast to short/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）8.CI: Class is final but declares protected field (CI_CONFUSED_INHERITANCE)这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。9.DB: Method uses the same code for two branches (DB_DUPLICATE_BRANCHES)此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。10.DB: Method uses the same code for two switch clauses (DB_DUPLICATE_SWITCH_CLAUSES)他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。11.DLS: Dead store to local variable (DLS_DEAD_LOCAL_STORE)该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。12.DLS: Useless assignment in return statement (DLS_DEAD_LOCAL_STORE_IN_RETURN)本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。13.DLS: Dead store of null to local variable (DLS_DEAD_LOCAL_STORE_OF_NULL)把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。14.DMI: Code contains a hard coded reference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;15.DMI: Non serializable object written to ObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。16.DMI: Invocation of substring(0), which returns the original value (DMI_USELESS_SUBSTRING)此代码调用了subString(0)方法，它将返回原来的值。17.Eq: Class doesn’t override equals in superclass (EQ_DOESNT_OVERRIDE_EQUALS)子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。18.FE: Test for floating point equality (FE_FLOATING_POINT_EQUALITY)此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较19.FS: Non-Boolean argument formatted using %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false20.IC: Initialization circularity (IC_INIT_CIRCULARITY)在引用两个相互调用为环状static方法去初始化一个实例时是错误的。21.ICAST: integral division result cast to double or float (ICAST_IDIV_CAST_TO_DOUBLE)整形数除法强制转换为double或者float类型。int x = 2;int y = 5;// Wrong: yields result 0.0double value1 = x / y;// Right: yields result 0.4double value2 = x / (double) y;22.ICAST: Result of integer multiplication cast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)整形数做乘法运算结果转换为long值时如果采用long convertDaysToMilliseconds(int days) { return 1000360024days; } 结果会因为超出整形的范围而出错。如果使用：long convertDaysToMilliseconds(int days) { return 1000L360024days; }或者：static final long MILLISECONDS_PER_DAY = 24L36001000; long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }都可以避免此问题。23.IM: Computation of average could overflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x &amp; 1 == 1, or x % 2 != 0来代替24.INT: Vacuous comparison of integer value (INT_VACUOUS_COMPARISON)整形数进行比较结果总是不变。例如：x &lt;= Integer.MAX_VALUE25.MTIA: Class extends Servlet class and uses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。26.MTIA: Class extends Struts Action class and uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。27.NP: Dereference of the result of readLine() without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。28.NP: Immediate dereference of the result of readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。29.NP: Possible null pointer dereference due to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。30.NP: Parameter must be nonnull but is marked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)参数值在任何情况下都不能为空，但是有明确的注释它可以为空。31.NS: Potentially dangerous use of non-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，这会造成潜在的危险。32.NS: Questionable use of non-short-circuit logic (NS_NON_SHORT_CIRCUIT)代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，会引起不安全的操作33.PZLA: Consider returning a zero length array rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)考虑返回一个零长度的数组，而不是null值34.QF: Complicated, subtle or wrong increment in for-loop (QF_QUESTIONABLE_FOR_LOOP)确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。35.RCN: Redundant comparison of non-null value to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。36.RCN: Redundant comparison of two null values (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)方法中对两个null值进行比较37.RCN: Redundant nullcheck of value known to be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)方法中对不为空的值进行为空的判断。38.REC: Exception is caught when Exception is not thrown (REC_CATCH_EXCEPTION)在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获39.RI: Class implements same interface as superclass (RI_REDUNDANT_INTERFACES)子类和父类都实现了同一个接口，这种定义是多余的。40.RV: Method discards result of readLine after checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)readLine方法的结果不为空时被抛弃41.RV: Remainder of 32-bit signed random integer (RV_REM_OF_RANDOM_INT)此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。42.SA: Double assignment of local variable (SA_LOCAL_DOUBLE_ASSIGNMENT)为一个局部变量两次赋值，这样是没有意义的。例如：public void foo() { int x,y; x = x = 17; }43.SA: Self assignment of local variable (SA_LOCAL_SELF_ASSIGNMENT)局部变量使用自身给自己赋值public void foo() { int x = 3; x = x; }44.SF: Switch statement found where one case falls through to the next case (SF_SWITCH_FALLTHROUGH)Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。45.SF: Switch statement found where default case is missing (SF_SWITCH_NO_DEFAULT)Switch没有默认情况下执行的case语句。46.Se: private readResolve method not inherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)声明为private的序列化方法被子类继承47.UCF: Useless control flow (UCF_USELESS_CONTROL_FLOW)没有任何作用的条件语句。if (argv.length == 0) { // TODO: handle this case }48.UCF: Useless control flow to next line (UCF_USELESS_CONTROL_FLOW_NEXT_LINE)无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。if (argv.length == 1); System.out.println(“Hello, “ + argv[0]);49.UwF: Field not initialized in constructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。50.XFB: Method directly allocates a specific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：javax.xml.parsers.DocumentBuilderFactoryjavax.xml.parsers.SAXParserFactoryjavax.xml.transform.TransformerFactoryorg.w3c.dom.Document.createXXXX 6.1、 ES_COMPARING_PARAMETER_STRING_WITH_EQ ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ) This code compares a java.lang.String parameter for reference equality using the == or != operators. Requiring callers to pass only String constants or interned strings to a method is unnecessarily fragile, and rarely leads to measurable performance gains. Consider using the equals(Object) method instead. 使用 == 或者 != 来比较字符串或interned字符串，不会获得显著的性能提升，同时并不可靠，请考虑使用equals()方法。6.2、 HE_EQUALS_NO_HASHCODE HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE) This class overrides equals(Object), but does not override hashCode(). Therefore, the class may violate the invariant that equal objects must have equal hashcodes. 类定义了equals()方法但没有重写hashCode()方法，这样违背了相同对象必须具有相同的hashcodes的原则6.3、 IT_NO_SUCH_ELEMENT It: Iterator next() method can’t throw NoSuchElement exception (IT_NO_SUCH_ELEMENT) This class implements the java.util.Iterator interface. However, its next() method is not capable of throwing java.util.NoSuchElementException. The next() method should be changed so it throws NoSuchElementException if is called when there are no more elements to return. 迭代器Iterator无法抛出NoSuchElement异常，类实现了java.util.Iterator接口，但是next()方法无法抛出java.util.NoSuchElementException异常，因此，next()方法应该做如此修改，当被调用时，如果没有element返回，则抛出NoSuchElementException异常6.4、 J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION) This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result. 将没有实现serializable的对象放到HttpSession中，当这个session被钝化和迁移时，将会产生错误，建议放到HttpSession中的对象都实现serializable接口。6.5、 ODR_OPEN_DATABASE_RESOURCE ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE) The method creates a database resource (such as a database connection or row set), does not assign it to any fields, pass it to other methods, or return it, and does not appear to close the object on all paths out of the method. Failure to close database resources on all paths out of a method may result in poor performance, and could cause the application to have problems communicating with the database. 方法可能未关闭数据库资源，未关闭数据库资源将会导致性能变差，还可能引起应用与服务器间的通讯问题。6.6、 OS_OPEN_STREAM OS: Method may fail to close stream (OS_OPEN_STREAM) The method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method. This may result in a file descriptor leak. It is generally a good idea to use a finally block to ensure that streams are closed. 方法可能未关闭stream，方法产生了一个IO流，却未关闭，将会导致文件描绘符的泄漏，建议使用finally block来确保io stream被关闭。6.7、 DMI_CALLING_NEXT_FROM_HASNEXT DMI: hasNext method invokes next (DMI_CALLING_NEXT_FROM_HASNEXT) The hasNext() method invokes the next() method. This is almost certainly wrong, since the hasNext() method is not supposed to change the state of the iterator, and the next method is supposed to change the state of the iterator. 6.8、 IL_INFINITE_LOOP IL: An apparent infinite loop (IL_INFINITE_LOOP) This loop doesn’t seem to have a way to terminate (other than by perhaps throwing an exception). 明显的无限循环.6.9、 IL_INFINITE_RECURSIVE_LOOP IL: An apparent infinite recursive loop (IL_INFINITE_RECURSIVE_LOOP) This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow. 明显的无限迭代循环,将导致堆栈溢出.6.10、 WMI_WRONG_MAP_ITERATOR WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR) This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup. 使用了keySet iterator和Map.get(key)来获取Map值,这种方式效率低,建议使用entrySet的iterator效率更高.6.11、 IM_BAD_CHECK_FOR_ODD IM: Check for oddness that won’t work for negative numbers (IM_BAD_CHECK_FOR_ODD) The code uses x % 2 == 1 to check to see if a value is odd, but this won’t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0. 奇偶检测逻辑,未考虑负数情况.7.实际项目中Bug类型统计 7.1、 Call to equals() comparing different typesid : EC_UNRELATED_TYPES, type : EC, category : CORRECTNESS This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be false at runtime. 原因分析： 这缺陷的意思是，大部分都是类型永远不会有这种情况， 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的； 示例：if(“1”.equals(DAOValue.valueofSuccess())) 7.2、 Dead store to local variableid: DLS_DEAD_LOCAL_STORE, type: DLS, category: STYLE This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives. 原因分析： DLS问题指的是给本地变量赋了一个值，但随后的代码并没有用到这个值。 7.3、 Method call passes null for nonnull parameterid: NP_NULL_PARAM_DEREF, type: NP, category: CORRECTNESS This method call passes a null value for a nonnull method parameter. Either the parameter is annotated as a parameter that should always be nonnull, or analysis has shown that it will always be dereferenced. 原因分析：对参数为null的情况未作处理。 例如： 7.4、 Method with Boolean return type returns explicit nullid: NP_BOOLEAN_RETURN_NULL, type: NP, category: BAD_PRACTICE A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException. 原因分析： 方法如果定义为返回类型Boolean，则可以返回Boolean.TRUE, Boolean.FALSE or null （如果 return 的是 true or false， 则AutoBoxing 成 Boolean.TRUE, Boolean.FALSE）。因为JDK 支持 基本类型和装箱类型的自动转化， 所以下面的代码中： boolean result = test_NP_BOOLEAN_RETURN_NULL(); 因为此时test_NP_BOOLEAN_RETURN_NULL() 返回的是NULL， 所以 JDK 做 automatic unboxing 的操作时， 即调用了 object. booleanValue() 方法时，抛出了空指针。 改成：boolean result = test_NP_BOOLEAN_RETURN_NULL()==null?false:true; 7.5、 No relationship between generic parameter and method argumentid: GC_UNRELATED_TYPES, type: GC, category: CORRECTNESS This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method. In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String. In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks. 原因分析：调用Collection类中的contains方法比较时，所比较的两个参数类型不致； 例如： 修改后： 7.6、 Null pointer dereference in method on exception pathid: NP_ALWAYS_NULL_EXCEPTION, type: NP, category: CORRECTNESS A pointer which is null on an exception path is dereferenced here. This will lead to a NullPointerException when the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning. Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible. 原因分析：在异常处理时，调用一个空对象的方法时可能引起空指针异常。 例如： 7.7、 Nullcheck of value previously dereferencedid: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE, type:RCN, category: CORRECTNESS A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous. 原因分析：前面获取的对象，现在引用的时候没有交验是否为null。 例如： 7.8、 Possible null pointer dereferenceid: NP_NULL_ON_SOME_PATH, type: NP, category: CORRECTNESS There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of FindBugs. 原因分析：可能存在空引用。 例如： 7.9、 Possible null pointer dereference in method on exception pathid: NP_NULL_ON_SOME_PATH_EXCEPTION, type: NP, category:CORRECTNESS A reference value which is null on some exception control path is dereferenced here. This may lead to a NullPointerException when the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning. Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible. 原因分析： 代码调用时， 遇到异常分支， 可能造成一个对象没有获得赋值依旧保持NULL空指针。 接下来如果对这个对象有引用， 可能造成NullPointerException 空指针异常。 例如： 7.10、 Test for floating point equalityid: FE_FLOATING_POINT_EQUALITY, type: FE, category: STYLE This operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate. For values that must be precise, such as monetary values, consider using a fixed-precision type such as BigDecimal. For values that need not be precise, consider comparing for equality within some range, for example: if ( Math.abs(x - y) &lt; .0000001 ). See the Java Language Specification, section 4.2.4. 原因分析： Float类型的数据比较时，会存在的定的误差值，用!=来比较不是很准确，建议比较两个数的绝对值是否在一定的范围内来进行比较。如，if ( Math.abs(x - y) &lt; .0000001 ) 例如： 7.11、 Useless assignment in return statementid: DLS_DEAD_LOCAL_STORE_IN_RETURN, type: DLS, category: STYLE This statement assigns to a local variable in a return statement. This assignment has effect. Please verify that this statement does the right thing. 原因分析： 在return的对象中，没有必要通过对象赋值再进行返回。 例如： 7.12、 Write to static field from instance methodid: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD, type: ST, category:STYLE This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice. 原因分析：向static字段中写入值。 例如： private static DBRBO dbrBO; public final void refresh() { danskeBankBO = null; dbrBO = null; fileAndPathBO = null; }建议改为：去掉static。 7.13、 Incorrect lazy initialization and update of static fieldid: LI_LAZY_INIT_UPDATE_STATIC, type: LI, category: MT_CORRECTNESS This method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very seriousmultithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized. Even if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized. 原因分析： 该方法的初始化中包含了一个迟缓初始化的静态变量。你的方法引用了一个静态变量，估计是类静态变量，那么多线程调用这个方法时，你的变量就会面临线程安全的问题了，除非别的东西阻止任何其他线程访问存储对象从直到它完全被初始化。 7.14、 Method ignores return valueid: RV_RETURN_VALUE_IGNORED, type: RV, category: CORRECTNESS The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment, String dateString = getHeaderField(name); dateString.trim(); the programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to: String dateString = getHeaderField(name); dateString = dateString.trim(); 原因分析：方法忽略了设置返回值。 例如： 7.15、 Method might ignore exceptionid: DE_MIGHT_IGNORE, type: DE, category: BAD_PRACTICE This method might ignore an exception.Â In general, exceptions should be handled or reported in some way, or they should be thrown out of the method. 原因分析：应该将异常 处理、打印或者抛出 例如： 7.16、 Unwritten fieldid: UWF_UNWRITTEN_FIELD, type: UwF, category: CORRECTNESS This field is never written.Â All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless. 原因分析：从未被初始化的变量，调用它时，将返回默认值，要么初始化，要么删掉它。 例如： 7.17、 Value is null and guaranteed to be dereferenced on exception pathid: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH, type: NP, category:CORRECTNESS There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions). 原因分析：exception分支上，存在引用一个null对象的方法，引发空指针异常。 例如： 7.18、 Very confusing method namesid: NM_VERY_CONFUSING, type: Nm, category: CORRECTNESS The referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other. 原因分析：被引用的方法中存在容易混淆的变量。 例如：fzgsdm改成 fzgsDm 即可。 7.19、 Method invokes inefficient new String() constructorid: DM_STRING_VOID_CTOR, type: Dm, category: Performance Creating a new java.lang.String object using the no-argument constructor wastes memory because the object so created will be functionally indistinguishable from the empty string constant “”. Java guarantees that identical string constants will be represented by the same String object. Therefore, you should just use the empty string constant directly. 原因分析：不使用new String()定义空的字符串 例如： 7.20、 Load of known null valueid: NP_LOAD_OF_KNOWN_NULL_VALUE, type: Np, category: Dodgy The variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake (perhaps you intended to refer to a different variable, or perhaps the earlier check to see if the variable is null should have been a check to see if it was nonnull). 原因分析：null值的不当使用。 例如： 7.21、 Method concatenates strings using + in a loopid: SBSC_USE_STRINGBUFFER_CONCATENATION, type: SBSC, category: Performance The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration. Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly. For example: // This is bad String s = “”; for (int i = 0; i &lt; field.length; ++i) { s = s + field[i]; } // This is better StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; field.length; ++i) { buf.append(field[i]); } String s = buf.toString(); 原因分析：在循环里使用字符串连接，效率低，应该使用StringBuilder/StringBuffer findbugs 错误分析日志 findbugs 出错类型及对应解释终于 我们又开始使用FINDBUGS来检测代码的问题了 但因没又中文版和网上错误分析实际很少 所以自己边处理BUG边写文档 首先在装好FINDBUGS后 在 project–&gt;properteis–&gt;findbugs里的2个框的勾点上可以让改正BUG后自动判断是否改正了 改正了就自动去掉BUG点 1、Dead store to local variable 本地变量存储了闲置不用的对象举例：List accountCoList = new ArrayList();我们为accountCoList新建了一个对象，但是程序的后面并没有使用这个这个新建对象。建议改为：List accountCoList = null; This instruction assigns a value to a local variable, but the value is not read or used in any subsequentinstruction. Often, this indicates an error, because the value computed is never used.Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs isa bytecode-based tool, there is no easy way to eliminate these false positives.本地变量存储了闲置不用的对象，也就是说这个变量是多余的。Hashtable hTable = new Hashtable();Object obj = new Object();obj = hTable.put(“uuid”, “abcd1234”); String abc = “abc”; String xyz = new String(“”); xyz = abc; System.out.println(xyz);用findbug檢查會出現Dead store to local variable的錯誤，他的意思是“本地变量存储了闲置不用的对象”為什么會出現這個原因呢？ 因為 String xyz = new String(“”); 这一句执行3个动作： 1)创建一个引用xyz 2)创建一个String对象 3)把String的引用赋值给xyz 其中，后面两个动作是多余的，因为后面的程序中你没有使用这个新建的String对象，而是重新给xyz赋值，xyz = abc;所以，只需要String xyz = abc; 就可以了。这样，findbugs就不会报了。 2、Write to static field from instance method 向static字段中写入值举例： private static DBRBO dbrBO; public final void refresh() { danskeBankBO = null; dbrBO = null; fileAndPathBO = null; }建议改为：去掉static。 This instance method writes to a static field. This is tricky to get correct if multiple instances arebeing manipulated, and generally bad practice.向static字段中写入值，如： private static Logger logger; public XXXActionCtrl(){ logger = Logger.getLogger(getClass()); }可改为：private static Logger logger = Logger.getLogger(getClass());Unread field: should this field be static?This class contains an instance final field that is initialized to a compile-time static value. Consider 3、Load of known null value 大体意思是加载了null的对象。举例 if (null == boList) { for (int i = 0; i &lt; boList.size(); i++) { entityList.add(productBOToEntity(boList.get(i))); } } 4、Exception is caught when Exception is not thrown这个意思比较好理解：就是catch了异常但是try里并没有抛出异常 异常被捕获但没抛出。。。。 一般人都会这样写代码： try{ // } catch(Exception ex){ // } 这样很省事，但是JAVA规范中并不推荐这样做，这样是属于“过泛地捕获异常”，因为try{}中可能出现的异常种类有很多，上面的做法不利于分别处理各种异常，建议根 据业务需求，分别捕获需要特别处理的异常，例子如下： try{ // } catch(SQLException ex){ // } catch(IOException ex){ // } catch(Exception ex){ // } 另外一个是，捕获到的Exception应尽量记录到LOG文件里。 5、Method ignores exceptional return value没有对方法的异常返回值进行检查 6、Comparison of String objects using == or !=This code compares java.lang.String objects for reference equality using the == or != operators.Unless both strings are either constants in a source file, or have been interned using the String.intern() method, the same string value may be represented by two different String objects. Consider using the equals(Object) method instead. 从字面意思可以理解String对象进行比较的时候：只有两种情况可以使用== or !=的，这两种情况是；在源文件中是个常数或者是调用 String.intern()方法，使用String的规范化表示形式来进行比较,如果不是这两中情况的话推荐使用.equals(object)方式 7、Method names should start with a lower case letter这个好理解方法名的第一个字母不能是大写 函数的首字母应该小写。 8、Non-transient non-serializable instance field in serializable classThis Serializable class defines a non-primitive instance field which is neither transient, Serializable, or java.lang.Object, and does not appear to implement the Externalizable interface or the readObject() and writeObject() methods.? Objects of this class will not be deserialized correctly if a non-Serializable object is stored in this field.这个错误的意思是：在可序列化的类中存在不能序列化或者不能暂存的数据在可序列化的类中存在不能序列化或者不能暂存的数据 9.Call to equals() comparing different types 大部分都是类型永远不会有这种情况 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的的equals比较了不同的对象类型 说的是equals要比较相同的对象类型This method calls equals(Object) on two references of different class types with no common subclasses.Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless someapplication classes were not analyzed, or dynamic class loading can occur at runtime). According to thecontract of equals(), objects of different classes should always compare as unequal; therefore, accordingto the contract defined by java.lang.Object.equals(Object), the result of this comparison will always befalse at runtime.调用equals()比较不同的类型。此方法调用相当于两个不同的类类型的引用，没有共同的子类（对象）。因此，所比较的对象是不太可能在运行时相同的类成员（除非一些应用类没有分析或动态类加载可以发生在运行时）。据equals()的规则，不同类的对象应始终比较不平等，因此，根据由java.lang.Object.equals定义的合同（对象），FALSE将永远是比较的结果在运行时错误。 10.Class doesn’t override equals in superclass super.equals(obj) 调用父类equals方法 一般都是Object的方法，所以这个super可写可不写，一般都是 为了代码的可读性才加上去的 一般就是重写equals(obj)即可 即public boolean equals(Object obj){ return super.equals(obj);} 但是如果覆盖了equals()方法的话，则必须要覆盖hashCode()方法。否则FINDBUGS会出现下面的7号BUG:覆盖了equals()方法的话，则必须要覆盖hashCode()方法 所以 public boolean equals(Object obj){ return super.equals(obj);} public int hashCode(){ return super.hashCode();} 11.Class is Serializable, but doesn’t define serialVersionUID serialVersionUID 用来表明类的不同版本间的兼容性 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地 相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个 serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID 。 如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long 的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。 也就是这个错误 你要定义一个名为 serialVersionUID，类型为long的变量 按照新版Eclipse自动填写规则 就是： private static final long serialVersionUID = 1L; 12.Class names shouldn’t shadow simple name of superclass 基本就是这个类的名字跟超类的名字一样但不在一个包里 所以就改下类名啦 13.Comparison of String parameter using == or != 原因：当比较两个字符串内容是否相同时，仅当两个字符串在源文件中都是常量时或者是使用intern()来比较才可以用==来比较， 否则最好使用对象比较方法equal。附string比较： String str1 = “java”; String str2 = “java”; System.out.print(str1==str2); 结果：true(二者都为常量) String str1 = new String(“java”); String str2 = new String(“java”); System.out.print(str1==str2); 结果：false（二者为对象） String str1 = “java”; String str2 = “blog”; String s = str1+str2; System.out.print(s==”javablog”); 结果：false(s不为常量，为对象) String s1 = “java”; String s2 = new String(“java”); System.out.print(s1.intern()==s2.intern()); 结果：true(但是intern（）方法在效率和实现方式上不统一) 14.Equals checks for noncompatible operand equals()方法比较的是值是否相同，而不是内存指向地址 就实际情况来看 是因为 public boolean equals(Object object) { if (!(object instanceof DmZzmm)) { return false; } Dxinfo rhs = (Dxinfo) object; return new EqualsBuilder().append(this.dxcount, rhs.dxcount).append(this.lxrsjh, rhs.lxrsjh) .append(this.dxnr, rhs.dxnr).append(this.fssj, rhs.fssj).append(this.fssl, rhs.fssl) .append(this.id,rhs.id).isEquals(); 。。。。 } 问题在那里？很简单 这个白痴是拷贝的代码 既然object 不为DmZzmm就为false 而你要执行的是 Dxinfo rhs = (Dxinfo) object; 所以如果为DMZzmm进入代码 会因为不是 Dxinfo 类型而不执行下面的代码 如果为Dxinfo 类型 它就直接执行为FALSE!!所以代码毫无意义 只会执行false!! 所以只需要把 public boolean equals(Object object) { if (object instanceof Dxinfo) { Dxinfo rhs = (Dxinfo) object; 。。。。。。。 }else{ return false; } 就可以了 说穿了 就是你准备用instanceof 匹配的类要跟你下面执行的类要一致。。。。 15.equals method always returns false equals始终返回false 嘛。。。就是没继承超类的话要自己写个EQUALS。。。。别写的没意义只有false就是了。。 public boolean equals(Object o) { return (this==o);} 16.equals() method does not check for null argument equals（）方法没检查空参数 2B错误完全不解释 17.Field names should start with a lower case letter 字段名应该用小写 18.Can’t close pw since it is always null 无法关闭【PW】因为总是为NULL 19.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)/AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)示例代码：ZipEntry entry = new ZipEntry(PATH);zos.putNextEntry(entry);zos.closeEntry();原因：代码中在调用putNextEntry()之后紧接着调用了closeEntry()函数，致使该jar文件内容为空，因为打jar包的写内容是在putNextEntry()和closeEntry()两个函数调用之间来进行的。（有时候也许会有意的构建一个空目录，因此不一定就是bug） 20.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)示例代码：public class Foo { // some code public void equals(Object o) { Foo other = (Foo) o; // the real equals code }}原因：当你在实现类的equals方法时，不应该对参数有任何的预先设定。如上代码所写，则设定了参数o肯定是Foo类的一个对象.但是如果在函数调用时，参数o不是一个Foo类或其子类，就会导致代码会抛出一个ClassCastException。因此在实现equals方法，应该加一个判断，如果参数o不是一个Foo类对象，则返回false。 21.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)示例代码：public int getRandom(int seed) { return new Random(seed).nextInt();}原因：由于java.util.Random是一个伪随机函数，如果传入的seed值相同的话，返回的随机数者是相同的 。因此没必要每次都new一个新的random出来计算随机数。如果你想真正地获得一个不可预知的随机数，建议使用java.security.SecureRandom，该类继承自Random，是一个强随机数生成器 。因此上述代码可以修改为：public class Test extends Thread{ private SecureRandom ran; Test(int seed){ ran = new SecureRandom(); } public int getRandom(int seed) { return ran.nextInt(); }} 22.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)示例代码：public class Foo implements Cloneable { public Object clone() throws CloneNotSupportedException { return super.clone(); } }原因：类定义要实现了 Cloneable接口，却没有定义或使用 clone方法，即缺少红色字体部分。 23.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)示例代码：public class Foo implements Cloneable { public Object clone() throws CloneNotSupportedException { return super.clone(); }}原因：clone方法没有调用super.clone()方法，如果没有调用，则会导致对象父子层级关系不能正确建立，最终导致无法正确组装对象。 24.CN: Class defines clone() but doesn’t implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)示例代码：public class Foo{ public Object clone() throws CloneNotSupportedException { return super.clone(); }}原因：这个用法的意义在于你可以规范该类的子类的clone的实现，如果你的确想这样做的话，这不是一个bug,否则的话是一个bug 25.DE: Method might drop exception (DE_MIGHT_DROP)/DE: Method might ignore exception (DE_MIGHT_IGNORE)示例代码：try{}catch(Exception ex){}原因：方法有可能抛异常或者忽略异常，需要对异常进行处理,即需要在catch体中对异常进行处理。 8.DMI: Don’t use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)原因：建议不要使用 collection.removeAll(collection)方法来删除 collection中的所有元素，而使用collection.clear()。比较二者的代码实现就可以看出：removeAll()源码： public boolean removeAll(Collection c) { boolean modified = false; Iterator e = iterator(); while (e.hasNext()) { if (c.contains(e.next())) { e.remove(); modified = true; } } return modified; }clear()源码： public void clear() { Iterator e = iterator(); while (e.hasNext()) { e.next(); e.remove(); } }前者是比较参数中的collection和要移除元素的collection中是否有交集，然后将交集元素删除；后者是直接将collenction中的元素删除。显然后者要比前者高效，而且对于某些特殊的collenction还容易抛出一些异常，如ConcurrentModificationException 26.May expose internal representation by incorporating reference to mutable object JAVA里，对象是引用传递的，setObj的时候，对象不要直接赋值(this.regDate = regDate)，可改为：this.regDate = (Date)regDate.clone();， 27.Uninitialized read of field in constructor 构造函数没有初始化; 28.Method concatenates strings using + in a loopThe method seems to be building a String using concatenation in a loop. In each iteration, the String isconverted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to acost quadratic in the number of iterations, as the growing string is recopied in each iteration.Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.字符串串联使用方法在一个循环+该方法似乎是建立在循环使用字符串串联。在每次迭代中，字符串转换为一个StringBuffer / StringBuilder的，附加到 并转换回为String。这可能导致成本的二次迭代，因为不断增长的字符串是在每次迭代中重新复制。更好的性能，可使用StringBuffer（或StringBuilder的）会更好一些。For example: // This is bad String s = “”; for (int i = 0; i &lt; field.length; ++i) { s = s + field[i]; } // This is better StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; field.length; ++i) { buf.append(field[i]); } String s = buf.toString(); 29.May expose internal representation by incorporating reference to mutableobject.This code stores a reference to an externally mutableobject into the internal representation of the object.If instancesare accessed by untrusted code,and unchecked changes to the mutable object would compromise security orother important properties,you will need to do something different.Storing a copy of the object is better approach in many situations.可能因使引用可指向多个对象而暴露内部存储结构。这代码使一个指向外部多个对象的引用指向了一个内部对象存储地址。如果实例被未被信任代码访问或多个对象发生了未经检查的改变就会危及安全性或其它重要属性，你需要去做一些不同的事情。存储一个对象的拷贝在许多情况下会是一个更好的方法。网上findbug使用的介绍文章中写到,按下面修改findbug就没bug提示了,为什么要放到一个临时变量中就可以了?public class Test {private String[] name;public String[] getName() {String[] temp = name;return temp;}public void setName(String[] name) {String[] temp = name;this.name = temp;}}因为代码中会经常出现getter/setter，我觉得这个bug是不必要进行修改的。 30.making the field static.未读的领域：这个领域应该是静态的？这个类包含一个实例的最后字段初始化为编译时静态值。考虑静态的领域。（findbugs建议修改该属性为static的）。如：private final String FAIL_FLAG = “exit”;改为：private static final String FAIL_FLAG = “exit”; 31.Unread fieldThis field is never read. Consider removing it from the class.未读的领域（字段，属性）类中声明了从未用过的字段。考虑从类中删除。 32.Inefficient use of keySet iterator instead of entrySet iteratorThis method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator.It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.低效利用，使用keySet迭代器而不是entrySet迭代器。使用entrySet效率会比keySet高。keySet()迭代后只能通过get()取key。entrySet()迭代后可以e.getKey()，e.getValue()取key和value，返回的是Entry接口。 33.Field isn’t final but should be.A mutable static field could be changed by malicious code or by accident from another package. The fieldcould be made final to avoid this vulnerability.字段应该声明为final，实际上却未声明final。一个易变的static字段可以被恶意代码改变，使用final关键字以避免此漏洞。 34.Call to equals() with null argument.This method calls equals(Object), passing a null value as the argument.According to the contract of the equals() method, this call should always return false.使用null参数调用equals()。此方法调用等于（对象），作为参数传递一个空值。根据合同的equals（）方法，此调用应始终返回false。如：queryStr.equals(null); 这样使用是不可取的，虽然能够通过编译。 35.Invocation of toString on an array.The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472.Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array.See Programming Puzzlers, chapter 3, puzzle 12.对数组调用toString()方法。代码在对数组调用toString()方法时，将产生一个相当无用的形如 [C@16f0472 的结果。考虑使用 Arrays.toString方法 将数组转化为一个可读的给出数组内容的字符串。比如：在使用System.out.println(xx.readNext());时候会碰到这样的提示，readNext() 方法放回一个String[]。可改为：String[] arr = reader.readNext();System.out.println(Arrays.asList(arr).toString());（好像有点麻烦，没想到更简洁的办法）。 36.Nullcheck of value previously dereferencedA value is checked here to see whether it is null, but this value can’t be null because it was previouslydereferenced and if it were null a null pointer exception would have occurred at the earlier dereference.Essentially, this code and the previous dereference disagree as to whether this value is allowed to benull. Either the check is redundant or the previous dereference is erroneous.此代码之前废弃null值检查。一个值被选中这里看它是否是空的，但这个值不能为空，因为它在此之前废弃null值检查，而且如果它为null，空指针异常将会发生在此处，如果它是空一空指针异常会发生在较早取消引用。从本质上讲，此代码和前边废弃的null值检查将会出现不一致，是否这个值是容许空。出现该bug有两种情况：多余的null检查；前边废弃null值检查的。比如：我们经常会这个使用ActionForm，String clazzId = request.getParameter(“clazzId”);// script1studentForm.setClazzID(clazzId);// script2往往会在script2会出现该错误，因为在script1出未检查clazzId是否为null才导致的。修改为 ：if(clazzId != null) {studentForm.setClazzID(clazzId);}在设置使用clazzId之前先判断其是否为null。 37.Possible null pointer dereference in method on exception pathA reference value which is null on some exception control path is dereferenced here. This may lead to a NullPointerException when the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.在异常部分放弃null值检查，可能会导致后面的代码出现空指针异常。如：md = null;try { md = MessageDigest.getInstance(“SHA-256”); md.update(bt); } catch (NoSuchAlgorithmException e) { e.printStackTrace();// script1 } byte[] digest = md.digest();// script2bug出现在script2处，在script1处处理相应的exception即可，如throw 或 return； Possible null pointer dereferenceThere is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of FindBugs.可能的空指针引用。如在JDBC编程时候，在关闭ResultSet时候(rs.close())，经常会出现这个bug，解决办法很容易想到，判断是否为null或 使用try…catch…finally。 相关资料： 1：hyddd的FindBugs分析记录用FindBugs分析代码漏洞 hyddd 阅读:6139 评论:13http://www.cnblogs.com/hyddd/tag/hyddd%E7%9A%84FindBugs%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/ 1.[hyddd的FindBugs分析记录][H STCAL] Call to static DateFormat上面的英文解释其实应该说得比较清楚，在Java文档中，已经明确说明了DateFormats 是非线程安全的，而在SimpleDateFormat的Jdk 的Source文件中，我们也找到这么一段注释，说明它不是线程安全的。导致SimpleDateFormat出现多线程安全问题的原因，是因为：SimpleDateFormat处理复杂，Jdk的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。而Findbugs所说的“Call to static DateFormat”，其实就是一些人：为了渐少new 的次数而把SimpleDateFormat做成成员或者静态成员，上面已经说了，这样做是不安全的。 2.[hyddd的FindBugs分析记录][M S XSS] Class defines clone() but doesn’t implement Cloneable[H B CN] Class defines clone() but doesn’t implement Cloneable [CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE]This class defines a clone() method but the class doesn’t implement Cloneable.There are some situations in which this is OK (e.g., you want to control how subclasses can clone themselves),but just make sure that this is what you intended. 什么代码会引起这个问题呢？先看下面： 1: class MyTest { 2: public MyTest clone(){ 3: MyTest test = new MyTest(); 4: return test; 5: } 6: }这段代码会引起FindBugs的这个警告，为什么？请看下面解释：1.根据FindBugs的说明，如果一个类重写clone()函数，而不继承Cloneable接口，是一定有问题的，如果clone()方法只是简单进行克隆，如：new一个对象并初始化，然后返回这个新创建的对象的话，不继承Cloneable接口也是可以的。2.如果是上面这样的话，为什么还要继承Cloneable接口呢？稍微说一下，Cloneable接口是不包含任何方法的！其实这个接口仅仅是一个标志，而且这个标志也仅仅是针对Object类中clone()方法的，如果clone类没有实现 Cloneable接口，并调用了Object的clone()方法（也就是调用了super.Clone()方法），那么Object的clone() 方法就会抛出CloneNotSupportedException异常。3.所以这里建议是：规范写法，如果重写clone()，最好请继承Cloneable接口。 3.[hyddd的FindBugs分析记录][M S XSS] Servlet reflected cross site scripting vulnerability[M S XSS] Servlet reflected cross site scripting vulnerability [XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER]This code directly writes an HTTP parameter to Servlet output, which allows for a reflected cross site scripting vulnerability.See http://en.wikipedia.org/wiki/Cross-site_scripting for more information.FindBugs looks only for the most blatant, obvious cases of cross site scripting. If FindBugs found any,you almost certainly have more cross site scripting vulnerabilities that FindBugs doesn’t report. If you are concerned about cross site scripting, you should seriously consider using a commercial static analysis or pen-testing tool.先看下面代码：public void doGet(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException{ // String v = request.getParameter(“v”); // PrintWriter out = response.getWriter(); out.print(“协议版本号不对,v=”+v); out.close(); //}这里字符串v没有作过滤，直接返回给用户，有可能操作XSS攻击。具体关于XSS攻击的资料，可以参考上面Findbugs说明中的连接，这里就不多说了。 4.[hyddd的FindBugs分析记录]M D ICAST] Result of integer multiplication cast to long[M D ICAST] Result of integer multiplication cast to long [ICAST_INTEGER_MULTIPLY_CAST_TO_LONG]This code performs integer multiply and then converts the result to a long, as in: long convertDaysToMilliseconds(int days) { return 1000360024days; }If the multiplication is done using long arithmetic, you can avoid the possibility that the result will overflow.For example, you could fix the above code to:long convertDaysToMilliseconds(int days) { return 1000L360024days; }orstatic final long MILLISECONDS_PER_DAY = 24L36001000; long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }其实看上面的例子可以看到了long convertDaysToMilliseconds(int days) { return 1000360024days; }这段代码是有可能溢出的，建议把代码改为下面：long convertDaysToMilliseconds(int days) { return 1000L360024days; }用过VB6的人应该了解为什么会这样，因为在VB6里面一不小心就有可能出现这种溢出，在这里，JAVA认为：int * int * …..它的结果还是一个int！为什么编译器不能自动识别呢？答案是：很麻烦，并且这会使用编译器的效率非常低！ 对于有汇编经验的人来说，应该了解用汇编实现动态判断一个结果应该分配到一个long的空间还是int的空间有多复杂吧， 而编译器有不能随便随便把int * int 的结果分配一个long空间，因为这会非常浪费内存，所以出于对效率和资源的考虑， 最后的决定就是，凡是int * int * ….这样的计算结果一律都存放到int空间里，如果是long * int * …..则一律存放到long空间里， 这就解释了为什么上面要在1000后面加个”L”了。:&gt; [hyddd的FindBugs分析记录][M B DE] Method might ignore exceptionThis method might ignore an exception. In general, exceptions should be handled or reported in some way,or they should be thrown out of the method.try{//}Catch(Execption ex){}//上面这段代码没有对ex进行任何处理。Findbugs在这里想说明的就是上面这个问题。 5.[hyddd的FindBugs分析记录][M M IS] Inconsistent synchronization追加说明 6.[hyddd的FindBugs分析记录][M B Eq] Class defines compareTo(…) and uses Object.equals()重写compareTo有一定的风险，因为你不知道JDK内部做对象对比时，到底使用了compareTo还是equals。例如：在JAVA5 里，PriorityQueue.remove中使用了compareTo，但JAVA6中，PriorityQueue.remove使用了equals方法。 这里Findbugs强烈建议：(x.compareTo(y)==0) == (x.equals(y))，当你重写compareTo的时候，请记得这一点:&gt;，当然这个只是建议，不是绝对的。 7.[hyddd的FindBugs分析记录][H C EC] equals() used to compare array and nonarrayThis method invokes the .equals(Object o) to compare an array and a reference that doesn’t seem to be an array.If things being compared are of different types, they are guaranteed to be unequal and the comparison is almost certainly an error.Even if they are both arrays, the equals method on arrays only determines of the two arrays are the same object.To compare the contents of the arrays, use java.util.Arrays.equals(Object[], Object[]).先看下面一段代码：String[] strs = {“1”};//.If(“1”.equals(strs)){//todo}上面这段代码，if里面的代码是永远都不会被执行的，因为我们用了一个非数据（nonarray）和一个数组(array)做equals()，这里估计是写代码时的笔误。 8.[hyddd的FindBugs分析记录][H C FS] Format string references missing argumentNot enough arguments are passed to satisfy a placeholder in the format string.A runtime exception will occur when this statement is executed.看实例代码：public static void main(String args[]) throws Exception{ String sqlrightDate = “select state from right where user_id = ‘%s’ and soft_code =’%s’ and right_name = ‘%s’ “; String str = String.format(sqlrightDate,”1” ,”2”); System.out.println(str);}对，你没有眼花，format里面只传了两个参数，但sqlrightData需要的是三个参数！这可能值是你的一个笔误，相信没人会故意写这样的代码，但编译器检查不出这种问题，这导致运行时这里会抛异常，所以用FindBugs扫扫代码还是有点用处的～！ 9.[hyddd的FindBugs分析记录][M B Nm] Class names should start with an upper case letterJAVA里，类的首字母需要大写，这个不多说了。 10.[hyddd的FindBugs分析记录][H B BC] Random object created and used only once1.new一个Random的对象，保存之，然后每次都使用这个对象去获取随机数，而不要每次new一个Random对象去获取。2.FindBugs强烈推荐使用java.security.SecureRandom代替Random。 11.[hyddd的FindBugs分析记录][M D REC] Exception is caught when Exception is not thrown略 上有 12.[hyddd的FindBugs分析记录][M D DLS] Dead store to local variable略 上有 13.[hyddd的FindBugs分析记录][M P UuF] Unused field说明某个类里的某个变量没有被使用。FindBugs建议你把无用东西去除掉。 14.[hyddd的FindBugs分析记录][M B ODR] Method may fail to close database resource请参考：[M X OBL] Method may fail to clean up stream or resource注意：同一个问题可能引发两个不同的BUG警告～！ 15.[hyddd的FindBugs分析记录][M X OBL] Method may fail to clean up stream or resource[M X OBL] Method may fail to clean up stream or resource [OBL_UNSATISFIED_OBLIGATION]This method may fail to clean up (close, dispose of) a stream, database object, or other resource requiring an explicit cleanup operation.In general, if a method opens a stream or other resource, the method should use a try/finally block to ensure that the stream or resource is cleaned up before the method returns.This bug pattern is essentially the same as the OS_OPEN_STREAM and ODR_OPEN_DATABASE_RESOURCE bug patterns,but is based on a different (and hopefully better) static analysis technique. We are interested is getting feedback about theusefulness of this bug pattern. To send feedback, either:send email to findbugs@cs.umd.edufile a bug report: http://findbugs.sourceforge.net/reportingBugs.htmlIn particular, the false-positive suppression heuristics for this bug pattern have not been extensively tuned,so reports about false positives are helpful to us.See Weimer and Necula, Finding and Preventing Run-Time Error Handling Mistakes, for a description of the analysis technique.这个BUG想说明的是：有些资源打开了，但在函数结束的时候却没有关闭。比如：数据库连接……虽然JAVA有垃圾回收机制，但是，自己打开的资源需要自己手动关闭，否则有可能直到程序退出，JRE才会清理你打开的资源。这里FindBugs建议在try/finally里面关闭打开的资源，在关闭之前，还要判断资源是否为Null，或者再加一层异常捕获处理噢～以下是一些可能关闭资源失败的例子———————————————–情况1—————————————–//FileOutputStream fs = null;try{ fs = new FileOutputStream(clearTableFile); fs.close(); //当出异常时候fs关闭失败，所以应该在finally中关闭}catch(){//}———————————————–情况2—————————————–//Properties props = new Properties();try{ props.store(new FileOutputStream(configFile), configFile); //new FileOutputStream(configFile)没有释放。}catch(){ //}———————————————–情况3—————————————– // FileOutputStream fs = new FileOutputStream(clearTableFile); // (里没有做异常处理，如果中间出异常了，异常会抛往上层，这时fs就没能释放了。 fs.close(); // 16.[hyddd的FindBugs分析记录][M M NP] Synchronize and null check on the same field [M M NP] Synchronize and null check on the same field. [NP_SYNC_AND_NULL_CHECK_FIELD]Since the field is synchronized on, it seems not likely to be null. If it is null and then synchronized on aNullPointerException will be thrown and the check would be pointless. Better to synchronize on another field.先看一段代码：public static Timestamp getTableLastUpdateTime(String tableName) { Timestamp time = null; synchronized (GoodsSysConfig.tableLastUpdateTime) { if (GoodsSysConfig.tableLastUpdateTime != null) { //这句判断是多余的，可以去掉！ time = GoodsSysConfig.tableLastUpdateTime.get(tableName); } else { log.error(“GoodsSysConfig.tableLastUpdateTime 为空!”); } } return time;} 这段代码会引发两个BUG警告，一个是：[H C RCN] Nullcheck of value previously dereferenced，另外一个就是这里要介绍的[M M NP] Synchronize and null check on the same field。其实，在[H C RCN] Nullcheck of value previously dereferenced的介绍里面已经提到Synchronize and null check on the same field这个问题了，出现这个BUG的原因是：synchronized (GoodsSysConfig.tableLastUpdateTime) 这里已经对GoodsSysConfig.tableLastUpdateTime这个变量进行了是否为Null的判断，如果为Null，synchronized (…)会抛异常，并且经过synchronized (…)后，GoodsSysConfig.tableLastUpdateTime已经被独占，所以 if (GoodsSysConfig.tableLastUpdateTime != null) 这句可以看作是多余的，因为GoodsSysConfig.tableLastUpdateTime不可能为Null。 17.[hyddd的FindBugs分析记录][M V MS] Public static method may expose internal representation by returning array[M V MS] Public static method may expose internal representation by returning array [MS_EXPOSE_REP]A public static method returns a reference to an array that is part of the static state of the class.Any code that calls this method can freely modify the underlying array. One fix is to return a copy of the array.一个静态的公共函数，它返回了一个私有的静态数组的引用。任何调用这个静态公共函数的代码，都有可能改变这个私有的静态数组。实例代码如下：public static void main(String args[]) throws Exception{ String[] strs = Test.getStrs(); strs[0] = “123”; Test.myTest();}public class Test { private static String[] strs = new String[10]; public static String[] getStr(){ return strs; } public static void myTest(){ System.out.println(strs[0]); }}运行结果是：123防止这种问题的方法是：返回一个数组的拷贝，而不直接返回数组引用。如：public static String[] getStr(){ return strs.clone();}注意：这个BUG和下面这两个BUG比较类似，可以比较一下:&gt;[M V EI2] May expose internal representation by incorporating reference to mutable object[M V EI] May expose internal representation by returning reference to mutable object 18.[hyddd的FindBugs分析记录][M C NP] Possible null pointer dereference[M C NP] Possible null pointer dereference [NP_NULL_ON_SOME_PATH]There is a branch of statement that, if executed, guarantees that a null value will be dereferenced,which would generate a NullPointerException when the code is executed. Of course,the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed;deciding that is beyond the ability of FindBugs.看一段代码：public void test(){ // ResultSet rs = cmd.executeQuery(); if (rs != null &amp;&amp; rs.next()) { goodsId = rs.getInt(“goods_id”); } rs.close(); //rs可能为null //}这里不多解释，更正代码的方法很多，可以用try…catch…finally…处理可能出现的异常，也可以在rs.close之前，先判断rs是否为null。 19.[hyddd的FindBugs分析记录][M B Nm] Method names should start with a lower case letter在Java里，函数的首字母应该小写。而.Net和Java不同，它要求函数的首字母必须大写。这个问题是个规范问题，这里就不提供实例代码了。 20.[hyddd的FindBugs分析记录][M P Dm] Method invokes toString() method on a String[M P Dm] Method invokes toString() method on a String [DM_STRING_TOSTRING]Calling String.toString() is just a redundant operation. Just use the String.对一个String对象使用了toString()方法，这种操作是多余的，完全可以去掉。public static void main(String args[]) throws Exception{ String str = “123”; System.out.println(str.toString());} 21.[hyddd的FindBugs分析记录][M P Bx] Method invokes inefficient Number constructor; use static valueOf instead [M P Bx] Method invokes inefficient Number constructor; use static valueOf instead [DM_NUMBER_CTOR]Using new Integer(int) is guaranteed to always result in a new object whereas Integer.valueOf(int)allows caching of values to be done by the compiler, class library, or JVM.Using of cached values avoids object allocation and the code will be faster.Values between -128 and 127 are guaranteed to have corresponding cached instances and using valueOf isapproximately 3.5 times faster than using constructor. For values outside the constant range the performance of both styles is the same.Unless the class must be compatible with JVMs predating Java 1.5, use either autoboxing or the valueOf() method when creating instances of Long,Integer, Short, Character, and Byte.这里，FindBugs推荐使用Integer.ValueOf(int)代替new Integer(int)，因为这样可以提高性能。如果当你的int值介于-128～127时，Integer.ValueOf(int)的效率比Integer(int)快大约3.5倍。下面看看JDK的源码，看看到Integer.ValueOf(int)里面做了什么优化：public static Integer valueOf(int i) { final int offset = 128; if (i &gt;= -128 &amp;&amp; i &lt;= 127) { // must cache return IntegerCache.cache[i + offset]; } return new Integer(i);}private static class IntegerCache { private IntegerCache(){} static final Integer cache[] = new Integer[-(-128) + 127 + 1]; static { for(int i = 0; i &lt; cache.length; i++) cache = new Integer(i - 128); }}从源代码可以知道，ValueOf对-128～127这256个值做了缓存(IntegerCache)，如果int值的范围是：-128～127，在ValueOf(int)时，他会直接返回IntegerCache的缓存给你。所以你会看到这样的一个现象：public static void main(String []args) { Integer a = 100; Integer b = 100; System.out.println(a==b); Integer c = new Integer(100); Integer d = new Integer(100); System.out.println(c==d);}结果是：truefalse因为：java在编译的时候 Integer a = 100; 被翻译成-&gt; Integer a = Integer.valueOf(100);，所以a和b得到都是一个Cache对象，并且是同一个！而c和d是新创建的两个不同的对象，所以c自然不等于d。再看看这段代码：public static void main(String args[]) throws Exception{ Integer a = 100; Integer b = a; a = a + 1; //或者a++; System.out.println(a==b);}结果是：false因为在对a操作时(a=a+1或者a++)，a重新创建了一个对象，而b对应的还是缓存里的100，所以输出的结果为false。 22.[hyddd的FindBugs分析记录][M C NP] Method call passes null for unconditionally dereferenced parameter[M C NP] Method call passes null for unconditionally dereferenced parameter [NP_NULL_PARAM_DEREF]This method call passes a null value to a method which might dereference it unconditionally.这里FindBugs的解释是：你传入参数的值，有可能是一个NULL。下面看一段代码：public boolean accept(File dir, String name) { String reg = null; if (this.type == ChangeConfigUtil.windowsType) { reg = “^(\\S+)” + ChangeConfigUtil.windowsTypeTag + “\\.(\\S)$”; } else if (this.type == ChangeConfigUtil.linuxType) { reg = “^(\\S+)” + ChangeConfigUtil.linuxTypeTag + “\\.(\\S)$”; } Pattern p = Pattern.compile(reg, Pattern.MULTILINE); //这里reg可能为空 Matcher m = p.matcher(name); if (m.find()) { return true; } else { return false; }}这里Pattern p = Pattern.compile(reg, Pattern.MULTILINE);可能会出现问题。如果this.type既不等于windows，也不等于linux，那么reg=null，这会导致Pattern.compile(reg, Pattern.MULTILINE);抛异常。这里，FindBugs想说明的就是这个问题。 23.[hyddd的FindBugs分析记录][M V EI] May expose internal representation by returning reference to mutable object 这个问题的解决方案和[M V EI2] May expose internal representation by incorporating reference to mutable object很类似， 可以参考：http://www.cnblogs.com/hyddd/articles/1391118.html 24.[hyddd的FindBugs分析记录][M V EI2] May expose internal representation by incorporating reference to mutable object[M V EI2] May expose internal representation by incorporating reference to mutable object [EI_EXPOSE_REP2]This code stores a reference to an externally mutable object into the internal representation of the object. If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties,you will need to do something different. Storing a copy of the object is better approach in many situations.这个问题和Inconsistent synchronization描述的问题很类似，解决方案也很类似，可以参考看看：http://www.cnblogs.com/hyddd/articles/1391098.html先看一段代码：public class Test extends Thread{ public static void main(String args[]) throws Exception{ Test3 obj = new Test3(); Date now = new Date(); obj.setRegDate(now); now.setYear(4000); //问题所在！ System.out.println(obj.getRegDate()); }}public class Test3 { private Date regDate ; public void setRegDate(Date regDate) { this.regDate = regDate; } public Date getRegDate() { return regDate; }}这段代码的输出是：Thu Feb 15 21:47:13 CST 5900如果main里面不加now.setYear(4000);这句代码呢，结果是：Sun Feb 15 21:47:31 CST 2009从这里我们发现了，修改一个对象，可能会引起其他对象的修改，因为JAVA里，对象是引用传递的……所以这里我的建议是：setObj的时候，对象不要直接赋值(this.regDate = regDate)，而是赋值传入对象的拷贝(this.regDate = (Date)regDate.clone();)。OK~现在我们把代码this.regDate = regDate替换成this.regDate = (Date)regDate.clone();，运行一下看看结果，噢，输出是：Sun Feb 15 21:47:31 CST 2009。 25.[hyddd的FindBugs分析记录][M M IS] Inconsistent synchronization[M M IS] Inconsistent synchronization [IS2_INCONSISTENT_SYNC]The fields of this class appear to be accessed inconsistently with respect to synchronization.This bug report indicates that the bug pattern detector judged thatThe class contains a mix of locked and unlocked accesses,At least one locked access was performed by one of the class’s own methods, andThe number of unsynchronized field accesses (reads and writes) was no more than one third of all accesses, with writes being weighed twice as high as readsA typical bug matching this bug pattern is forgetting to synchronize one of the methods in a class that is intended to be thread-safe.You can select the nodes labeled “Unsynchronized access” to show the code locations where the detector believed that afield was accessed without synchronization.Note that there are various sources of inaccuracy in this detector; for example, the detector cannot statically detect all situations in which a lock is held. Also, even when the detector is accurate in distinguishing locked vs. unlocked accesses, the code in question may still be correct.先上一段代码：public class Test extends Thread{ public static void main(String args[]) throws InterruptedException{ ObjectClass obj = new ObjectClass(); Thread t2 = new ChangeValue(obj); t2.start(); Thread t1 = new AlwaysRun(obj); t1.start(); sleep(10000); t1.stop(); }}class AlwaysRun extends Thread{ ObjectClass obj; public AlwaysRun(ObjectClass obj) { // TODO Auto-generated constructor stub this.obj = obj; } public void run() { obj.Loop(); }}class ChangeValue extends Thread{ ObjectClass obj; ChangeValue(ObjectClass obj){ this.obj = obj; } public void run() { System.out.println(\"Thread2\"); ObjClass2 obj2 = obj.getObj(); try { sleep(1500); } catch (InterruptedException e) { System.out.println(\"Error!\"); } obj2.str = \"aaa\"; System.out.println(\"Thread2 Finish!\"); }}public class ObjectClass extends Thread { private ObjClass2 obj; private Object lockTable = new Object(); public ObjectClass() { // TODO Auto-generated constructor stub obj = new ObjClass2(); } public void setObj(ObjClass2 obj){ synchronized (lockTable){ this.obj = obj; } } public ObjClass2 getObj(){ synchronized (lockTable){ return this.obj; //出问题处！！ } } public void Loop(){ synchronized (lockTable){ while(true){ System.out.println(obj.str); } } } }public class ObjClass2 { public String str = “ddddddd”;}看看运行的结果：Thread2dddddddddddddddddddddddddddddddddddddddddddddddddThread2 Finish!aaaaaaaaaaaaaaaaaa…. 如果看明白代码，你应该会知道问题出再哪里了，为什么Loop使用了synchronized (lockTable)，但是obj.str还是被修改了？！因为getObj()这个函数把obj对象返回了给外面，JAVA里面对象的传递是使用引用传递，如果对象传递到外面并且在做修改obj的时候没有加锁操作，就是引起刚才的问题。所以如果getObj()函数返回的是对象，那么，请返回一个拷贝，而不要直接返回引用。这里再总结一下值得注意问题：1.看下面代码： public ObjClass2 getObj(){ synchronized (lockTable){ return this.obj; } }synchronized (lockTable)不能阻止外面的函数修改obj，即：obj=getObj();当赋值完毕后，synchronized (lockTable)无效了，如果后面需要修改obj的值，那么就得注意了！！！另外建议的是，不直接返回this.obj，而是返回一个this.obj的拷贝。这样可以根本上避免出现上面的问题！2.同理，在setObj(…)的时候，如果传入的是个对象，也建议是存储传入对象的拷贝，而不（this.obj=obj）这样直接赋值。3.注意对竞争的资源都使用synchronized (lockTable)，不要像上面的Demo代码那样，一处用了，一处没有！ 26.[hyddd的FindBugs分析记录][M D RCN] Redundant nullcheck of value known to be non-null参考文档：[hyddd的FindBugs分析记录][M C RCN] Nullcheck of value previously dereferenced 27.[hyddd的FindBugs分析记录][M D RCN] Repeated conditional tests[M C RpC] Repeated conditional tests [RpC_REPEATED_CONDITIONAL_TEST]The code contains a conditional test is performed twice, one right after the other (e.g., x == 0 || x == 0).Perhaps the second occurrence is intended to be something else (e.g., x == 0 || y == 0).这个不解释，一看代码就知道： public void test{ String str = “123”; if(str!=null){ if(str!=null){ //重复了 System.out.println(“123”); } } } 28.[hyddd的FindBugs分析记录][M C RCN] Nullcheck of value previously dereferenced[M C RCN] Nullcheck of value previously dereferenced [RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE]A value is checked here to see whether it is null, but this value can’t be null because it was previouslydereferenced and if it were null a null pointer exception would have occurred at the earlier dereference.Essentially,this code and the previous dereference disagree as to whether this value is allowed to be null.Either the check is redundant or the previous dereference is erroneous.先看一段代码：public class MyTest { private String str = “123”; public void setStr(String str){ this.str = str; } public String getStr(){ return this.str; } public void test(){ String str2 = “123”; synchronized (str) { if (str != null) { str2 =”123”; } else { str2 =”456”; } System.out.println(str2); } }}这个时候这段代码就会报Nullcheck of value previously dereferenced这个Bug，看Bug定位，发现问题出现在synchronized (str) 这里，str没有检查是否为NULL?!OK，我现在改用getStr()这个函数代替直接使用str，即：synchronized (getStr())，重新FindBug……居然没有发现错误-_-，但事实上getStr()并没有检查str是否为Null！！ 现在我换另外一种写法，代码如下：public class MyTest { private String str = “123”; public void setStr(String str){ this.str = str; } public String getStr(){ return this.str; } public void test(){ String str2 = \"123\"; if(str != null){ //tag2 synchronized (str) { if (str != null) { //tag1 str2 =\"123\"; } else { str2 =\"456\"; } System.out.println(str2); } } }}这次我在tag2处加了一行检查str是否为NULL的代码，看FindBugs结果，出现了另外一个中等BUG：[M D RCN]Redundant nullcheck of value known to be non-null，跟踪发现是tag1处的代码是多余的，因为tag2处已经检查了一遍，并且在synchronized (str)后，str被独占，它不可能被修改，也就是说synchronized (str)后，根本不需要检查str是否为空，tag1处的代码是多余的。如果把tag1处代码去掉，[M D RCN]警告就没有了。 不知道大家有没有发现，上面的代码还有个问题，看这段代码：if(str != null){ synchronized (str) { System.out.println(“123”); }}如果是多线程运行时，你不能排除它会if(str != null)和synchronized(str)之间进行线程切换，然后把str至为null！所以上面这样写其实也是有可能出现问题的！只是FindBugs没有找出来。我觉得最好的写法还是： public void test() throws Exception{ try{ String str2 = “123”; synchronized (getStr()) { str2 =”456”; System.out.println(str2); } } catch(Exception ex){ throw ex; } //Do other things…. }其实synchronized (getStr()) 换成synchronized (str) 也是可以的，FindBugs不会再报Bug了。总结一下，我觉得FindBugs之所以会报[H C RCN] Nullcheck of value previously dereferenced，是因为我没有检查str的值是否为Null，并且没有注意对可能出现的Exception的截获。而简单使用getStr()，不检查str的值，不作异常捕获，也能躲过这个Bug，我觉得可能是FindBugs的一个BUG:&lt;，因为估计它会认为，getStr()这个函数里面会检查str的值……但这个仅仅是个人认为而已。 29.[hyddd的FindBugs分析记录][H C FS] More arguments are passed that are actually used in the format string[H C FS] More arguments are passed that are actually used in the format string [VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED]A format-string method with a variable number of arguments is called, but more arguments are passed than are actually used by the format string.This won’t cause a runtime exception, but the code may be silently omitting information that was intended to be included in the formatted string.这个错误很简单，是使用String.format的时候出了问题，format里面的参数没有被全部用上。看下面一段代码：public void test(){ String str1 = “123”; String str2 = “456”; String str3 = String.format(“{0} {1}” , str1 ,str2); System.out.println(str3);}输出的结果是：{0} {1}这个Bug描述就是这种问题，str1和str2根本没有被用上！{0}{1}这种Format格式是.NET上面的用法，java里面应该是%s %s。这个是一个代码逻辑问题，可能是你写代码时不小心导致的，它在这段代码里不会导致异常，但往往会很可能导致其他地方异常，那时候你可能会百思不得其解。 A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.修改建议：使用Long.ParseLong，避免自动装箱再拆箱问题原因：Long.ParseLong(String)方法，将 string 参数解析为有符号十进制 ，返回一个long的基本类型值Long.ValueOf(String) ,方法得到的值非常相似。只是最后被转换为一个Long的包装类This class is an inner class, but does not use its embedded reference to the object which created it. This reference makes the instances of the class larger, and may keep the reference to the creator object alive longer than necessary. If possible, the class should be made static.修改建议：若成员类中未访问外围类的非静态成员，为避免额外的空间和时间开销，建议改用静态成员类。问题原因：非静态成员类和静态成员类的区别在于，非静态成员类是对象的，静态成员类是类的。非静态成员类可以访问外围类的任何成员，但前提是必须存在外围类对象。JAVA需要额外维护非静态成员类和外围类对象的关系。This code generates a hashcode and then computes the absolute value of that hashcode. If the hashcode is Integer.MIN_VALUE, then the result will be negative as well (since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE).One out of 2^32 strings have a hashCode of Integer.MIN_VALUE, including “polygenelubricants” “GydZG_” and “”DESIGNING WORKHOUSES”.修改建议：在使用之前判断一下是否是为Integer.MIN_VALUE问题原因：此代码产生哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负的（因为Math.abs（Integer.MIN_VALUE）==Integer.MIN_VALUE）。A boxed value is unboxed and then immediately reboxed.修改建议：三元运算符两个分支的返回类型保持一致。问题原因：装箱的值被拆箱，然后立刻重新装箱This class defines a field with the same name as a visible instance field in a superclass. This is confusing, and may indicate an error if methods update or access one of the fields when they wanted the other.修改建议：要么去掉其中一个字段，要么重新命名。问题原因：变量与超类中的可访问静态变量重名，使用时会造成迷惑 This private method is never called. Although it is possible that the method will be invoked through reflection, it is more likely that the method is never used, and should be removed.修改建议：删除该方法问题原因：这个私有方法没有被调用。虽然可能通过反射的方法将被调用，更可能从未使用过，应该被删除。 This method calls equals(Object) on two references of different class types and analysis suggests they will be to objects of different classes at runtime. Further, examination of the equals methods that would be invoked suggest that either this call will always return false, or else the equals method is not be symmetric (which is a property required by the contract for equals in class Object).修改建议：去除这种无意义的判断问题原因：两个不同类型实例通过equals方法，通常情况下都会判断为非相同对象，其返回值也将始终为false。例如，调用string的equals方法比较double类型，永远都会返回false，如果把这个作为逻辑判断是没有意义的 The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.修改建议：使用StringBuilder/StringBuffer问题原因：在循环里使用字符串连接，效率低A reference value which is null on some exception control path is dereferenced here. This may lead to a NullPointerException when the code is executed. Note that because SpotBugs currently does not prune infeasible exception paths, this may be a false warning.Also note that SpotBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.修改建议：对引用对象进行判空问题原因：代码调用时，遇到异常分支，可能造成一个对象没有获得赋值依旧保持NULL空指针。接下来如果对这个对象有引用，可能造成NullPointerException空指针异常。A String function is being invoked and “.” or “|” is being passed to a parameter that takes a regular expression as an argument. Is this what you intended? For example s.replaceAll(“.”, “/”) will return a String in which every character has been replaced by a ‘/’ character s.split(“.”) always returns a zero length array of String “ab|cd”.replaceAll(“|”, “/”) will return “/a/b/|/c/d/” “ab|cd”.split(“|”) will return array with six (!) elements: [, a, b, |, c, d]修改建议：在前面加上“\\”转义符。问题原因：String的split方法传递的参数是正则表达式，正则表达式本身用到的字符需要转义，如：句点符号“.”，美元符号“$”，乘方符号“^”，大括号“{}”，方括号“[]”，圆括号“()” ，竖线“|”，星号“*”，加号“+”，问号“?”等等，这些需要在前面加上“\\”转义符。There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of SpotBugs.修改建议：判断header是否为null或使用try…catch…finally。问题原因：可能存在空引用This method call passes a null value for a non-null method parameter. Either the parameter is annotated as a parameter that should always be non-null, or analysis has shown that it will always be dereferenced.修改建议：赋予函数参数默认值。问题原因：传递了一个空值给函数参数The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,String dateString = getHeaderField(name);dateString.trim();the programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:String dateString = getHeaderField(name);dateString = dateString.trim();修改建议：定义变量接收方法的返回值问题原因：忽略了该方法的返回值This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.修改建议：遍历entry（桶）然后直接从entry得到value问题原因：很多人都这样遍历Map，没错，但是效率很低，先一个一个的把key遍历，然后在根据key去查找value，这不是多此一举么，为什么不遍历entry（桶）然后直接从entry得到value呢？它们的执行效率大概为1.5:1This code creates an exception (or error) object, but doesn’t do anything with it. For example, something like if (x &lt; 0) { new IllegalArgumentException(“x must be nonnegative”);}It was probably the intent of the programmer to throw the created exception: if (x &lt; 0) { throw new IllegalArgumentException(“x must be nonnegative”);} 修改建议：将创建的异常抛出问题原因：创建了一个异常对象，但是没有对它做任何操作 Using the java.lang.String(String) constructor wastes memory because the object so constructed will be functionally indistinguishable from the String passed as a parameter. Just use the argument String directly.修改建议：直接使用其参数问题原因：这里调用了String的构造函数来新建一个字符串，浪费内存 This code contains a sequence of calls to a concurrent abstraction (such as a concurrent hash map). These calls will not be executed atomically.修改建议：使用putIfAbsent()保证操作是原子级的问题原因：在多线程访问的情况下，它是不安全的 A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous修改建议：在使用变量之前先判断其是否为null问题原因：出现该bug有两种情况，多余的null检查或者没有进行null值检查。 As the JavaDoc states, DateFormats are inherently unsafe for multithreaded use. The detector has found a call to an instance of DateFormat that has been obtained via a static field. This looks suspicious.修改建议：使用ThreadLocal: 每个线程都将拥有自己的SimpleDateFormat对象副本。问题原因：SimpleDateFormat不是线程安全的———————————————— -============================================================================================================ FindBugs Bug Descriptions (推荐)http://findbugs.sourceforge.net/bugDescriptions.html#NP_NULL_PARAM_DEREF document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"findbugs","slug":"findbugs","permalink":"http://www.zhoudamin.com/tags/findbugs/"}]},{"title":"刷题总结","slug":"刷题总结","date":"2020-05-03T08:57:23.000Z","updated":"2020-05-03T09:19:11.612Z","comments":true,"path":"2020/05/03/shua-ti-zong-jie/","link":"","permalink":"http://www.zhoudamin.com/2020/05/03/shua-ti-zong-jie/","excerpt":"刷题总结","text":"刷题总结 递归 递归就是将大问题转化为小问题，然后推敲出递推公式，再思考出终止条件，将递推公式和终止条件输出为代码的过程。 二分查找 三个注意点 循环退出条件 终止条件是 low &lt;=high，而不是 low&lt; high mid的取值 mid计算公式避免溢出，最好是 mid = low + (high - low )/2 low和high的更新 是 low = mid + 1 ,high = mid -1 。而不是 low = mid ，high = mid ，会死循环。 二分查找条件 数组 有序 数据量太小不适合，可以用遍历，效率差不多 数据量太大也不适合，比如1G，二分查找依赖连续数组，数组存储在内存。要求计算机提供1G的连续内存空间要求比较高，可能无法申请到。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.zhoudamin.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"最长回文子串","slug":"最长回文子串","date":"2020-05-02T09:15:08.000Z","updated":"2020-05-02T09:20:51.796Z","comments":true,"path":"2020/05/02/zui-chang-hui-wen-zi-chuan/","link":"","permalink":"http://www.zhoudamin.com/2020/05/02/zui-chang-hui-wen-zi-chuan/","excerpt":"给定一个字符串 s，找到 s 中最长的回文子串。你可以假设&nbsp;s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" Related Topics字符串动态规划","text":"给定一个字符串 s，找到 s 中最长的回文子串。你可以假设&nbsp;s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" Related Topics字符串动态规划 中心法，找出 aba 和 abba 这两种情况的即可，然后每次判断是不是最长的。 class Solution { public String longestPalindrome(String s) { if (null == s || s.equals(\"\")) { return \"\"; } int maxLen = 0; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) { int len1 = palindromicStr(s, i, i); int len2 = palindromicStr(s, i, i + 1); maxLen = Math.max(len1, len2); if (maxLen > end - start) { start = i - (maxLen - 1) / 2; end = i + maxLen / 2; } } return s.substring(start, end + 1); } public int palindromicStr(String str, int left, int right) { int L = left, R = right; char[] arr = str.toCharArray(); while (L >= 0 &amp;&amp; R &lt; str.length() &amp;&amp; arr[L] == arr[R]) { L--; R++; } return R - L - 1; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"交换数字","slug":"交换数字","date":"2020-05-02T02:31:06.000Z","updated":"2020-05-02T02:33:12.288Z","comments":true,"path":"2020/05/02/jiao-huan-shu-zi/","link":"","permalink":"http://www.zhoudamin.com/2020/05/02/jiao-huan-shu-zi/","excerpt":"编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。 示例： 输入: numbers = [1,2] 输出: [2,1] 提示： numbers.length == 2 Related Topics位运算数学","text":"编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。 示例： 输入: numbers = [1,2] 输出: [2,1] 提示： numbers.length == 2 Related Topics位运算数学 交换数字即可 class Solution { public int[] swapNumbers(int[] numbers) { numbers[1] ^= numbers[0]; numbers[0] ^= numbers[1]; numbers[1] ^= numbers[0]; return numbers; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"统计作战单位数","slug":"统计作战单位数","date":"2020-05-01T09:01:53.000Z","updated":"2020-05-01T09:10:47.654Z","comments":true,"path":"2020/05/01/tong-ji-zuo-zhan-dan-wei-shu/","link":"","permalink":"http://www.zhoudamin.com/2020/05/01/tong-ji-zuo-zhan-dan-wei-shu/","excerpt":"&nbsp;n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。 每 3 个士兵可以组成一个作战单位，分组规则如下： 从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k] 作战单位需满足： rating[i] &lt; rating[j] &lt; rating[k] 或者 rating[i] &gt; rating[j] &gt; rating[k] ，其中&nbsp; 0&nbsp;&lt;= i &lt;&nbsp;j &lt;&nbsp;k &lt;&nbsp;n 请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。 &nbsp; 示例 1： 输入：rating = [2,5,3,4,1] 输出：3 解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。 示例 2： 输入：rating = [2,1,3] 输出：0 解释：根据题目条件，我们无法组建作战单位。 示例 3： 输入：rating = [1,2,3,4] 输出：4 &nbsp; 提示： n == rating.length 1 &lt;= n &lt;= 200 1 &lt;= rating[i] &lt;= 10^5 Related Topics数组","text":"&nbsp;n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。 每 3 个士兵可以组成一个作战单位，分组规则如下： 从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k] 作战单位需满足： rating[i] &lt; rating[j] &lt; rating[k] 或者 rating[i] &gt; rating[j] &gt; rating[k] ，其中&nbsp; 0&nbsp;&lt;= i &lt;&nbsp;j &lt;&nbsp;k &lt;&nbsp;n 请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。 &nbsp; 示例 1： 输入：rating = [2,5,3,4,1] 输出：3 解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。 示例 2： 输入：rating = [2,1,3] 输出：0 解释：根据题目条件，我们无法组建作战单位。 示例 3： 输入：rating = [1,2,3,4] 输出：4 &nbsp; 提示： n == rating.length 1 &lt;= n &lt;= 200 1 &lt;= rating[i] &lt;= 10^5 Related Topics数组 三个数大小，翻转数组 class Solution { public int numTeams(int[] rating) { int rst = 0; if (rating.length &lt; 3) { return 0; } rst += countRating(rating); for (int i = 0; i &lt; rating.length / 2; i++) { // 交换元素 int temp = rating[rating.length - i - 1]; rating[rating.length - i - 1] = rating[i]; rating[i] = temp; } rst += countRating(rating); return rst; } public int countRating(int[] arr) { int result = 0; for (int i = 0; i &lt; arr.length - 2; i++) { for (int j = i + 1; j &lt; arr.length - 1; j++) { for (int k = j + 1; k &lt; arr.length; k++) { if (arr[i] &lt; arr[j] &amp;&amp; arr[j] &lt; arr[k]) { result++; } } } } return result; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"求1+2+…+n","slug":"求1-2-…-n","date":"2020-05-01T04:01:25.000Z","updated":"2020-05-01T04:04:00.077Z","comments":true,"path":"2020/05/01/qiu-1-2-n/","link":"","permalink":"http://www.zhoudamin.com/2020/05/01/qiu-1-2-n/","excerpt":"求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 &nbsp; 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 &nbsp; 限制： 1 &lt;= n&nbsp;&lt;= 10000","text":"求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 &nbsp; 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 &nbsp; 限制： 1 &lt;= n&nbsp;&lt;= 10000 递归循环 class Solution { int res = 0; public int sumNums(int n) { boolean x = n > 1 &amp;&amp; sumNums(n - 1) > 0; res += n; return res; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"删除链表的倒数第N个节点","slug":"删除链表的倒数第N个节点","date":"2020-04-26T14:46:26.000Z","updated":"2020-04-26T14:53:14.606Z","comments":true,"path":"2020/04/26/shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/","link":"","permalink":"http://www.zhoudamin.com/2020/04/26/shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/","excerpt":"给定一个链表，删除链表的倒数第&nbsp;n&nbsp;个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n&nbsp;保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ Related Topics链表双指针","text":"给定一个链表，删除链表的倒数第&nbsp;n&nbsp;个节点，并且返回链表的头结点。 示例： 给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明： 给定的 n&nbsp;保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ Related Topics链表双指针 双指针，new一个新的头结点，返回的时候要返回次节点 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode pre = new ListNode(0); pre.next = head; ListNode first = pre ; ListNode last = pre ; for (int i=0;i&lt;n;i++){ last = last.next; } while (last.next!=null){ first = first.next; last = last.next; } first.next=first.next.next; return pre.next; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"[面试题56 - I]数组中数字出现的次数","slug":"-面试题56-I-数组中数字出现的次数","date":"2020-04-25T09:08:12.000Z","updated":"2020-04-26T14:49:59.293Z","comments":true,"path":"2020/04/25/mian-shi-ti-56-i-shu-zu-zhong-shu-zi-chu-xian-de-ci-shu/","link":"","permalink":"http://www.zhoudamin.com/2020/04/25/mian-shi-ti-56-i-shu-zu-zhong-shu-zi-chu-xian-de-ci-shu/","excerpt":"一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 &nbsp; 示例 1： 输入：nums = [4,1,4,6] 输出：[1,6] 或 [6,1] 示例 2： 输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] &nbsp; 限制： 2 &lt;= nums &lt;= 10000 &nbsp;","text":"一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 &nbsp; 示例 1： 输入：nums = [4,1,4,6] 输出：[1,6] 或 [6,1] 示例 2： 输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] &nbsp; 限制： 2 &lt;= nums &lt;= 10000 &nbsp; 用一个list去装数组，遍历过程中，如果元素已经存在，就去除（remove有去除object和index两种方式，要注意下），最后剩下的就是我们求的。 class Solution { public int[] singleNumbers(int[] nums) { List list = new ArrayList(nums.length); for (int i = 0; i &lt; nums.length; i++) { if (list.contains(nums[i])) { list.remove((Object) nums[i]); } else { list.add(nums[i]); } } int[] rst = new int[2]; for (int i = 0; i &lt; rst.length; i++) { rst[i] = (int) list.get(i); } return rst; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"Pow(x, n)","slug":"Pow-x-n","date":"2020-04-25T03:26:31.000Z","updated":"2020-04-25T08:36:03.489Z","comments":true,"path":"2020/04/25/pow-x-n/","link":"","permalink":"http://www.zhoudamin.com/2020/04/25/pow-x-n/","excerpt":"实现&nbsp;pow(x, n)&nbsp;，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10输出: 1024.00000 示例&nbsp;2: 输入: 2.10000, 3输出: 9.26100 示例&nbsp;3: 输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt;&nbsp;x&nbsp;&lt; 100.0 n&nbsp;是 32 位有符号整数，其数值范围是&nbsp;[−231,&nbsp;231&nbsp;− 1] 。 Related Topics数学二分查找","text":"实现&nbsp;pow(x, n)&nbsp;，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10输出: 1024.00000 示例&nbsp;2: 输入: 2.10000, 3输出: 9.26100 示例&nbsp;3: 输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt;&nbsp;x&nbsp;&lt; 100.0 n&nbsp;是 32 位有符号整数，其数值范围是&nbsp;[−231,&nbsp;231&nbsp;− 1] 。 Related Topics数学二分查找 思路： 暴力会超时 不long 一个N 无法解决越边的问题 class Solution { private double fastPow(double x, long n) { if (n == 0) { return 1.0; } double half = myPow(x, (int) (n / 2)); if (n % 2 == 0) { return half * half; } else { return half * half * x; } } public double myPow(double x, int n) { long N = n; if (N &lt; 0) { x = 1 / x; N = -N; } return fastPow(x, N); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"搜索二维矩阵","slug":"搜索二维矩阵","date":"2020-04-20T16:49:29.000Z","updated":"2020-04-25T09:19:48.859Z","comments":true,"path":"2020/04/21/sou-suo-er-wei-ju-zhen/","link":"","permalink":"http://www.zhoudamin.com/2020/04/21/sou-suo-er-wei-ju-zhen/","excerpt":"编写一个高效的算法来判断&nbsp;m x n&nbsp;矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例&nbsp;1: 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 示例&nbsp;2: 输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false Related Topics数组二分查找","text":"编写一个高效的算法来判断&nbsp;m x n&nbsp;矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例&nbsp;1: 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 示例&nbsp;2: 输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false Related Topics数组二分查找 先算全长，再除2，然后/% class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length; if (m== 0) { return false; } int n =matrix[0].length; int right = 0; int left = m*n-1; int indexNum; int index ; while (right&lt;=left){ index =(right+left)/2; indexNum =matrix[index/n][index%n]; if (indexNum ==target){ return true; }else if(indexNum>target){ left=index-1; }else { right = index+1; } } return false; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"三数之和","slug":"三数之和","date":"2020-04-19T09:53:06.000Z","updated":"2020-04-25T08:45:13.289Z","comments":true,"path":"2020/04/19/san-shu-zhi-he/","link":"","permalink":"http://www.zhoudamin.com/2020/04/19/san-shu-zhi-he/","excerpt":"给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 &nbsp; 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] Related Topics数组双指针","text":"给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 &nbsp; 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] Related Topics数组双指针 先排序，然后定点，双指针搜索。另外去重。 class Solution { public List&lt;List&lt;Integer>> threeSum(int[] nums) { Arrays.sort(nums); List&lt;List&lt;Integer>> rstList = new ArrayList&lt;List&lt;Integer>>(); for (int i = 0; i &lt; nums.length - 2; i++) { if (nums[i] > 0) { break; } if (i > 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } int first = i + 1; int end = nums.length - 1; while (first &lt; end) { int temp = nums[i] + nums[first] + nums[end]; if (temp > 0) { end--; } else if (temp &lt; 0) { first++; } else { List&lt;Integer> list = new ArrayList&lt;>(); list.add(nums[i]); list.add(nums[first]); list.add(nums[end]); rstList.add(list); first++; end--; while (first &lt; end &amp;&amp; nums[first] == nums[first - 1]) { first++; } while (first &lt; end &amp;&amp; nums[end] == nums[end + 1]) { end--; } } } } return rstList; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"}]},{"title":"Apollo核心概念","slug":"Apollo核心概念","date":"2019-10-13T04:03:55.000Z","updated":"2019-10-13T04:09:45.876Z","comments":true,"path":"2019/10/13/apollo-he-xin-gai-nian/","link":"","permalink":"http://www.zhoudamin.com/2019/10/13/apollo-he-xin-gai-nian/","excerpt":"携程框架Apollo概念介绍","text":"携程框架Apollo概念介绍 核心功能统一管理不同环境、不同集群的配置配置修改实时生效（热发布）版本发布管理 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"http://www.zhoudamin.com/tags/Apollo/"}]},{"title":"ValidParentheses","slug":"ValidParentheses","date":"2019-09-22T08:25:18.000Z","updated":"2019-09-22T08:29:47.399Z","comments":true,"path":"2019/09/22/validparentheses/","link":"","permalink":"http://www.zhoudamin.com/2019/09/22/validparentheses/","excerpt":"给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。","text":"给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 解题思路：1.用堆栈的数据结构处理括号的入栈与对比2.用map存储键值对，来进行入栈与对比判断 import java.util.HashMap; import java.util.Map; import java.util.Stack; /** * 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 * * 有效字符串需满足： * * 左括号必须用相同类型的右括号闭合。 * 左括号必须以正确的顺序闭合。 * 注意空字符串可被认为是有效字符串。 */ public class ValidParentheses { public static void main (String [] args){ String str = \"()[]{}\"; System.out.println(checkValid(str)); } public static boolean checkValid (String str){ Stack&lt;Character> stk = new Stack&lt;>(); Map&lt;Character,Character> map = new HashMap() ; map.put(')','('); map.put(']','['); map.put('}','{'); for(int i= 0;i&lt;str.length();i++){ if(map.containsValue(str.charAt(i))){ stk.push(str.charAt(i)); }else { if(stk.peek().equals(map.get(str.charAt(i)))){ stk.pop(); }else { return false; } } } return stk.size()==0; } } 2019.9.22晴天百草园 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"MissingRange","slug":"MissingRange","date":"2019-09-08T09:39:20.000Z","updated":"2019-09-08T09:44:20.941Z","comments":true,"path":"2019/09/08/missingrange/","link":"","permalink":"http://www.zhoudamin.com/2019/09/08/missingrange/","excerpt":"Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges. For example, given [0, 1, 3, 50, 75] return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”]","text":"Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges. For example, given [0, 1, 3, 50, 75] return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”] package com.zdm.demo; import java.util.ArrayList; import java.util.List; /** * Given a sorted integer array where the range of elements are [0, 99] inclusive, return its * missing ranges. * For example, given [0, 1, 3, 50, 75], return [“2”, “4->49”, “51->74”, “76->99”] */ public class MissingRange { public static void main(String[] args) { int[] arr = new int[]{0, 1, 3, 50, 75}; int low = 0; int up = 99; List&lt;String> rst = findMissingRange(arr, low, up); System.out.print(rst.toString()); } private static List findMissingRange(int[] num, int low, int up) { // 定义返回值 List rst = new ArrayList&lt;>(); //处理异常 if (num == null || num.length == 0) { rst.add(low + \"->\" + up); return rst; } //do business //处理首 doAdd(rst, low, num[0]); //处理中间 int i = 1; int pre = num[0]; while (i &lt; num.length) { int cur = num[i]; if (cur != pre + 1) { doAdd(rst, pre, cur); } i++; pre = cur; } //处理尾巴 doAdd(rst, num[num.length - 1], up + 1); return rst; } private static List doAdd(List rst, int low, int up) { //拼接 if (low &lt; up &amp;&amp; (low + 1) &lt; up) { if ((up - low) == 2) { rst.add((low + 1)); } else { rst.add((low + 1) + \"->\" + (up - 1)); } } return rst; } } 时间：2019年9月8日地点：百草园天气：雷雨心情：平静… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java知识增强","slug":"Java知识增强","date":"2019-08-07T12:39:12.000Z","updated":"2019-08-07T12:47:25.856Z","comments":true,"path":"2019/08/07/java-zhi-shi-zeng-qiang/","link":"","permalink":"http://www.zhoudamin.com/2019/08/07/java-zhi-shi-zeng-qiang/","excerpt":"每日一考！","text":"每日一考！ 倒排索引 讲讲redis里面的哈希表？ happen-before的规则？ volatile修饰符，synchronize锁 java单例模式的实现，懒汉、饿汉？ 进程与线程的区别，多进程和多线程的区别？ HashMap原理，为什么用红黑树，红黑树的特点？ 快排时间空间复杂度，最好最坏的情况，优化方案？ TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决？ 讲讲了解的垃圾回收算法和回收器，什么时候执行STOP THE WORLD？ 讲一下最大堆和最小堆 LRU算法实现（伪代码） 链表倒数第K个数（讲思路） 一堆螺丝和螺母用最短时间匹配（代码实现） 求每天浏览页面的新用户（Hive QL实现） 求抖音小视频每日点击量最高的10个（Hash + 最小堆） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"第一次NZJ","slug":"第一次NZJ","date":"2019-05-13T15:45:04.000Z","updated":"2019-07-28T02:20:42.833Z","comments":true,"path":"2019/05/13/di-yi-ci-nzj/","link":"","permalink":"http://www.zhoudamin.com/2019/05/13/di-yi-ci-nzj/","excerpt":"入我厂第一次沟，以后还需更加努力。","text":"入我厂第一次沟，以后还需更加努力。 .23333 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://www.zhoudamin.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://www.zhoudamin.com/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"Java知识点锦集","slug":"Java知识点锦集","date":"2019-04-13T09:33:55.000Z","updated":"2019-04-13T10:21:42.906Z","comments":true,"path":"2019/04/13/java-zhi-shi-dian-jin-ji/","link":"","permalink":"http://www.zhoudamin.com/2019/04/13/java-zhi-shi-dian-jin-ji/","excerpt":"知识锦集","text":"知识锦集 hashMap原理，java8做的改变从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。ConcurrentHashMap线程安全。解决碰撞：当出现冲突时，运用拉链法，将关键词为同义词的结点链接在一个单链表中，散列表长m，则定义一个由m个头指针组成的指针数组T，地址为i的结点插入以T(i)为头指针的单链表中。Java8中，冲突的元素超过限制（8），用红黑树替换链表。 String 和 StringBuilder 的区别1）可变与不可变：String不可变，每一次执行“+”都会新生成一个新对象，所以频繁改变字符串的情况中不用String，以节省内存。2）是否多线程安全：StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。StringBuffer和String均线程安全。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"随想","slug":"随想","date":"2019-04-10T14:21:54.000Z","updated":"2019-04-10T15:06:22.105Z","comments":true,"path":"2019/04/10/sui-xiang/","link":"","permalink":"http://www.zhoudamin.com/2019/04/10/sui-xiang/","excerpt":"又到了一年一度域名续费的日子了","text":"又到了一年一度域名续费的日子了 加入我厂也有大半年了，从一开始忙到飞起，体验做不完的活，每次想起这个就想到陈老师给形容的：工作就像打仗一样。入我厂从一名Test做起，慢慢才开始做起开发，最近还搞起了设计，学到了Linux，sh，sql，angular，这些之前都很少接触，入我司半年，也算是小有所得。记得刚来的时候，住的特别挫，居然租了一个10楼无电梯的小房子，OMG，想起去年脚扭伤了，泽林和华哥送我上楼，然后好几天都没下来过，不是不想下来看医生，是根本下不来…2333，确实没必要租这么挫的房子，后面在要排到百草园的前夕，实在是受不了，拔草了后面一栋的三楼一个房子，光线不错，不过下水系统设计的很随意，又排起了百草园的队。。。2333都是泪。从去年年底开始看房子，到现在还没定好房子，发现钱在这个大件面前，真的好不值钱，想买的买不起，买的起的太郊区了，浪费钱。 博客好久没写了，还是好好学习吧，域名就不续了，除了自己访问一下，貌似也没啥用！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://www.zhoudamin.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://www.zhoudamin.com/tags/%E9%9A%8F%E6%83%B3/"}]},{"title":"人人懂AI","slug":"人人懂AI","date":"2019-03-03T12:57:38.000Z","updated":"2019-03-03T14:10:43.795Z","comments":true,"path":"2019/03/03/ren-ren-dong-ai/","link":"","permalink":"http://www.zhoudamin.com/2019/03/03/ren-ren-dong-ai/","excerpt":"人人懂AI入门学习！","text":"人人懂AI入门学习！ 神经网络M-P Model多参数，多权重学习模型 单层感知器：输入就输出的 多层感知器深度网络的前身。输入层–隐含层–输出层 Back Propagetion Algorithm前向计算输出，比较期望输出，得到误差，然后反向调整权项值，逼近阈值。 可以做车牌识别， 局限性：训练过程，局部最小，不是全局最小，收敛不了。和初始点选择有关，和全局下降速率有关。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://www.zhoudamin.com/tags/AI/"}]},{"title":"shell脚本学习与演练","slug":"shell脚本学习与演练","date":"2018-10-14T08:30:10.000Z","updated":"2019-01-12T14:53:58.080Z","comments":true,"path":"2018/10/14/shell-jiao-ben-xue-xi-yu-yan-lian/","link":"","permalink":"http://www.zhoudamin.com/2018/10/14/shell-jiao-ben-xue-xi-yu-yan-lian/","excerpt":"平时经常接触Linux的操作指导，是不是可以写个脚本一键式解决这些繁琐的操作呢？ok","text":"平时经常接触Linux的操作指导，是不是可以写个脚本一键式解决这些繁琐的操作呢？ok 写一个简单脚本vi test1.sh ······························test1.sh #! /bin/bash echo \"Hello !\" ······························ chmod +x ./test1.sh ./test1.sh shell 变量your_name=\"zzz\" echo $your_name your_name=\"cccc\" echo $your_name 字符串里写变量your_name='aaa' str=\"Hello, you are \\\"$your_name\\\"!\" echo $str 数组array_name=(value0 value1 value2 value3) # or array_name=( value0 value1 value2 value3 ) # 单个 valuen=${array_name[n]} # 所有元素 echo ${array_name[@]} 运算#!/bin/bash # 不是单引号 是斜引号 val=`expr 4 + 2` echo \"and : $val\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.zhoudamin.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.zhoudamin.com/tags/Linux/"}]},{"title":"Java之广度优先搜索算法","slug":"Java之广度优先搜索算法","date":"2018-08-12T14:35:39.000Z","updated":"2018-08-12T15:01:33.696Z","comments":true,"path":"2018/08/12/java-zhi-guang-du-you-xian-sou-suo-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2018/08/12/java-zhi-guang-du-you-xian-sou-suo-suan-fa/","excerpt":"BFS，全称是Breadth First Search。 简单说就是图搜索算法。","text":"BFS，全称是Breadth First Search。 简单说就是图搜索算法。 Word LadderGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence frombeginWord to endWord, such that: Only one letter can be changed at a timeEach intermediate word must exist in the word listFor example, Given:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”] As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,return its length 5. Note: Return 0 if there is no such transformation sequence.All words have the same length.All words contain only lowercase alphabetic characters. 简单来说就是从一个单词出发，每次只改变一个字母，直到变到最后一个单词，求最短路径。 再简单点思考就是 hit—&gt;hot—&gt;lot/dot—&gt;log/dog—&gt;cog 思路就是用两个set,一个存老的单词，如果添加进路径，就删除；一个存路径。 循环终止条件是路径匹配到尾巴的目标单词； 关键代码 public int ladderLen(String beginWord ,String endWord ,List&lt;String> wordList){ Set&lt;String> wordSet = new HashSet&lt;>(wordList); Set&lt;String> visited = new HashSet&lt;>; visited.add(beginWord); int len=1; //开始计算路径与清楚单词集合里的单词 //算法终止条件 while(!visited.contains(endWord)){ Set&lt;String> temp = new HashSet&lt;>(); for(String word:visited){ for(int i=0;i&lt;word.length;i++){ char[] chars=word.toCharArray(); for(int j=(int)'a';j&lt;(int)'z'+1;j++){ chars[i]=(char)j; String newWord=new String(chars); if(wordSet.contains(newWord)){ temp.add(newWord); wordSet.remove(newWord); } } } } len += 1; if(temp.size()==0){ return 0; } vistied=temp; } return len; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java之排序算法","slug":"Java之排序算法","date":"2018-08-06T15:52:53.000Z","updated":"2018-08-06T16:24:12.834Z","comments":true,"path":"2018/08/06/java-zhi-pai-xu-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2018/08/06/java-zhi-pai-xu-suan-fa/","excerpt":"排序，各种排序~","text":"排序，各种排序~ 桶排序First Missing PositiveGiven an unsorted integer array, find the first missing positive integer. For example, given [1,2,0] return 3 and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 分析：本质上是桶排序，每当A[i]!=i+1时，A[i]与A[A[i]-1]交换，终止条件是A[i]==A[A[i]-1]. public int firstMissingPositive(int [] nums){ bucket_sort(nums); for(int i=0;i&lt;nums.length;++i){ if(nums[i]!=(i+1)){ return i+1; } return nums.length+1; } private static void bucket_sort(int [] A){ final int n=A.length; for(int i=0;i&lt;n :i++){ while(A[i]!=i+1){ if(A[i]&lt;1 || A[i]>n || A[i]==A[A[i]-1]) break; int temp = A[i]; A[i]=A[temp-1]; A[temp-1]=temp; } } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java之二叉树算法","slug":"Java之二叉树算法","date":"2018-08-05T15:04:25.000Z","updated":"2018-08-05T15:14:02.125Z","comments":true,"path":"2018/08/05/java-zhi-er-cha-shu-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2018/08/05/java-zhi-er-cha-shu-suan-fa/","excerpt":"二叉树算法","text":"二叉树算法 二叉查找树Validate Binary Search Tree 验证二叉搜索树Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than the node’s key.Both the left and right subtrees must also be binary search trees. 思路，用递归，左&lt;根&lt;右 &amp;&amp; 左根递归 &amp;&amp; 右根递归关键代码 public boolean isValidBST(TreeNode root){ return isValidBST(root,INT_MIN,INT_MAX); } bool isValidBST (TreeNode* root,int lower ,int upper ){ if(root == nullptr) return true; return root.val>lower &amp;&amp; root.val&lt;upper &amp;&amp; isValidBST(root.left,lower,root.val) &amp;&amp; isValidBST(root.right,root.val,upper); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java之数组算法","slug":"Java之数组算法","date":"2018-07-26T15:28:19.000Z","updated":"2018-07-29T03:14:09.336Z","comments":true,"path":"2018/07/26/java-zhi-shu-zu-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2018/07/26/java-zhi-shu-zu-suan-fa/","excerpt":"数组是常见的算法题，所以多做题，多总结，总是能找到idea的。","text":"数组是常见的算法题，所以多做题，多总结，总是能找到idea的。 Product of Array Except SelfGiven an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up:Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 思路：首先，介绍方法： [1,a1,a12,a123].*[a234,a34,a4,1]=[a234,a134,a124,a123]这个算法有个O(1)的思路:就是用常数的方法，从左边乘到右边，再取一个常数，从右边乘到左边 //关键算法段 left[0]=1; for(int i=1;i&lt;num.length;++i){ left[i]=left[i-1]*num[i-1]; } int right=1; for(int i=num.length-1;i>=0;i--){ left[i]*=right; //right 初始为1，每次乘完再迭代 right*=num[i]; } return left; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Essence","slug":"Essence","date":"2018-07-24T14:54:44.000Z","updated":"2018-08-15T15:06:33.913Z","comments":true,"path":"2018/07/24/essence/","link":"","permalink":"http://www.zhoudamin.com/2018/07/24/essence/","excerpt":"生活珠玑~","text":"生活珠玑~ 尽量结合兴趣，选准方向，不要动摇，深入研究。 和牛人共事，和善良的人交友。 从此刻起，加上思考，梳理手头的todolist，把最重要的工作找出来，全身心突出亮点。 不问别人为什么，多问自己凭什么！ —by 2018/8/9 健康 不要熬夜，尽量少熬夜 锻炼身体 不抽烟，少饮酒 注意日常行为姿势 多吃健康食品，少吃外卖 不要用眼过度，注意眼睛的休息 注重心理健康 定期体检 生活 建造强大的内心 尽早有理财念头 多出去走走 平和的心态面对一切 喜欢的东西要攒钱买下来 不要以为自己吃不胖 心本善，但是要有提防人的心 社交 增加自身的价值(有效社交) 不要盲目社交 注重对方的需求，不要一味索取 要多和人进行高质量的交流 不要勉强自己合群 分清自己的社交关系深浅 去掉一切不必要的应酬和饭局 不要急切的表达自己的观点，多听少说 人生 尽早做好人生规划(短期、长期) 建立正确的三观(学习、思考、实践) 趁年轻抓紧努力 要有自己的核心竞争力 别因为懒惰放弃能抓住的机会和挑战 要真正了解自己 别怕犯错和失败 不要自作聪明，恃才傲物 承担责任(社会、工作、家庭、自己的选择) 不要怕事，但别主动惹事 尽早进入社会历练 找到正确的平台比能力更重要 学会拒绝 不要轻易跳槽，但每次都要更上一个台阶 工作尽可能积累资源 要忠于自己，再忠于工作和公司 适当的妥协不丢人 要有长远的眼光，不要总是盯着眼前的利益 学习 勤学勤思考 多读书，广读书，读好书 迷茫的时候就学习 要有自己的专精 少刷手机 操作系统、网络、算法数据结构、离散数学、数据库原理与实践，这些看起来枯燥而无味的基础科学，要了解它们是必须付出非常多的时间才有可能理解通透些。而这些基础的扎实程度，就直接决定了你的高度。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://www.zhoudamin.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"观点与感想","slug":"观点与感想","permalink":"http://www.zhoudamin.com/tags/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"}]},{"title":"《Hadoop权威指南》 Notes","slug":"《Hadoop权威指南》-Notes","date":"2018-07-08T04:55:24.000Z","updated":"2019-05-12T15:21:17.488Z","comments":true,"path":"2018/07/08/hadoop-quan-wei-zhi-nan-notes/","link":"","permalink":"http://www.zhoudamin.com/2018/07/08/hadoop-quan-wei-zhi-nan-notes/","excerpt":"业余读书笔记1","text":"业余读书笔记1 初识HadoopHadoop项目简述 Common 一组分布式文件系统和通用I/O的组件与接口(序列化、Java RPC 和持久化数据结构)。 Avro 一种支持高效、跨语言的RPC以及永久存储数据的序列化系统。 MapReduce 分布式数据处理模型和执行环境，运行于大型商用机集群。 HDFS 分布式文件系统，运行于大型商用机集群。 Pig 一种数据流语言和运行环境，用以检索非常大的数据集。Pig运行在MapReduce和HDFS的集群上。 Hive 一个分布式、按列存储的数据仓库。Hive管理HDFS中存储的数据，并提供基于SQL的查询语言以查询数据。 HBase 一个分布式、按列存储数据库。 ZooKeeper 一个分布式、可用性高的协调服务。 Sqoop 在数据库和HDFS之间高效传输数据的工具。 关于MapReduce数据处理方法 将输入数据分成固定大小的块，然后把每块分配到各个进程，这样一来，即使有些进程能处理更多数据，我们也可以为他们分配更多的数据。 对每块数据进行处理，取每块中的最大值，作为每块的最高标准。 多台机器如何处理协调性和可靠性的问题。 查找最高气温的方法论 Hadoop自身提供一套可优化网络序列化传输的基本类型，在org.apache.hadoop.io包中。 map()方法的输入时一个键和一个值，首先将包含有一行输入的text值转换成java的String类型，之后使用subString()方法提取感兴趣的列。 map()方法还提供了OutputCollector实例用于输出内容的写入，在这种情况下，将年份按照Text对象进行读写，将气温值封装在IntWritable类型中。 测试气温数据是否缺失or显示为正确的气温读数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.zhoudamin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://www.zhoudamin.com/tags/Notes/"}]},{"title":"Java并发编程实战","slug":"Java并发编程实战","date":"2018-06-16T02:54:24.000Z","updated":"2018-06-16T03:17:54.472Z","comments":true,"path":"2018/06/16/java-bing-fa-bian-cheng-shi-zhan/","link":"","permalink":"http://www.zhoudamin.com/2018/06/16/java-bing-fa-bian-cheng-shi-zhan/","excerpt":"基于《Java并发编程实战》，作者Brain等。","text":"基于《Java并发编程实战》，作者Brain等。 任务执行顺序执行SingleThreadWebServer顺序处理他的任务：接收到达80端口的HTTP请求 class SingleThreadWebServer{ public static void main(String [] args)throws IOException{ ServerSocket socket = new ServerSocket(80); while(true){ Socket connection = socket.accept(); handleRequest(connection); } } } 无限创建线程的缺点 线程生命周期的开销 资源消耗量、尤其是内存 稳定性差 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"},{"name":"编程语言","slug":"开发者手册/编程语言","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.zhoudamin.com/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Java实现彩色二维码","slug":"Java实现彩色二维码","date":"2018-05-02T11:30:05.000Z","updated":"2018-05-02T11:35:35.945Z","comments":true,"path":"2018/05/02/java-shi-xian-cai-se-er-wei-ma/","link":"","permalink":"http://www.zhoudamin.com/2018/05/02/java-shi-xian-cai-se-er-wei-ma/","excerpt":"使用Zxing库实现彩色二维码的生成，代码如下：","text":"使用Zxing库实现彩色二维码的生成，代码如下： package com; import com.google.zxing.BarcodeFormat; import com.google.zxing.EncodeHintType; import com.google.zxing.MultiFormatWriter; import com.google.zxing.client.j2se.MatrixToImageWriter; import com.google.zxing.common.BitMatrix; import com.google.zxing.qrcode.QRCodeWriter; import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel; import com.google.zxing.qrcode.encoder.Encoder; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.Hashtable; import java.util.Map; import java.util.Random; public class TexturedEncoderHandler { /** * 编码 * @param contents * @param width * @param height * @param imgPath */ public void encode(String contents, int width, int height, ErrorCorrectionLevel level, String imgPath) { Hashtable&lt;EncodeHintType, Object> hints = new Hashtable&lt;EncodeHintType, Object>(); // 指定纠错等级 hints.put(EncodeHintType.ERROR_CORRECTION, level); // 指定编码格式 hints.put(EncodeHintType.CHARACTER_SET, \"GBK\"); try { int [][] bitMatrix = new QRCodeWriter().encode(contents, BarcodeFormat.QR_CODE, width, height, hints); int len=bitMatrix.length; width=len*12; boolean [][]matrixBoo=new boolean[width][width]; MyPic(bitMatrix,matrixBoo,imgPath); } catch (Exception e) { e.printStackTrace(); } } public void MyPic(int [][] bitmatrix,boolean [][] matrixboo,String pathname) throws IOException { BufferedImage matrix = new BufferedImage(matrixboo.length , matrixboo[0].length, BufferedImage.TYPE_INT_ARGB); Random rand = new Random(); for(int i=0;i&lt;bitmatrix.length;i++){ for(int j=0;j&lt;bitmatrix[0].length;j++){ if(bitmatrix[i][j]==1){ int rr= rand.nextInt(255); int gg= rand.nextInt(255); int bb= rand.nextInt(255); Color color = new Color(rr, gg, bb); int colorInt = color.getRGB(); for(int n=i*12;n&lt;(i+1)*12;n++){ for(int m=j*12;m&lt;(j+1)*12;m++) { matrixboo[n][m] = true; matrix.setRGB(n, m, colorInt ); } } } } } ImageIO.write(matrix, \"PNG\", new File(pathname)); } /** * @param args */ public static void main(String[] args) { long startTime=System.currentTimeMillis(); String imgPath = \"guangzhou.jpg\"; String contents = \"guangzhou\"; int width = 300, height = 300; ErrorCorrectionLevel level=ErrorCorrectionLevel.L; TexturedEncoderHandler handler = new TexturedEncoderHandler(); handler.encode(contents, width, height, level, imgPath); long endTime=System.currentTimeMillis(); //获取结束时间 System.out.println(\"程序运行时间： \"+(endTime-startTime)+\"ms\"); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java 二维码","slug":"Java-二维码","permalink":"http://www.zhoudamin.com/tags/Java-%E4%BA%8C%E7%BB%B4%E7%A0%81/"}]},{"title":"HTTP基础","slug":"HTTP基础","date":"2018-04-25T10:18:20.000Z","updated":"2018-04-25T10:19:08.999Z","comments":true,"path":"2018/04/25/http-ji-chu/","link":"","permalink":"http://www.zhoudamin.com/2018/04/25/http-ji-chu/","excerpt":"","text":"服务器意图 GET：获取资源，用来请求已经被URI识别的资源 POST：传输实体主体 PUT：传输文件 HEAD：获得报文首部 DELETE：删除文件 OPTIONS：询问支持的方法 状态码 类别 原因短语 1XX Informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection (重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"理解计算机","slug":"理解计算机","permalink":"http://www.zhoudamin.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.zhoudamin.com/tags/HTTP/"}]},{"title":"云计算基础","slug":"云计算基础","date":"2018-04-25T10:13:17.000Z","updated":"2018-04-25T10:14:35.004Z","comments":true,"path":"2018/04/25/yun-ji-suan-ji-chu/","link":"","permalink":"http://www.zhoudamin.com/2018/04/25/yun-ji-suan-ji-chu/","excerpt":"","text":"云计算分类 IaaS 基础设施即服务 PaaS 平台即服务 SaaS 软件即服务 公有云公有云构建在互联网上，任何已付费的用户都可以访问。 私有云私有云构建在局域网内部，属于一个独立的组织。 混合云混合云由公有云和私有云共同构成 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"云计算","slug":"云计算","permalink":"http://www.zhoudamin.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"http://www.zhoudamin.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"Hexo Notes","slug":"Hexo Notes","date":"2018-04-23T15:07:42.000Z","updated":"2018-04-23T15:15:14.704Z","comments":true,"path":"2018/04/23/hexo-notes/","link":"","permalink":"http://www.zhoudamin.com/2018/04/23/hexo-notes/","excerpt":"遇到的小问题","text":"遇到的小问题 关于设置页宽没错，这就是我上面提到的那个主题，这个主题有三种外观，其中我现在使用的是 Pisces Scheme ，但还是做了一些修改，因为原来那个宽度太小了，不适合展示代码块，也不太美观。修改方法如下：Pisces 的布局定义在 source/css/_schemes/Picses/_layout.styl 中，打开文件并在最后添加以下 css引用自 http://www.aidansu.com/2017/github-pages-build-blog/ .header{ width: 80%; +tablet() { width: 100%; } +mobile() { width: 100%; } } .container .main-inner { width: 80%; +tablet() { width: 100%; } +mobile() { width: 100%; } } .content-wrap { width: calc(100% - 260px); +tablet() { width: 100%; } +mobile() { width: 100%; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Notes","slug":"Notes","permalink":"http://www.zhoudamin.com/categories/Notes/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zhoudamin.com/tags/Hexo/"}]},{"title":"Java 运动模糊","slug":"Java-运动模糊","date":"2018-04-23T12:41:58.000Z","updated":"2018-04-23T14:32:38.495Z","comments":true,"path":"2018/04/23/java-yun-dong-mo-hu/","link":"","permalink":"http://www.zhoudamin.com/2018/04/23/java-yun-dong-mo-hu/","excerpt":"想用Java 写个运动模糊的效果，无奈本人水平有限，国内也没找到资源，于是Google到了一个文档，特地分享出来！","text":"想用Java 写个运动模糊的效果，无奈本人水平有限，国内也没找到资源，于是Google到了一个文档，特地分享出来！ 本代码源自 http://www.jhlabs.com/ip/blurring.html Java运动模糊算法： import java.awt.*; import java.awt.geom.*; import java.awt.image.*; public class MotionBlurOp extends AbstractBufferedImageOp { private float centreX = 0.5f, centreY = 0.5f; private float distance=20.0f; //这里设置运动距离 private float angle; private float rotation; private float zoom; public MotionBlurOp() { } public MotionBlurOp( float distance, float angle, float rotation, float zoom ) { this.distance = distance; this.angle = angle; this.rotation = rotation; this.zoom = zoom; } public void setAngle( float angle ) { this.angle = angle; } public float getAngle() { return angle; } public void setDistance( float distance ) { this.distance = distance; } public float getDistance() { return distance; } public void setRotation( float rotation ) { this.rotation = rotation; } public float getRotation() { return rotation; } public void setZoom( float zoom ) { this.zoom = zoom; } public float getZoom() { return zoom; } public void setCentreX( float centreX ) { this.centreX = centreX; } public float getCentreX() { return centreX; } public void setCentreY( float centreY ) { this.centreY = centreY; } public float getCentreY() { return centreY; } public void setCentre( Point2D centre ) { this.centreX = (float)centre.getX(); this.centreY = (float)centre.getY(); } public Point2D getCentre() { return new Point2D.Float( centreX, centreY ); } private int log2( int n ) { int m = 1; int log2n = 0; while (m &lt; n) { m *= 2; log2n++; } return log2n; } public BufferedImage filter( BufferedImage src, BufferedImage dst ) { if ( dst == null ) dst = createCompatibleDestImage( src, null ); BufferedImage tsrc = src; float cx = (float)src.getWidth() * centreX; float cy = (float)src.getHeight() * centreY; float imageRadius = (float)Math.sqrt( cx*cx + cy*cy ); float translateX = (float)(distance * Math.cos( angle )); float translateY = (float)(distance * -Math.sin( angle )); float scale = zoom; float rotate = rotation; float maxDistance = distance + Math.abs(rotation*imageRadius) + zoom*imageRadius; int steps = log2((int)maxDistance); translateX /= maxDistance; translateY /= maxDistance; scale /= maxDistance; rotate /= maxDistance; if ( steps == 0 ) { Graphics2D g = dst.createGraphics(); g.drawRenderedImage( src, null ); g.dispose(); return dst; } BufferedImage tmp = createCompatibleDestImage( src, null ); for ( int i = 0; i &lt; steps; i++ ) { Graphics2D g = tmp.createGraphics(); g.drawImage( tsrc, null, null ); g.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON ); g.setRenderingHint( RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR ); g.setComposite( AlphaComposite.getInstance( AlphaComposite.SRC_OVER, 0.5f ) ); g.translate( cx+translateX, cy+translateY ); g.scale( 1.0001+scale, 1.0001+scale ); // The .0001 works round a bug on Windows where drawImage throws an ArrayIndexOutofBoundException if ( rotation != 0 ) g.rotate( rotate ); g.translate( -cx, -cy ); g.drawImage( dst, null, null ); g.dispose(); BufferedImage ti = dst; dst = tmp; tmp = ti; tsrc = dst; translateX *= 2; translateY *= 2; scale *= 2; rotate *= 2; } return dst; } public String toString() { return \"Blur/Motion Blur...\"; } }测试代码： import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; /** * Created by zdmein on 2018/1/10. */ public class MotionBlurOpTest { public static void main(String [] args) throws IOException { BufferedImage sourceImage = ImageIO.read(new File(\"flower.jpg\")); MotionBlurOp filter=new MotionBlurOp(); BufferedImage destImage=filter.filter(sourceImage,null); ImageIO.write(destImage, \"PNG\", new File(\"MotionBlurOpflower.jpg\")); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"图像","slug":"图像","permalink":"http://www.zhoudamin.com/categories/%E5%9B%BE%E5%83%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"优秀博主整理","slug":"优秀博主整理","date":"2017-09-12T01:59:40.000Z","updated":"2018-04-23T15:50:59.749Z","comments":true,"path":"2017/09/12/you-xiu-bo-zhu-zheng-li/","link":"","permalink":"http://www.zhoudamin.com/2017/09/12/you-xiu-bo-zhu-zheng-li/","excerpt":"优秀博主整理","text":"优秀博主整理 Name Introduction 纯洁的微笑 资深码农博主，对Spring框架的总结非常不错，现在在一家互联网金融公司做技术经理兼技术负责人 Raysmond 复旦的计算机研究生，现在在北京工作，生活很精彩，工程能力也非常强，看到他在与我同龄时写的一些代码，非常佩服 Yikun 西电毕业的通信领域研究生，去年好像去了菊厂，手绘很棒，生活也很精彩，也是个技术牛人 酷壳 耗子叔，业内知名博主，每一篇博文都是经典，15年开发经验的老码农，曾在Amazon，阿里等处做过资深专家 王之琳 12年本科毕业前端交互工程师，能力很强，简历很炫，写的项目非常多，也特别喜欢逛各种论坛 litten 毕业于华科的前端工程师，非常文青，我这个博客主题就是他写的，现在鹅厂工作 Oilbeater 北大毕业的研究生，曾在阿里任职，现在灵雀云搞Docker，挺有想法的人 羡辙 毕业于上交的研究生，现在是一个非常出色的前端工程师，目前在百度ECharts团队做可视化的相关工作。博客非常有特点，博文质量很高，而且GITHUB的Follower高达4k DIYgod 15年毕业的前端工程师，非常二次元，博客也很另类，个人能力也是很强的，喜欢玩GITHUB很棒，也是掘金的联合小编 龙哥盟 16年毕业于上交，项目经验很丰富，而且非常喜欢搞各种教程，GITHUB的Follower也很多 闵聪 17年毕业于重邮，项目和实习经验都很丰富，现在似乎去了鹅厂 byvoid 牛x的大佬，搞NOIP进的清华，能力超强，奇闻逸事网上流传了很多，最有名的大概就是报阿里星时候的评价表。。。 谢益辉 在美帝工作的经济学PhD,双语博客从05年更到现在，文笔也牛的不行，现在在RStudio做软件工程师 MartinRGB 13年西电毕业的交互设计师以及GUI设计师，看了眼博客，没啥说的，不愧是设计师。。。 魏楚阳 18年毕业的华科研究生，webporter的开发者，爬虫和数据分析的高端玩家，BAT随便进。。。 VoidKing 16级东北师大的软件工程硕士研究生，是个很勤奋的博主，有梦想有想法。 颜开 对Java以及分布式数据库等有着非常深厚的积淀，现在任职于EMC，可惜的是博客不怎么更了 李钊 东北大学14级同届本科，能力很强，现在百度深度学习实验室。 马壮 努力高产的全栈工程师 孔令贤 11年硕士毕业，前华为 OpenStack 社区开发部技术经理，从14级破格提拔至17级，任总在总裁令中点名致歉的员工，在技术和管理的岔路口迷茫过，博客中也记录了职场中很多心路历程。现在已技术移民新西兰 余舜哲 同龄的同学，现在在多伦多大学留学，对新技术有很大的热情，很不错的博客 aneasystone 80后码农一枚。喜欢开源，喜欢读书，喜欢折腾，方向是偏信息安全的，目前应该转了java Zhisheng Tian 同一届的同学，学习的能力跟写作的条理都非常清楚，基础功很扎实，也是非常值得学习 翟永超 《Spring Cloud 微服务实战》一书作者，对Spring全家桶和微服务架构有着很深刻的理解 赵伊凡 比较喜欢总结知识的90后码农，好像写了本书叫《轻松学算法》 小草窝 很小就开始写代码的博主，自己写的emlog框架，比较喜欢搞网站安全 王爵 blade框架的作者，维护了很多开源项目，用blade写的Tale博客框架也挺不错的 并发编程网 阿里系的一帮大牛创的技术网站 aidan 雄哥的博客 云风的 BLOG 总是读成风云… 阮一峰的网络日志 非常佩服的一位，非常勤，特别能坚持 老赵 赵百万的博客 闵聪 腾讯的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Life","slug":"Life","permalink":"http://www.zhoudamin.com/categories/Life/"}],"tags":[{"name":"博主","slug":"博主","permalink":"http://www.zhoudamin.com/tags/%E5%8D%9A%E4%B8%BB/"}]},{"title":"常用数据结构底层实现及源码","slug":"常用数据结构底层实现及源码","date":"2017-09-12T01:59:40.000Z","updated":"2018-04-23T02:27:20.062Z","comments":true,"path":"2017/09/12/chang-yong-shu-ju-jie-gou-di-ceng-shi-xian-ji-yuan-ma/","link":"","permalink":"http://www.zhoudamin.com/2017/09/12/chang-yong-shu-ju-jie-gou-di-ceng-shi-xian-ji-yuan-ma/","excerpt":"ZDM–ArrayList、HashMap、Collection、LinkedList、Redis 底层实现及源码","text":"ZDM–ArrayList、HashMap、Collection、LinkedList、Redis 底层实现及源码 RedisRedis简介Redis是一种key/value型数据库，其中，每个key和value都是使用对象表示的。 SET message \"Hello\" 其中，字符串 “message” 这个对象 就是 key ， “Hello” 这个对象 就是 value Redis有5种对象的类型 类型常量 小写 对象名称 REDIS_STRING string 字符串对象 REDIS_LIST list 列表对象 REDIS_HASH hash 哈希对象 REDIS_SET set 集合对象 REDIS_ZSET zset 有序集合对象 Redis对象底层数据结构 编码常量 数据结构 int long类型的整数 embstr embstr编码的简单动态字符串 raw 简单动态字符串 ht 字典 linkedlist 双端链表 ziplist 压缩列表 intset 整数集合 skiplist 跳跃表和字典 字符串对象字符串对象的编码可以是int、raw、embstr 如果字符串对象的长度小于39字节，就用embstr 否则用传统的raw对象 # define REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39 robj *createStringObject(char *ptr, size_t len) { if (len &lt;= REDIS_ENCODING_EMBSTR_SIZE_LIMIT) return createEmbeddedStringObject(ptr,len); else return createRawStringObject(ptr,len); } embstr的优点： 创建只需分配一次内存，raw为两次 释放内存也是一次 embstr的objet和sds放在一起，更好地利用缓存带来的优势 列表对象列表对象的编码可以是 ziplist or LinkedList ziplist 是一种压缩链表，好处是更能节省内存空间，存储的内容都是在连续的内存区域中的 LinkedList是一种双向链表，没增加一个node，都要重新分配一个内存 哈希对象哈希对象的底层实现用ziplist or hashtable ziplist : 对象数目不多且内容不大，这种方式效率很高 HashTable由dict这个结构实现 集合对象集合对象编码可以是 intset or HashTable 有序集合对象编码一种是 ziplist ，一种是skipList 与 dict 的结合 ziplist作为集合和作为哈希对象是一样的，member和score顺序存放。按照score从小到大顺序排列。它的结构不再复述。 skiplist是一种跳跃表，它实现了有序集合中的快速查找，在大多数情况下它的速度都可以和平衡树差不多。但它的实现比较简单，可以作为平衡树的替代品。 ArrayListArrayList是基于数组实现的，是一个动态数组，其容量能自动增长(1.5+1)。 非线程安全 源码： package java.util; public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable { // 序列版本号 private static final long serialVersionUID = 8683452581122892189L; // ArrayList基于该数组实现，用该数组保存数据 private transient Object[] elementData; // ArrayList中实际数据的数量 private int size; // ArrayList带容量大小的构造函数。 public ArrayList(int initialCapacity) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); // 新建一个数组 this.elementData = new Object[initialCapacity]; } // ArrayList无参构造函数。默认容量是10。 public ArrayList() { this(10); } // 创建一个包含collection的ArrayList public ArrayList(Collection&lt;? extends E> c) { elementData = c.toArray(); size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } // 将当前容量值设为实际元素个数 public void trimToSize() { modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) { elementData = Arrays.copyOf(elementData, size); } } // 确定ArrarList的容量。 // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1” public void ensureCapacity(int minCapacity) { // 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity > oldCapacity) { Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; //如果还不够，则直接将minCapacity设置为当前容量 if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); } } // 添加元素e public boolean add(E e) { // 确定ArrayList的容量大小 ensureCapacity(size + 1); // Increments modCount!! // 添加e到ArrayList中 elementData[size++] = e; return true; } // 返回ArrayList的实际大小 public int size() { return size; } // ArrayList是否包含Object(o) public boolean contains(Object o) { return indexOf(o) >= 0; } //返回ArrayList是否为空 public boolean isEmpty() { return size == 0; } // 正向查找，返回元素的索引值 public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1; } // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值 public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i >= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i >= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } // 返回ArrayList的Object数组 public Object[] toArray() { return Arrays.copyOf(elementData, size); } // 返回ArrayList元素组成的数组 public &lt;T> T[] toArray(T[] a) { // 若数组a的大小 &lt; ArrayList的元素个数； // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中 if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 若数组a的大小 >= ArrayList的元素个数； // 则将ArrayList的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, size); if (a.length > size) a[size] = null; return a; } // 获取index位置的元素值 public E get(int index) { RangeCheck(index); return (E) elementData[index]; } // 设置index位置的值为element public E set(int index, E element) { RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; } // 将e添加到ArrayList中 public boolean add(E e) { ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; } // 将e添加到ArrayList的指定位置 public void add(int index, E element) { if (index > size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } // 删除ArrayList指定位置的元素 public E remove(int index) { RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; } // 删除ArrayList的指定元素 public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 快速删除第index个元素 private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; // 从\"index+1\"开始，用后面的元素替换前面的元素。 if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设为null elementData[--size] = null; // Let gc do its work } // 删除元素 public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { // 便利ArrayList，找到“元素o”，则删除，并返回true。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 清空ArrayList，将全部的元素设为null public void clear() { modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; } // 将集合c追加到ArrayList中 public boolean addAll(Collection&lt;? extends E> c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } // 从index位置开始，将集合c添加到ArrayList public boolean addAll(int index, Collection&lt;? extends E> c) { if (index > size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \" + index + \", Size: \" + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved > 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } // 删除fromIndex到toIndex之间的全部元素。 protected void removeRange(int fromIndex, int toIndex) { modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newSize = size - (toIndex-fromIndex); while (size != newSize) elementData[--size] = null; } private void RangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException( \"Index: \"+index+\", Size: \"+size); } // 克隆函数 public Object clone() { try { ArrayList&lt;E> v = (ArrayList&lt;E>) super.clone(); // 将当前ArrayList的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // this shouldn't happen, since we are Cloneable throw new InternalError(); } } // java.io.Serializable的写入函数 // 将ArrayList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // 写入“数组的容量” s.writeInt(elementData.length); // 写入“数组的每一个元素” for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } // java.io.Serializable的读取函数：根据写入方式读出 // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // 从输入流中读取ArrayList的“容量” int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength]; // 从输入流中将“所有的元素值”读出 for (int i=0; i&lt;size; i++) a[i] = s.readObject(); } } HashMapHashMap是基于哈希表实现，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足时，会自动增长。 非线程安全，只是用于单线程环境下，多线程用concurrentHashMap 实现了Serializable接口，因此支持序列化，实现了Cloneable接口，能被克隆。 源码： package java.util; import java.io.*; public class HashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable { // 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子为0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的底层数组中已用槽的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //加载因此不能小于0 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); } // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 默认构造函数。 public HashMap() { // 设置“加载因子”为默认加载因子0.75 this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); } // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V> m) { this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); } //求hash值的方法，重新计算hash值 static int hash(int h) { h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } // 返回h在数组中的索引值，这里用&amp;代替取模，旨在提升效率 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) { return h &amp; (length-1); } public int size() { return size; } public boolean isEmpty() { return size == 0; } // 获取key对应的value public V get(Object key) { if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; //判断key是否相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; } //没找到则返回null return null; } // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！ private V getForNullKey() { for (Entry&lt;K,V> e = table[0]; e != null; e = e.next) { if (e.key == null) return e.value; } return null; } // HashMap是否包含key public boolean containsKey(Object key) { return getEntry(key) != null; } // 返回“键为key”的键值对 final Entry&lt;K,V> getEntry(Object key) { // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } return null; } // 将“key-value”添加到HashMap中 public V put(K key, V value) { // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V> e = table[i]; e != null; e = e.next) { Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; //将key-value添加到table[i]处 addEntry(hash, key, value, i); return null; } // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) { for (Entry&lt;K,V> e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 如果没有存在key为null的键值对，则直接题阿见到table[0]处! modCount++; addEntry(0, null, value, 0); return null; } // 创建HashMap对应的“添加方法”， // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap // 而put()是对外提供的往HashMap中添加元素的方法。 private void putForCreate(K key, V value) { int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值 for (Entry&lt;K,V> e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { e.value = value; return; } } // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中 createEntry(hash, key, value, i); } // 将“m”中的全部元素都添加到HashMap中。 // 该方法被内部的构造HashMap的方法所调用。 private void putAllForCreate(Map&lt;? extends K, ? extends V> m) { // 利用迭代器将元素逐个添加到HashMap中 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;? extends K, ? extends V> e = i.next(); putForCreate(e.getKey(), e.getValue()); } } // 重新调整HashMap的大小，newCapacity是调整后的容量 void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; //如果就容量已经达到了最大值，则不能再扩容，直接返回 if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); } // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) { Entry&lt;K,V> e = src[j]; if (e != null) { src[j] = null; do { Entry&lt;K,V> next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); } } } // 将\"m\"的全部元素都添加到HashMap中 public void putAll(Map&lt;? extends K, ? extends V> m) { // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前阀值容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded > threshold) { int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity > MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity > table.length) resize(newCapacity); } // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;? extends K, ? extends V> e = i.next(); put(e.getKey(), e.getValue()); } } // 删除“键为key”元素 public V remove(Object key) { Entry&lt;K,V> e = removeEntryForKey(key); return (e == null ? null : e.value); } // 删除“键为key”的元素 final Entry&lt;K,V> removeEntryForKey(Object key) { // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V> prev = table[i]; Entry&lt;K,V> e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V> next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; } prev = e; e = next; } return e; } // 删除“键值对” final Entry&lt;K,V> removeMapping(Object o) { if (!(o instanceof Map.Entry)) return null; Map.Entry&lt;K,V> entry = (Map.Entry&lt;K,V>) o; Object key = entry.getKey(); int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V> prev = table[i]; Entry&lt;K,V> e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) { Entry&lt;K,V> next = e.next; if (e.hash == hash &amp;&amp; e.equals(entry)) { modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; } prev = e; e = next; } return e; } // 清空HashMap，将所有的元素设为null public void clear() { modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; } // 是否包含“值为value”的元素 public boolean containsValue(Object value) { // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; } // 是否包含null值 private boolean containsNullValue() { Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; } // 克隆一个HashMap，并返回Object对象 public Object clone() { HashMap&lt;K,V> result = null; try { result = (HashMap&lt;K,V>)super.clone(); } catch (CloneNotSupportedException e) { // assert false; } result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; } // Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V> implements Map.Entry&lt;K,V> { final K key; V value; // 指向下一个节点 Entry&lt;K,V> next; final int hash; // 构造函数。 // 输入参数包括\"哈希值(h)\", \"键(k)\", \"值(v)\", \"下一节点(n)\" Entry(int h, K k, V v, Entry&lt;K,V> n) { value = v; next = n; key = k; hash = h; } public final K getKey() { return key; } public final V getValue() { return value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) { Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; } return false; } // 实现hashCode() public final int hashCode() { return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); } public final String toString() { return getKey() + \"=\" + getValue(); } // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V> m) { } // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V> m) { } } // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V> e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V>(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ >= threshold) resize(2 * table.length); } // 创建Entry。将“key-value”插入指定位置。 void createEntry(int hash, K key, V value, int bucketIndex) { // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V> e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V>(hash, key, value, e); size++; } // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E> implements Iterator&lt;E> { // 下一个元素 Entry&lt;K,V> next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V> current; HashIterator() { expectedModCount = modCount; if (size > 0) { // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } } public final boolean hasNext() { return next != null; } // 获取下一个元素 final Entry&lt;K,V> nextEntry() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V> e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) { Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; } current = e; return e; } // 删除当前元素 public void remove() { if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; } } // value的迭代器 private final class ValueIterator extends HashIterator&lt;V> { public V next() { return nextEntry().value; } } // key的迭代器 private final class KeyIterator extends HashIterator&lt;K> { public K next() { return nextEntry().getKey(); } } // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V>> { public Map.Entry&lt;K,V> next() { return nextEntry(); } } // 返回一个“key迭代器” Iterator&lt;K> newKeyIterator() { return new KeyIterator(); } // 返回一个“value迭代器” Iterator&lt;V> newValueIterator() { return new ValueIterator(); } // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V>> newEntryIterator() { return new EntryIterator(); } // HashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V>> entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K> keySet() { Set&lt;K> ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); } // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private final class KeySet extends AbstractSet&lt;K> { public Iterator&lt;K> iterator() { return newKeyIterator(); } public int size() { return size; } public boolean contains(Object o) { return containsKey(o); } public boolean remove(Object o) { return HashMap.this.removeEntryForKey(o) != null; } public void clear() { HashMap.this.clear(); } } // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V> values() { Collection&lt;V> vs = values; return (vs != null ? vs : (values = new Values())); } // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private final class Values extends AbstractCollection&lt;V> { public Iterator&lt;V> iterator() { return newValueIterator(); } public int size() { return size; } public boolean contains(Object o) { return containsValue(o); } public void clear() { HashMap.this.clear(); } } // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V>> entrySet() { return entrySet0(); } // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V>> entrySet0() { Set&lt;Map.Entry&lt;K,V>> es = entrySet; return es != null ? es : (entrySet = new EntrySet()); } // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V>> { public Iterator&lt;Map.Entry&lt;K,V>> iterator() { return newEntryIterator(); } public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V> e = (Map.Entry&lt;K,V>) o; Entry&lt;K,V> candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); } public boolean remove(Object o) { return removeMapping(o) != null; } public int size() { return size; } public void clear() { HashMap.this.clear(); } } // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException { Iterator&lt;Map.Entry&lt;K,V>> i = (size > 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) { while (i.hasNext()) { Map.Entry&lt;K,V> e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } } } private static final long serialVersionUID = 362498820763181265L; // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) { K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); } } // 返回“HashMap总的容量” int capacity() { return table.length; } // 返回“HashMap的加载因子” float loadFactor() { return loadFactor; } } HashTable基于哈希表实现，每个元素都是key-value对，内部通过单链表解决冲突问题，容量不足时，自动增长 是线程安全的，能用于多线程 实现了Serializable接口，支持序列号 实现了Cloneable接口，能被克隆 package java.util; import java.io.*; public class Hashtable extends Dictionary implements Map, Cloneable, java.io.Serializable { // 保存key-value的数组。 // Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表 private transient Entry[] table; // Hashtable中键值对的数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数，用于fail-fast机制的实现 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); if (loadFactor >> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } } else { return k.hashCode(); } } public synchronized int size() { return count; } public synchronized boolean isEmpty() { return count == 0; } // 返回“所有key”的枚举对象 public synchronized Enumeration keys() { return this.getEnumeration(KEYS); } // 返回“所有value”的枚举对象 public synchronized Enumeration elements() { return this.getEnumeration(VALUES); } // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) { //注意，Hashtable中的value不能是null， // 若是null的话，抛出异常! if (value == null) { throw new NullPointerException(); } // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- > 0 ;) { for (Entry e = tab[i] ; e != null ; e = e.next) { if (e.value.equals(value)) { return true; } } } return false; } public boolean containsValue(Object value) { return contains(value); } // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) { Entry tab[] = table; //计算hash值，直接用key的hashCode代替 int hash = key.hashCode(); // 计算在数组中的索引值 int index = (hash & 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { return true; } } return false; } // 返回key对应的value，没有的话返回null public synchronized V get(Object key) { Entry tab[] = table; int hash = hash(key); // 计算索引值， int index = (hash & 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { return e.value; } } return null; } // 调整Hashtable的长度，将长度变成原来的2倍+1 protected void rehash() { int oldCapacity = table.length; Entry[] oldMap = table; //创建新容量大小的Entry数组 int newCapacity = oldCapacity * 2 + 1; Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)(newCapacity * loadFactor); table = newMap; //将“旧的Hashtable”中的元素复制到“新的Hashtable”中 for (int i = oldCapacity ; i-- > 0 ;) { for (Entry old = oldMap[i] ; old != null ; ) { Entry e = old; old = old.next; //重新计算index int index = (e.hash & 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; } } } // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) { // Hashtable中不能插入value为null的元素！！！ if (value == null) { throw new NullPointerException(); } // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = hash(key); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { V old = e.value; e.value = value; return old; } } // 若“Hashtable中不存在键为key的键值对”， // 将“修改统计数”+1 modCount++; // 若“Hashtable实际容量” > “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count >= threshold) { rehash(); tab = table; index = (hash & 0x7FFFFFFF) % tab.length; } //将新的key-value对插入到tab[index]处（即链表的头结点） Entry e = tab[index]; tab[index] = new Entry(hash, key, value, e); count++; return null; } // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) { Entry tab[] = table; int hash = hash(key); int index = (hash & 0x7FFFFFFF) % tab.length; //从table[index]链表中找出要删除的节点，并删除该节点。 //因为是单链表，因此要保留带删节点的前一个节点，才能有效地删除节点 for (Entry e = tab[index], prev = null ; e != null ; prev = e, e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { modCount++; if (prev != null) { prev.next = e.next; } else { tab[index] = e.next; } count--; V oldValue = e.value; e.value = null; return oldValue; } } return null; } // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map t) { for (Map.Entry e : t.entrySet()) put(e.getKey(), e.getValue()); } // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() { Entry tab[] = table; modCount++; for (int index = tab.length; --index >= 0; ) tab[index] = null; count = 0; } // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() { try { Hashtable t = (Hashtable) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- > 0 ; ) { t.table[i] = (table[i] != null) ? (Entry) table[i].clone() : null; } t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; } catch (CloneNotSupportedException e) { throw new InternalError(); } } public synchronized String toString() { int max = size() - 1; if (max == -1) return \"{}\"; StringBuilder sb = new StringBuilder(); Iterator it = entrySet().iterator(); sb.append('{'); for (int i = 0; ; i++) { Map.Entry e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? \"(this Map)\" : key.toString()); sb.append('='); sb.append(value == this ? \"(this Map)\" : value.toString()); if (i == max) return sb.append('}').toString(); sb.append(\", \"); } } // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。 private Enumeration getEnumeration(int type) { if (count == 0) { return (Enumeration)emptyEnumerator; } else { return new Enumerator(type, false); } } // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private Iterator getIterator(int type) { if (count == 0) { return (Iterator) emptyIterator; } else { return new Enumerator(type, true); } } // Hashtable的“key的集合”。它是一个Set，没有重复元素 private transient volatile Set keySet = null; // Hashtable的“key-value的集合”。它是一个Set，没有重复元素 private transient volatile Set entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素 private transient volatile Collection values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set keySet() { if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; } // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet { public Iterator iterator() { return getIterator(KEYS); } public int size() { return count; } public boolean contains(Object o) { return containsKey(o); } public boolean remove(Object o) { return Hashtable.this.remove(o) != null; } public void clear() { Hashtable.this.clear(); } } // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set entrySet() { if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; } // Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet { public Iterator iterator() { return getIterator(ENTRIES); } public boolean add(Map.Entry o) { return super.add(o); } // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash && e.equals(entry)) return true; return false; } // 删除元素Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，删除链表中的元素Object public boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry) o; K key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next) { if (e.hash==hash && e.equals(entry)) { modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; } } return false; } public int size() { return count; } public void clear() { Hashtable.this.clear(); } } // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection values() { if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; } // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection { public Iterator iterator() { return getIterator(VALUES); } public int size() { return count; } public boolean contains(Object o) { return containsValue(o); } public void clear() { Hashtable.this.clear(); } } // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map t = (Map) o; if (t.size() != size()) return false; try { // 通过迭代器依次取出当前Hashtable的key-value键值对 // 并判断该键值对，存在于Hashtable中。 // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。 Iterator i = entrySet().iterator(); while (i.hasNext()) { Map.Entry e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(t.get(key)==null && t.containsKey(key))) return false; } else { if (!value.equals(t.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } // 计算Entry的hashCode // 若 Hashtable的实际大小为0 或者 加载因子 0 && length > origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements > 0; elements--) { K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); } this.table = table; } private void reconstitutionPut(Entry[] tab, K key, V value) throws StreamCorruptedException { if (value == null) { throw new java.io.StreamCorruptedException(); } // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) && e.key.equals(key)) { throw new java.io.StreamCorruptedException(); } } // Creates the new entry. Entry e = tab[index]; tab[index] = new Entry(hash, key, value, e); count++; } // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry implements Map.Entry { // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry next; // 构造函数 protected Entry(int hash, K key, V value, Entry next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } protected Object clone() { return new Entry(hash, key, value, (next==null ? null : (Entry) next.clone())); } public K getKey() { return key; } public V getValue() { return value; } // 设置value。若value是null，则抛出异常。 public V setValue(V value) { if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; } // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) && (value==null ? e.getValue()==null : value.equals(e.getValue())); } public int hashCode() { return hash ^ (value==null ? 0 : value.hashCode()); } public String toString() { return key.toString()+\"=\"+value.toString(); } } private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。 private class Enumerator implements Enumeration, Iterator { // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry entry = null; Entry lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) { this.type = type; this.iterator = iterator; } // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() { Entry e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null && i > 0) { e = t[--i]; } entry = e; index = i; return e != null; } // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() { Entry et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null && i > 0) { et = t[--i]; } entry = et; index = i; if (et != null) { Entry e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); } throw new NoSuchElementException(\"Hashtable Enumerator\"); } // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() { return hasMoreElements(); } // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); } // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() { if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException(\"Hashtable Enumerator\"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) { Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index], prev = null; e != null; prev = e, e = e.next) { if (e == lastReturned) { modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; } } throw new ConcurrentModificationException(); } } } private static Enumeration emptyEnumerator = new EmptyEnumerator(); private static Iterator emptyIterator = new EmptyIterator(); // 空枚举类 // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。 private static class EmptyEnumerator implements Enumeration { EmptyEnumerator() { } // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() { return false; } // 空枚举类的nextElement() 抛出异常 public Object nextElement() { throw new NoSuchElementException(\"Hashtable Enumerator\"); } } // 空迭代器 // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。 private static class EmptyIterator implements Iterator { EmptyIterator() { } public boolean hasNext() { return false; } public Object next() { throw new NoSuchElementException(\"Hashtable Iterator\"); } public void remove() { throw new IllegalStateException(\"Hashtable Iterator\"); } } } Collection是最基本的集合接口 继承的接口：Iterable 子接口：List、Set、Queue等 遍历Collection中的每一个元素 它支持一个Iterator()方法，该方法返回一个迭代子，该迭代子可逐一访问Collection中每一个元素 Iterator it = collection.iterator(); // 获得一个迭代子 while(it.hasNext()) { Object obj = it.next(); // 得到下一个元素 } 方法： retainAll(Collection&lt;?extends E>c); //保留，交运算 addAll(Collection&lt;?extends E>c); //添加，并运算 removeAll(Collection&lt;?extends E>c); //移除，减运算 LinkedListLinkedList是基于双向循环链表实现的，除了可以当作链表来操作外，它还可以当作栈、队列和双端队列来使用。 非线程安全，单线程下使用 LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。 是一个类 实现的接口：List、Collection、Iterable、Serializable、Cloneable、Deque，Queue 子类：没有子类 添加元素方法： boolean add(E e) 添加到链表末尾 void add(int index, E e) 添加到指定位置 boolean addAll(int index, Collection&lt;? extends E&gt; c) boolean addAll(Collection&lt;? extends E&gt; c) package java.util; public class LinkedList&lt;E> extends AbstractSequentialList&lt;E> implements List&lt;E>, Deque&lt;E>, Cloneable, java.io.Serializable { // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E> header = new Entry&lt;E>(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() { header.next = header.previous = header; } // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E> c) { this(); addAll(c); } // 获取LinkedList的第一个元素 public E getFirst() { if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; } // 获取LinkedList的最后一个元素 public E getLast() { if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; } // 删除LinkedList的第一个元素 public E removeFirst() { return remove(header.next); } // 删除LinkedList的最后一个元素 public E removeLast() { return remove(header.previous); } // 将元素添加到LinkedList的起始位置 public void addFirst(E e) { addBefore(e, header.next); } // 将元素添加到LinkedList的结束位置 public void addLast(E e) { addBefore(e, header); } // 判断LinkedList是否包含元素(o) public boolean contains(Object o) { return indexOf(o) != -1; } // 返回LinkedList的大小 public int size() { return size; } // 将元素(E)添加到LinkedList中 public boolean add(E e) { // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; } // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) { if (o==null) { // 若o为null的删除情况 for (Entry&lt;E> e = header.next; e != header; e = e.next) { if (e.element==null) { remove(e); return true; } } } else { // 若o不为null的删除情况 for (Entry&lt;E> e = header.next; e != header; e = e.next) { if (o.equals(e.element)) { remove(e); return true; } } } return false; } // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E> c) { return addAll(size, c); } // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E> c) { if (index &lt; 0 || index > size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E> successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E> predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) { Entry&lt;E> e = new Entry&lt;E>((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; } successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; } // 清空双向链表 public void clear() { Entry&lt;E> e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) { Entry&lt;E> next = e.next; e.next = e.previous = null; e.element = null; e = next; } header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; } // 返回LinkedList指定位置的元素 public E get(int index) { return entry(index).element; } // 设置index位置对应的节点的值为element public E set(int index, E element) { Entry&lt;E> e = entry(index); E oldVal = e.element; e.element = element; return oldVal; } // 在index前添加节点，且节点的值为element public void add(int index, E element) { addBefore(element, (index==size ? header : entry(index))); } // 删除index位置的节点 public E remove(int index) { return remove(entry(index)); } // 获取双向链表中指定位置的节点 private Entry&lt;E> entry(int index) { if (index &lt; 0 || index >= size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); Entry&lt;E> e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size >> 1)) { for (int i = 0; i &lt;= index; i++) e = e.next; } else { for (int i = size; i > index; i--) e = e.previous; } return e; } // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) { int index = 0; if (o==null) { for (Entry e = header.next; e != header; e = e.next) { if (e.element==null) return index; index++; } } else { for (Entry e = header.next; e != header; e = e.next) { if (o.equals(e.element)) return index; index++; } } return -1; } // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) { int index = size; if (o==null) { for (Entry e = header.previous; e != header; e = e.previous) { index--; if (e.element==null) return index; } } else { for (Entry e = header.previous; e != header; e = e.previous) { index--; if (o.equals(e.element)) return index; } } return -1; } // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() { if (size==0) return null; return getFirst(); } // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() { return getFirst(); } // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() { if (size==0) return null; return removeFirst(); } // 将e添加双向链表末尾 public boolean offer(E e) { return add(e); } // 将e添加双向链表开头 public boolean offerFirst(E e) { addFirst(e); return true; } // 将e添加双向链表末尾 public boolean offerLast(E e) { addLast(e); return true; } // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() { if (size==0) return null; return getFirst(); } // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() { if (size==0) return null; return getLast(); } // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() { if (size==0) return null; return removeFirst(); } // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() { if (size==0) return null; return removeLast(); } // 将e插入到双向链表开头 public void push(E e) { addFirst(e); } // 删除并返回第一个节点 public E pop() { return removeFirst(); } // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) { return remove(o); } // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) { if (o==null) { for (Entry&lt;E> e = header.previous; e != header; e = e.previous) { if (e.element==null) { remove(e); return true; } } } else { for (Entry&lt;E> e = header.previous; e != header; e = e.previous) { if (o.equals(e.element)) { remove(e); return true; } } } return false; } // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E> listIterator(int index) { return new ListItr(index); } // List迭代器 private class ListItr implements ListIterator&lt;E> { // 上一次返回的节点 private Entry&lt;E> lastReturned = header; // 下一个节点 private Entry&lt;E> next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) { // index的有效性处理 if (index &lt; 0 || index > size) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size >> 1)) { next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; } else { next = header; for (nextIndex=size; nextIndex>index; nextIndex--) next = next.previous; } } // 是否存在下一个元素 public boolean hasNext() { // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; } // 获取下一个元素 public E next() { checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; } // 是否存在上一个元素 public boolean hasPrevious() { // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; } // 获取上一个元素 public E previous() { if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; } // 获取下一个元素的索引 public int nextIndex() { return nextIndex; } // 获取上一个元素的索引 public int previousIndex() { return nextIndex-1; } // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() { checkForComodification(); Entry&lt;E> lastNext = lastReturned.next; try { LinkedList.this.remove(lastReturned); } catch (NoSuchElementException e) { throw new IllegalStateException(); } if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; } // 设置当前节点为e public void set(E e) { if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; } // 将e添加到当前节点的前面 public void add(E e) { checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; } // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E> { // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E> next; // 上一个节点 Entry&lt;E> previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E> next, Entry&lt;E> previous) { this.element = element; this.next = next; this.previous = previous; } } // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E> addBefore(E e, Entry&lt;E> entry) { // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E> newEntry = new Entry&lt;E>(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; } // 将节点从链表中删除 private E remove(Entry&lt;E> e) { if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; } // 反向迭代器 public Iterator&lt;E> descendingIterator() { return new DescendingIterator(); } // 反向迭代器实现类。 private class DescendingIterator implements Iterator { final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() { return itr.hasPrevious(); } // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() { return itr.previous(); } // 删除当前节点 public void remove() { itr.remove(); } } // 返回LinkedList的Object[]数组 public Object[] toArray() { // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E> e = header.next; e != header; e = e.next) result[i++] = e.element; return result; } // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T> T[] toArray(T[] a) { // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E> e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length > size) a[size] = null; return a; } // 克隆函数。返回LinkedList的克隆对象。 public Object clone() { LinkedList&lt;E> clone = null; // 克隆一个LinkedList克隆对象 try { clone = (LinkedList&lt;E>) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(); } // 新建LinkedList表头节点 clone.header = new Entry&lt;E>(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E> e = header.next; e != header; e = e.next) clone.add(e.element); return clone; } // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); } // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E>(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.zhoudamin.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.zhoudamin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"源码","slug":"源码","permalink":"http://www.zhoudamin.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Java基础-3","slug":"Java基础-3","date":"2017-09-11T02:46:51.000Z","updated":"2017-10-08T08:31:16.696Z","comments":true,"path":"2017/09/11/java-ji-chu-3/","link":"","permalink":"http://www.zhoudamin.com/2017/09/11/java-ji-chu-3/","excerpt":"一些Java基本功的记录。 Java基础系列： Java基础-1 Java基础-2","text":"一些Java基本功的记录。 Java基础系列： Java基础-1 Java基础-2 ArrayList与LinkedList的底层实现ArrayList是List接口的一个实现类，特点是查询效率高，增删效率低，线程不安全 原因是ArrayList底层封装了一个数组，他是用数组实现的。 地址 数组空间 2000 ————-&gt; a[0] 2004 ————-&gt; a[1] 2008 ————-&gt; a[2] — ————-&gt; … 2000+（n-1）*4 ————-&gt; a[n] 定义一个int[]数组，首地址是2000，int类型占4个字节，所以a[0]的首地址2000，a[1]就是2004 每次查询只要一个偏移量就可以了，所以查询效率高 增删效率低的原因： 地址 数组空间 2000 ————-&gt; a[0] 2004 ————-&gt; (新增元素) 2008 ————-&gt; a[1] — ————-&gt; … 2000+（n-1）*4 ————-&gt; a[n] 新增元素会引起后面的元素的移动，所以增删效率低。 LinkedList 增删效率高，查询效率低 LinkedList底层采用双向循环链表实现的List，链表的存储特点是不挨着，它存储每个元素分为三段：上一项的地址，下一项的地址，元素的内容。 每个元素在内存中的排列像是随机的，得根据地址来找元素，所以很慢 增删很快是因为，删除一个元素，前后元素会自动连上，而且删除一个元素只影响前后元素，所以增删效率高。 TCP三次握手，以及为什么不是两次或四次 三次握手过程： 第一次握手：客户端发送TCP包，置SYN标志位为1，将初始序号X，保存在包头的序列号（Seq）里。 第二次握手：服务端回应确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。 第三次握手：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z。 如果只有2次 第二次握手后，服务端发送请求给客户端，服务端以为连接成功了，但是如果实际上客户端没收到的话，客户端会认为连接没有建立，服务端会对已建立的连接保存必要的资源，如果出现大量这种情况，服务端会崩溃。 如果是4次 无谓的第四次 二叉树深度、结点​二叉树的第 i 层至多有 2^(i-1) 个结点； 深度为 k 的二叉树至多有 2^k - 1 ​个结点； 对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。 排序算法的稳定性是指 经过排序之后,能使值相同的数据保持原顺序中的相对位置不变 HTTP方法 GET 获取接口信息 PUT 支持幂等性的POST HEAD 紧急查看接口的HTTP的头 POST 提交数据到服务器 DELETE 删除服务器上的资源 OPTIONS 查看支持的方法 常见的HTTP相应状态码1xx：指示信息--表示请求已接收，继续处理 2xx：成功--表示请求已被成功接收、理解、接受 3xx：重定向--要完成请求必须进行更进一步的操作 4xx：客户端错误--请求有语法错误或请求无法实现 5xx：服务器端错误--服务器未能实现合法的请求 101 – 切换协议 201 – 已创建。 202 – 已接受。 203 – 非权威性信息。 204 – 无内容。 205 – 重置内容。 206 – 部分内容。 302 – 对象已移动。 304 – 未修改。 307 – 临时重定向。 401 – 访问被拒绝 403 – 禁止访问 404 – 未找到 405 – 用来访问本页面的 HTTP 谓词不被允许（方法不被允许） 406 – 客户端浏览器不接受所请求页面的 MIME 类型。 407 – 要求进行代理身份验证。 412 – 前提条件失败。 413 – 请求实体太大。 414 – 请求 URI 太长。 415 – 不支持的媒体类型。 416 – 所请求的范围无法满足。 417 – 执行失败。 423 – 锁定的错误。 500 – 内部服务器错误。 200：请求被正常处理 204：请求被受理但没有资源可以返回 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围 的资源。 301：永久性重定向 302：临时重定向 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上 304：发送附带条件的请求时，条件不满足时返回，与重定向无关 307：临时重定向，与302类似，只是强制要求使用POST方法 400：请求报文语法有误，服务器无法识别 401：请求需要认证 403：请求的对应资源禁止被访问 404：服务器无法找到对应资源 500：服务器内部错误 503：服务器正忙 反射机制功能 获得一个对象所属的类 获得一个类所有的成员变量和方法 运行时创建对象 运行时调用对象的方法 Java创建对象的方式 new一个 反射机制 clone()方法 反序列化的方式 Java程序初始化顺序 父类静态变量 父类静态代码块 子类静态变量 子类静态代码块 父类非静态变量 父类非静态代码块 父类构造函数 子类非静态变量 子类非静态代码块 子类构造函数 volatile用来修饰被不同线程访问和修改的变量 被volatile类型定义的变量，系统每次用它都是直接从内存中取，而不会利用缓存。 Java堆溢出public class HeapOOM1 { static class OOMObject{} public static void main(String [] args){ List&lt;OOMObject> list = new ArrayList&lt;OOMObject>(); while (true){ list.add(new OOMObject()); } } } 单例模式单例模式就是在应用程序中只创建一个该类的对象。又分为饿汉模式和懒汉模式。*实现套路也就是只提供私有构造函数，然后提供公有的 getInstance 方法。* 饿汉模式：也就是一开始就创建该对象 懒汉模式：等到需要用到的时候才创建该对象 饿汉模式public class Singleton { private static Singleton singleton = new Singleton(); private Singleton(){}; public static Singleton getInstance(){ return singleton; } } 懒汉模式public class Singleton { private static Singleton singleton; private Singleton(){}; public static Singleton getInstance(){ if(singleton == null) singleton = new Singleton(); return singleton; } } 多线程 synchronizedpublic static synchronized Singleton getInstance(){ if(singleton == null) singleton = new Singleton(); return singleton; } 双重检验锁public class Singleton { private static volatile Singleton singleton; public static Singleton getInstance() { if (singleton == null) { //Single Checked synchronized (Singleton.class) { if (singleton == null) { //Double Checked singleton = new Singleton(); } } } return singleton; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://www.zhoudamin.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"读书笔记之《程序员代码面试指南（字符串问题）》","slug":"读书笔记之《程序员代码面试指南（字符串问题）》","date":"2017-09-01T02:27:05.000Z","updated":"2018-08-03T14:54:45.413Z","comments":true,"path":"2017/09/01/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-zi-fu-chuan-wen-ti/","link":"","permalink":"http://www.zhoudamin.com/2017/09/01/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-zi-fu-chuan-wen-ti/","excerpt":"字符串问题也是老生常谈的算法问题，该书罗列的字符串问题以我做算法的经验来看，都是很好的题。 代码 Github 地址","text":"字符串问题也是老生常谈的算法问题，该书罗列的字符串问题以我做算法的经验来看，都是很好的题。 代码 Github 地址 判断两个字符串是否互为变形词给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样，那么str1和str2互为变形词。请实现函数判断两个字符串是否互为变形词。str1=”123”,str2=”231”,返回true。str1=”123”,str2=”2331”,返回false。 先判断长度是不是一致 再用一个长度为256的数组标记，一个加，一个减。最后看是不是互抵了。 package String; /** * Created by zdmein on 2017/9/1. * 判断两个字符串是否互为变形词 * 给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样， * 那么str1和str2互为变形词。请实现函数判断两个字符串是否互为变形词。 str1=\"123\",str2=\"231\",返回true。 str1=\"123\",str2=\"2331\",返回false。 */ public class isDeformation1 { public static void main(String args []){ String str1=\"54s6\"; String str2=\"465d\"; System.out.println(isDeformation(str1,str2)); } public static boolean isDeformation(String str1 ,String str2){ if(str1.length()!=str2.length()){ return false; } int res[]=new int [256]; int index=0; while (index!=str1.length()){ res[str1.charAt(index)]++; res[str2.charAt(index++)]--; } for(int i=0;i&lt;256;i++){ if(res[i]!=0){ return false; } } return true; } } 字符串的调整与替换 *把 “a b c” 替换后为 “a%20b%20%20c” 开辟空间，从尾部遍历替换到头部 package String; /** * Created by zdmein on 2017/9/1. * 字符串的调整与替换 *把 \"a b c\" 替换后为 “a%20b%20%20c” */ public class replace1 { public static void main(String [] args ){ String str=\"a b c\"; char chas[]=new char[20]; for(int i=0;i&lt;str.length();i++){ chas[i]=str.charAt(i); } replace(chas); } public static void replace(char [] chas){ int len=0; int num=0; for(;len&lt;chas.length &amp;&amp; chas[len]!=0;len++){ if(chas[len]==' '){ num++; } } int index=len+num*2; for(;index>=0;index--){ if (chas[len--]==' '){ chas[index--]='0'; chas[index--]='2'; chas[index]='%'; }else { chas[index]=chas[len+1]; } } System.out.println(chas); } } 扩展： 只含有数字字符和“”字符的字符类型数组，把数字字符挪到右边， *挪到左边 12**35 **1235 package String; /** * Created by zdmein on 2017/9/1. * 只含有数字字符和“”字符的字符类型数组，把数字字符挪到右边， *挪到左边 12**35 **1235 */ public class replace2 { public static void main(String [] args ){ String str=\"12**35\"; char chas[]=new char[20]; for(int i=0;i&lt;str.length();i++){ chas[i]=str.charAt(i); } modify(chas); } public static void modify(char [] chas){ if(chas==null||chas.length==0){ return; } int j=chas.length-1; for(int i=chas.length-1;i>=0;i--){ if(chas[i]!='*'){ chas[j--]=chas[i]; } } for(;j>=0;j--){ chas[j]='*'; } System.out.println(chas); } } 翻转字符串写一个函数，将字符串翻转，翻转方式如下：“I am a student”反转成“student a am I”，不借助任何库函数。 写个函数，先整体翻转一次，然后再每个单词翻转一次。easy！ package String; /** * Created by zdmein on 2017/9/2. * 翻转字符串 * 写一个函数，将字符串翻转，翻转方式如下：“I am a student”反转成“student a am I”，不借助任何库函数。 */ public class rotateWord1 { public static void main(String [] args){ String str= \"dogs love pig.\"; rotateWord(str); } public static void rotateWord(String str){ if(str==null||str.length()==0){ return ; } char [] strArr = str.toCharArray(); reverse(strArr,0,strArr.length-1); int index=0; for(int i=0;i&lt;strArr.length;i++){ if(strArr[i]==' '){ reverse(strArr,index,i-1); index=i+1; } } reverse(strArr,index,strArr.length-1); System.out.println(strArr); } public static void reverse(char[] strArr ,int first ,int end){ while (first&lt;end){ char tmp=strArr[first]; strArr[first]=strArr[end]; strArr[end]=tmp; first++; end--; } } } 数组中两个字符串的最小距离 Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”]. Given word1 = “coding”, word2 = “practice”, return 3. Given word1 = “makes”, word2 = “coding”, return 1. 用2个下标指向2个字符串，跟新位置，互相减，然后Math.min取小的。 package String; /** * Created by zdmein on 2017/9/3. * 数组中两个字符串的最小距离 *Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"]. * Given word1 = “coding”, word2 = “practice”, return 3. * Given word1 = \"makes\", word2 = \"coding\", return 1. */ public class minDistance1 { public static void main(String args[]){ String [] strs ={\"1\",\"3\",\"3\",\"3\",\"2\",\"3\",\"1\"}; String str1=\"1\"; String str2=\"2\"; minDistance(strs,str1,str2); } public static void minDistance(String[] strs,String str1 , String str2){ if(strs==null||strs.length==0||str1==null||str2==null){ return; } int index1=-1; int index2=-1; int min=Integer.MAX_VALUE; for(int i=0;i&lt;strs.length;i++){ if(strs[i]==str1){ index1=i; if(index2!=-1){ min=Math.min(min,index1-index2); } }else if(strs[i]==str2){ index2=i; if(index1!=-1){ min=Math.min(min,index2-index1); } } } // if(min!=Integer.MAX_VALUE){ System.out.println(min); }else { System.out.println(-1); } //上面这个渣渣代码可以这样写： // min==Integer.MAX_VALUE ? -1 : min; } } 替换字符串中连续出现的指定字符串题目：给定单个字符串str、from和to，已知from字符串中无重复字符，把str中所有from的子串全部替换成to字符串，对连续出现from的部分要求只替换成一个to字符串，返回最终结果字符串。举例：str=”123abc”，from=”abc”，to=”4567”，返回”1234567”；str=”123”，from=”abc”，to=”4567”，返回”123”；str=”123abcabc”，from=”abc”，to=”X”，返回”123X”； 思路： 把from匹配的字符，设为0，然后把0的部分全部替换掉成to，就好了 package String; /** * Created by zdmein on 2017/9/4. * 替换字符串中连续出现的指定字符串 题目： 给定单个字符串str、from和to，已知from字符串中无重复字符，把str中所有from的子串全部替换成to字符串，对连续出现from的部分要求只替换成一个to字符串，返回最终结果字符串。 举例： str=\"123abc\"，from=\"abc\"，to=\"4567\"，返回\"1234567\"； str=\"123\"，from=\"abc\"，to=\"4567\"，返回\"123\"； str=\"123abcabc\"，from=\"abc\"，to=\"X\"，返回\"123X\"； */ public class replace3 { public static void main(String args[]){ String str=\"123abcabc\"; String from=\"abc\"; String to = \"4567\"; System.out.println(replace(str,from,to)); } private static String replace(String str,String from ,String to){ if(str==null||from==\"\"||to==\"\"){ return str; } char[] chstr=str.toCharArray(); char[] chfrom=from.toCharArray(); int match=0; for(int i=0;i&lt;str.length();i++){ if(chstr[i]==chfrom[match++]){ if(match==chfrom.length){ clear(chstr,i,chfrom.length); match=0; } }else { match=0; } } String res=\"\"; for(int i=0;i&lt;chstr.length;i++){ if(chstr[i]!=0){ while (chstr[i]!=0){ res+=chstr[i++]; } } if(chstr[i]==0){ while (i!=chstr.length&amp;&amp;chstr[i]==0){ i++; } res+=to; i--; } } return res; } private static void clear(char[] chstr , int end ,int len){ while(len--!=0){ chstr[end--]=0; } } } 字符串的统计字符串 统计字符串中每个字符的出现频率，返回一个字符串统计，key 为统计字符，value 为出现频率输入： aaabbadddffc 输出： a_3_b_2_a_1_d_3_f_2_c_1 先记录a，然后一项一项对比记录 String.valueof()的使用 package String; /** * Created by zdmein on 2017/9/5. * 字符串的统计字符串 统计字符串中每个字符的出现频率，返回一个字符串统计，key 为统计字符，value 为出现频率 输入： aaabbadddffc 输出： a_3_b_2_a_1_d_3_f_2_c_1 */ public class getCountString1 { public static void main(String [] args){ String str=\"aaabbadddffc\"; System.out.println(getCountString(str)); } private static String getCountString(String str){ if(str==null||str.length()==0){ return \"\"; } char [] chs=str.toCharArray(); String res=String.valueOf(chs[0]); int num=1; for(int i=1;i&lt;str.length();i++){ if(chs[i]==chs[i-1]){ num++; }else { res=res+\"_\"+String.valueOf(num)+\"_\"+String.valueOf(chs[i]) ; num=1; } } return res+\"_\"+String.valueOf(num)+\"\" ; } } 判断两个字符串是否互为旋转词 题目： 如果一个字符串str，把字符串str前面任意的部分挪到后面形成的字符串叫做str的旋转词。 如str=”12345”，str的旋转词有”12345”、”23451”、”34512”、”45123”、”51234”。 给定两个字符串a和b，请判断a和b是否互为旋转词。 举例： a=”cdab”，b=”abcd”，返回true； a=”1ab2”，b=”ab12”，返回false； a=”2ab1”，b=”ab12”，返回true。 要求： 如果a和b长度不一样，那么a和b必然不互为旋转词，可以直接返回false。 当a和b长度一样，都为N时，要求解法的时间复杂度为O(N)。 package String; /** * Created by zdmein on 2017/9/6. */ public class isRotation { public boolean isRotation(String a ,String b){ if(a==null||b==null||a.length()!=b.length()){ return false; } String b2=b+b; return KMP(b2,a)!=-1; // KMP算法 } public static int KMP(String source , String pattern){ // int [] N=getN(pattern); return -1; } } 判断是不是整体有效的括号字符串package String; import java.util.Scanner; /** * Created by zdmein on 2017/9/18. * 判断是不是整体有效的括号字符串 * 括号字符串的有效性和最长有效长度 */ public class isValid1 { public static void main(String [] args){ Scanner cin=new Scanner(System.in); String str=cin.next(); System.out.println(isValid(str)); } public static boolean isValid(String str){ if(str==null ||str.equals(\"\")){ return false; } char [] chs=str.toCharArray(); int status=0; for(int i=0;i&lt;str.length();i++){ if(chs[i]!=')'&amp;&amp;chs[i]!='('){ return false; } if(chs[i]==')'&amp;&amp;--status&lt;0){ return false; } if(chs[i]=='('){ status++; } } return status==0; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"面经-腾讯1","slug":"面经-腾讯1","date":"2017-08-30T02:18:48.000Z","updated":"2017-08-31T04:41:29.561Z","comments":true,"path":"2017/08/30/mian-jing-teng-xun-1/","link":"","permalink":"http://www.zhoudamin.com/2017/08/30/mian-jing-teng-xun-1/","excerpt":"基础查漏补缺~","text":"基础查漏补缺~ 面向对象的特征 继承：联结性的层次模型，表述共性 多态：允许不同类对同一消息作出响应 抽象：过程抽象，数据抽象 封装：将客观事物抽象成类 重写和重载有什么不同 重写（override）：派生类函数覆盖 重载（overload）：多个方法有相同名字、不同参数。 区别： 重写是子类与父类之间的关系，是垂直关系；重载是同一个类中方法之间的关系，是水平关系。 重写只能由一个方法或者一对方法产生关系；重载是多个方法之间的关系。 重写要求参数列表相同；重载要求参数列表不同。 重写关系中，调用方法体是根据对象的类型来决定；重载是根据调用的实参表和形参表来选择方法体。 计算机加载程序包括哪几个区？链表和数组有什么不同？ 数组静态分配内存，链表动态分配内存 数组在内存中连续，链表不连续 数组元素在栈区，链表元素在堆区 数组利用下标定位，时间复杂度O(1)，链表定位元素时间复杂度O(n) 数组插入和删除时间复杂度O(n)，链表的时间复杂度O(1) 栈和堆的特点是什么？ 栈： 先进后出 存放的都是局部变量 使用完变量会自动在内存中释放 堆： 可以看成一棵树 存放的是实体或者成员变量 存放的实体都是有首地址值的 实体中的数据都是有初始值的 什么排序稳定性高而且效率？快排 进程间通讯的几种方式？ 文件和记录锁定 管道 有名管道 FIFO 信号量 信号 消息队列 共享内存 套接字（socket） 详解 解释 TCP/IP的三次握手协议TCP/IP有什么作用有哪些方式可以加快查询？（我答了建索引，试图存储 过程，建索引是一定对的其他两个就不知道了）然后他继续追问，建索引一般是怎么才能让查询更加快呢？ （问我怎么样才能够通过索引排除不同的数据吧，这个还真懂完全没左外连接和右外连接有什么不同左连接就是以左为主，右边的记录可能为空 右连接就是以右为主左边的可能为空 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"面经","slug":"面经","permalink":"http://www.zhoudamin.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"http://www.zhoudamin.com/tags/%E7%AC%94%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"},{"name":"腾讯","slug":"腾讯","permalink":"http://www.zhoudamin.com/tags/%E8%85%BE%E8%AE%AF/"}]},{"title":"Linux学习指南","slug":"Linux学习指南","date":"2017-08-28T14:22:39.000Z","updated":"2019-01-13T15:35:07.035Z","comments":true,"path":"2017/08/28/linux-xue-xi-zhi-nan/","link":"","permalink":"http://www.zhoudamin.com/2017/08/28/linux-xue-xi-zhi-nan/","excerpt":"发现学过的东西很容易忘，所以常常复习、总结还是蛮必要的。","text":"发现学过的东西很容易忘，所以常常复习、总结还是蛮必要的。 Linux基础 输出 echo \"Hellbo\" Hellbo 快捷键 快捷键 作用 Ctrl+c 终止程序 Ctrl+d 键盘输入结束或退出终端 Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl+z 把当前程序放到后台运行，fg将程序恢复到前台 Ctrl+a 将光标移至输入行头 Ctrl+e 将光标移至输入行尾 Ctrl+k 删除从光标位置到行末 Alt+Backspace 向前删除一个单词 Shift+Pgup 将终端显示向上滚动 Shift+PgDn 将终端显示向下滚动 创建文件 touch adeni.txt dsaidj.txt //创建2个文件 touch abc_{1..10}_linux.txt //创建多个文件 通配符找文件 ls *.txt Shell通配符 字符 含义 * 匹配0或多个字符 ？ 匹配任意一个字符 [list] 匹配list中的任意单一字符 [!list] 匹配除list中的任意单一字符以外的字符 [c1-c2] 匹配c1-c2终端任意单一字符 {string1,string2,…} 匹配list中的任意单一字符 {c1..c2} 匹配list中的任意单一字符 用户及文件权限管理 创建用户 sudo adduser zdm //创建用户 ls /home //默认为新用户创建home目录 su -l zdm //切换登陆用户 groups zdm //查看自己属于哪些用户组 cat /etc/group | sort //查看 /etc/group 文件 // 将其他用户加入sudo用户组 su -l zdm sudo ls 变更文件所有者 touch iphone cd /home/zdm ls iphone sudo chown shiyanlou iphone echo \"echo \\\"hello shiyanlou\\\"\" > iphone //加内容 chmod 700 iphone //修改权限 cp -r father family //复制目录 rm test //删除 环境变量及文件查找//创建tmp变量 $ declare tmp //使用=赋值 $ tmp=zdm //输出 $ echo $tmp //创建一个Shell脚本文件 $ gedit hello_shell.sh -------------------------- #!/bin/bash for((i=0;i { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.zhoudamin.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.zhoudamin.com/tags/Linux/"}]},{"title":"读书笔记之《程序员代码面试指南（二叉树问题）》","slug":"读书笔记之《程序员代码面试指南（二叉树问题）》","date":"2017-08-24T02:59:41.000Z","updated":"2018-08-03T14:54:17.732Z","comments":true,"path":"2017/08/24/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-er-cha-shu-wen-ti/","link":"","permalink":"http://www.zhoudamin.com/2017/08/24/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-er-cha-shu-wen-ti/","excerpt":"二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 代码 Github 地址","text":"二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 代码 Github 地址 判断二叉树是不是平衡二叉树输入一棵二叉树的根节点，判断该树是不是平衡的二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 先比较左边，再比较右边； 左子树也先比较左边再比较右边。 public boolean isBalance(Node head){ boolean res=true; getHeight(head,1,res); return res; } public int getHeight(Node head , int level ,boolean res){ if(head==null){ return level; } int lH=getHeight(head.left,level+1,res); if(!res){ return level; } int rH=getHeight(head.right,level+1,res); if(!res){ return level; } if(Math.abs(lH-rH)>1){ res=false; } return Math.max(lH,rH); } 根据后序数组重建搜索二叉树给定一个整型数组arr，已知其中没有重复值，判断arr是否可能是节点值类型为整型的搜索二叉树后序遍历的结果。 数组最后一个值，肯定是根节点的值 小于根节点的为左子树，大于根节点的为左子树 对应2,1,3小于4 6,5,7大于4 public static void main(String [] args){ int [] arr={2,1,3,6,5,7,4}; System.out.println(isPostArray(arr)); } public static boolean isPostArray(int [] arr){ if(arr==null || arr.length==0){ return false; } return isPost(arr,0,arr.length-1); } public static boolean isPost(int [] arr, int start ,int end){ if(start==end){ return true; } int less=-1; int more=end; for(int i=start;i&lt;end;i++){ if(arr[i]&lt;arr[end]){ less=i; }else { more=more==end ? i : more; } } if(less==-1||more==end){ return isPost(arr,start,end-1); } if(less!=more-1){ return false; } return isPost(arr,start,less)&amp;&amp;isPost(arr,more,end-1); } 二叉树的序列化和反序列化package BinaryTree; import java.util.LinkedList; import java.util.Queue; /** * Created by zdmein on 2017/9/7. 12 / \\ 3 null / \\ null null 先序遍历：12！3！#！#！#！ */ public class NodeSerial { /** * 定义Node */ public class Node{ public int value; public Node left; public Node right; public Node(int data){ this.value=data; } } /** * 先序遍历 */ public String serialByPre(Node head){ if(head==null){ return \"#!\"; } String res=head.value+\"!\"; res+=serialByPre(head.left); res+=serialByPre(head.right); return res; } /** * 先序遍历反序列化 */ public Node reconByPreString(String preStr){ String [] values=preStr.split(\"!\"); Queue&lt;String> queue=new LinkedList&lt;String>(); for(int i=0;i&lt;values.length;i++){ queue.offer(values[i]); } return reconPreOrder(queue); } /** * Queue add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 */ public Node reconPreOrder(Queue&lt;String> queue){ String value = queue.poll(); if(value.equals(\"#\")){ return null; } Node head=new Node(Integer.valueOf(value)); Node left=reconPreOrder(queue); Node right=reconPreOrder(queue); return head; } } 找到二叉树中的最大搜索二叉子树 题目：给定一棵二叉树的头节点head, 已知其中所有节点的值都不一样， 找到含有节点最多的搜索二叉子树，并返回这颗子树的头节点。 package BinaryTree; /** * Created by zdmein on 2017/9/8. * 找到二叉树中的最大搜索二叉子树 题目：给定一棵二叉树的头节点head, 已知其中所有节点的值都不一样， 找到含有节点最多的搜索二叉子树，并返回这颗子树的头节点。 6 / \\ 1 12 /\\ / \\ 0 3 10 13 / \\ / \\ 4 14 2 9 /\\ /\\ 2 5 1 6 二叉搜索树： 10 / \\ 4 14 / \\ / \\ 2 5 1 6 要求： 如果节点数为N，要求时间复杂度为O（N） ,额外空间复杂度为O(h),h为二叉树的高度。 解： 以节点node为头的树中，最大的搜索二叉子树只可能来自一下两种情况。 1.如果来自node左子树上的最大搜索二叉子树是以node.left为头的；来自node右子树的最大搜索二叉树是以 node.right为头的；node左子树上的最大搜索二叉子树的最大值小于node.value； node右子树的最大搜索二叉子树的最小值大于node.value,那么以节点node为头的整棵树都是搜索二叉树。 2如果不满足第一中情况，说明节点node为头的整颗树不能连成搜索二叉树。这种情况下，以node为头的树上的最大搜索二叉子树来自node的左子树上的最大搜索二叉子树和来自右子树上的最大搜索二叉子树之间， 节点较多的那个。 过程如下： 1，整个过程是二叉树的后序遍历。（左右根） 2，遍历到当前节点记为cur时，先遍历cur的左子树收集4个信息，分别是左子树上最大搜索二叉子树的头节点（IBST） ，节点数（ISize）,最小值（IMin）,最大值（IMax）. 再遍历cur的右子树收集4个信息，分别是右子树上最大搜索二叉子树的头节点（RBST） ，节点数（RSize）,最小值（RMin）,最大值（RMax）. 3, 根据步骤2收集的信息，判断是否满足第一种情况，如果满足第一种情况就返回cur，如果满足第二种情况，就返回IBST和RBST中较大的一个。 4，可以使用全局变量的方式实现步骤2中收集节点数，最大和最小的情况。 */ public class biggestSubBST1 { public class Node{ public int value; public Node left; public Node right; public Node(int data){ this.value=data; } } public Node biggestSubBST(Node head){ int [] record =new int[3]; return posOrder(head , record); } public Node posOrder(Node head,int [] record){ if(head==null){ record[0]=0; record[1]=Integer.MAX_VALUE; record[2]=Integer.MIN_VALUE; return null; } int value=head.value; Node left=head.left; Node right=head.right; Node lBST=posOrder(left,record); int lSize=record[0]; int lMin=record[1]; int lMax=record[2]; Node rBST=posOrder(right,record); int rSize=record[0]; int rMin=record[1]; int rMax=record[2]; record[1]=Math.min(value,lMin); record[2]=Math.max(value,rMax); if(left==lBST&amp;&amp;right==rBST&amp;&amp;lMax&lt;value&amp;&amp;rMin>value){ record[0]=lSize+rSize+1; return head; } record[0]=Math.max(lSize,rSize); return lSize>rSize?head.left:head.right; } } 找到二叉树中符合搜索二叉树条件的最大拓扑结构 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《程序员代码面试指南（链表问题）》","slug":"读书笔记之《程序员代码面试指南（链表问题）》","date":"2017-08-24T02:59:19.000Z","updated":"2018-08-03T14:53:42.767Z","comments":true,"path":"2017/08/24/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-lian-biao-wen-ti/","link":"","permalink":"http://www.zhoudamin.com/2017/08/24/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-lian-biao-wen-ti/","excerpt":"链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。它可以根据需要开辟内存单元。链表有一个“头指针”变量，以head表示，它存放一个地址。该地址指向一个元素。链表中每一个元素称为“结点”，每个结点都应包括两个部分：一为用户需要用的实际数据，二为下一个结点的地址。因此，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。","text":"链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。它可以根据需要开辟内存单元。链表有一个“头指针”变量，以head表示，它存放一个地址。该地址指向一个元素。链表中每一个元素称为“结点”，每个结点都应包括两个部分：一为用户需要用的实际数据，二为下一个结点的地址。因此，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。 打印两个有序链表的公共部分package LinkedList; /** * Created by zdmein on 2017/8/31. * * 打印两个有序链表的公共部分 * 给定两个有序列表的头指针head1和head2，打印两个链表的公共部分。 */ public class printCommonPart1 { public static class Node{ public int value; public Node next; public Node(int data){ this.value=data; } } public static void main(String args[]){ Node head1=new Node(2); Node head11=new Node(3); Node head12=new Node(4); Node head13=new Node(7); head1.next=head11; head11.next=head12; head12.next=head13; Node head2=new Node(1); Node head21=new Node(3); Node head22=new Node(4); Node head23=new Node(9); head2.next=head21; head21.next=head22; head22.next=head23; printCommonPart(head1,head2); } public static void printCommonPart(Node head1,Node head2){ System.out.println(\"Print Common Part: \"); while(head1!=null&amp;&amp;head2!=null){ if(head1.value==head2.value){ System.out.println(head1.value); head1=head1.next; head2=head2.next; }else if(head1.value>head2.value){ head2=head2.next; }else { head1=head1.next; } } } } 判断一个链表是否为回文结构题目：判断一个链表是否为回文结构。要求：时间复杂度为 O(n)，空间时间复杂度为O(1)。 思路分析：回文链表的特点就是对称，那么要判断是否回文，就可以用两个指针指向对称的节点，看它们的数据是否一样。由于是单向链表，不能同时用两个指针，从头尾向内部遍历取值比较。且本题对空间复杂度也有要求，所以可用如下方法实现。具体步骤如下：（1）先得到链表的中间节点；（2）从中间节点的下一个节点开始，反转链表。（3）从中间节点处，断开原链表。（4）用两个指针分别向两个端点移动，同时进行比较，数据相同则继续，数据不同则直接返回false。直到遍历完成，最后返回true。 class ListNode { public char data; public ListNode next; public ListNode(char c){ this.data=c; } } public static boolean isPalindrome(ListNode head ){ ListNode slow = head; ListNode fast= head; if(fast==null || fast.next==null){ return true; } //一个每次走2步，一个每次走1步，所以当fast到表尾，slow肯定把链表折半 while(fast.next!=null&amp;&amp;fast.next.next!=null){ fast=fast.next.next; slow=slow.next; } ListNode midNode=slow; ListNode firNode = slow.next; //后半段第一个节点 ListNode cur=firNode.next; //从第一个节点开始插入 firNode.next=null; //第一个节点最后变成最后一个节点，所以要置空 while(cur!=null){ ListNode nextNode = cur.next; cur.next=midNode.next; midNode=cur; cur=nextNode; } slow=head; fast=midNode.next; while (fast!=null){ if(fast.data!=slow.data){ return false; } slow=slow.next; fast=firNode.next; } return true; } 反转单向反转单向链表 1–&gt;2–&gt;null 反转后 2–&gt;1–&gt;null /** * Definition for ListNode. * public class ListNode { * int val; * ListNode next; * ListNode(int val) { * this.val = val; * this.next = null; * } * } */ public class Solution { /* * @param head: n * @return: The new head of reversed linked list. */ public ListNode reverse(ListNode head) { // write your code here ListNode pre=null; ListNode next1=null; while(head!=null){ next1=head.next; head.next=pre; pre=head; head=next1; } return pre; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《程序员代码面试指南（位运算及大数据）》","slug":"读书笔记之《程序员代码面试指南（位运算及大数据）》","date":"2017-08-22T12:09:43.000Z","updated":"2018-08-03T14:54:29.283Z","comments":true,"path":"2017/08/22/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-wei-yun-suan-ji-da-shu-ju/","link":"","permalink":"http://www.zhoudamin.com/2017/08/22/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-wei-yun-suan-ji-da-shu-ju/","excerpt":"位运算、大数据和空间限制","text":"位运算、大数据和空间限制 不用额外变量交换两个整数的值【题目】 如何不用任何额外变量交换两个整数的值？ 【解答】 使用位运算的异或运算，或者使用加法运算 a异或b的结果是c,那么c就是a整数位信息和b整数位信息的所有不同信息。 a = a^b,当前a=c；b = a^b相当于b = c^b 当前b=a；a = a^b 相当于a = c^a 当前a=b,完成交换； 如果是加法交换的话，假设a + b结果是c，那么 a = a+b,当前a=c；b = a-b相当于b = c-b 当前b=a；a = a-b 相当于a = c-a 当前a=b,完成交换； a=011 b=100 c=a^b=111 a=a^c=011^111=100 b=a^c=100^111=011 输入一个整数,求该整数的二进制表达中有多少个1题目：输入一个整数，求该整数的二进制表达中有多少个1。例如输入10，由于其二进制表示为1010，有两个1，因此输出2。 public int count(int n){ int res=0; while(n!=0){ n&amp;=(n-1); res++; } return res; } --- n=1010 n=1010&amp;1001=1000 res=1; n=1000&amp;0999=0000 res=2; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java基础-操作系统","slug":"Java基础-操作系统","date":"2017-08-15T12:14:51.000Z","updated":"2017-08-16T08:00:23.672Z","comments":true,"path":"2017/08/15/java-ji-chu-cao-zuo-xi-tong/","link":"","permalink":"http://www.zhoudamin.com/2017/08/15/java-ji-chu-cao-zuo-xi-tong/","excerpt":"操作系统的一些基本概念","text":"操作系统的一些基本概念 进程和线程的区别进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程是进程的一个实体，是CPU调度和分派的基本单元，他是比进程更小的能独立运行的基本单位。 一个程序至少有一个进程，一个进程至少有一个线程 线程的划分尺度小于进程，使得多线程程序的并发性高 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 死锁的必要条件，怎么处理死锁四个条件： 互斥条件：指进程对所分配到的资源进行排他性的使用，即在一段时间内某资源只有一个进程占用，如果此时还有其他进程请求资源，则让他先等着，直到占有资源的进程用完释放后，才可以用。意思就是一个资源只能一个进程占用，其他要用的得等着。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放。意思是一个进程占用了资源，想获得别的资源，要是那个资源被占，那自己先等，但是自己占的资源也不会释放给别的进程。 不剥夺条件：指进程占有的资源，不能被剥夺，只能自己释放。我占的资源你不能抢。 环路等待条件：指在发生死锁时，必然是有一个环路链，进程都占用资源，但是又想获得其他进程占有的资源，形成一个环，循环等待。 处理死锁的方法： 预防死锁 破坏占有并等待条件：一次性分配全部资源 or 每次申请前，必须释放自己的资源 避免死锁 检测死锁 解除死锁 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程 撤销进程：强制撤销某些、甚至全部死锁进程并剥夺这些进程的资源 进程回退：让一or多个进程回退到足以回避死锁的地步，进程回退时自愿放弃资源而不是剥夺。（设置还原点） Window内存管理方式段存储## 页存储 段页存储进程的几种状态进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。 一个进程的生命周期可以划分为一组状态。 三个：就绪、运行、阻塞 运行：进程占用CPU，并在CPU上运行 就绪：进程已经具备运行条件，但是CPU还没有分配过来 阻塞：进程因为某件事发生而暂时不能运行 IPC几种通信方式IPC是进程间的通讯 （Inter-process communication） 作用：数据传输、共享数据、通知事件、资源共享、进程控制（这些都需要通讯） 无名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在父子进程间通信。管道的缓冲区是有限的，管道所传送的是无格式字节流，要求管道的读出方和写入方必须事先约好数据的格式。 命名管道（fifo）：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对他们的写则是把数据添加到末尾。 消息队列（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识，可以用非先进先出方式处理，消息队列是异步通信。 共享内存：共享内存是最快的IPC方式，在共享内存段中都是以字符串的默认结束符为一条信息的结尾。 信号量（semophore）：信号量是一个计数器 什么是虚拟内存 虚拟地址、逻辑地址、线性地址、物理地址的区别 物理地址 用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应 虚拟地址 这是对整个内存的抽象描述 逻辑地址 指机器语言指令中，用来指定一个操作数或者是一条指令的地址 线性地址 也是不真实的地址，对应硬件页式内存的转换前地址 推荐书籍：《深入理解现代操作系统》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://www.zhoudamin.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"http://www.zhoudamin.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"读书笔记之《程序员代码面试指南（数组和矩阵问题）》","slug":"读书笔记之《程序员代码面试指南（数组和矩阵问题）》","date":"2017-08-14T15:54:40.000Z","updated":"2018-08-03T14:53:54.581Z","comments":true,"path":"2017/08/14/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-shu-zu-he-ju-zhen-wen-ti/","link":"","permalink":"http://www.zhoudamin.com/2017/08/14/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-shu-zu-he-ju-zhen-wen-ti/","excerpt":"数组和矩阵问题，这些做得比较多。","text":"数组和矩阵问题，这些做得比较多。 未排序正整数数组中累加和为给定值的最长子数组长度package Array; /** * Created by zdmein on 2017/8/30. *未排序正整数数组中累加和为给定值的最长子数组长度 * 给定一个无需数组arr,其中元素为正，给定一个整数k。求arr的所有子数组中累加和为k的最长子数组的长度。 * arr=[1,2,1,1,1],k=3 * 结果返回3 */ public class getMaxLength1 { public static void main(String [] args){ int [] arr={1,2,1,1,1}; int k=3; System.out.println(getMaxLength(arr,k)); } public static int getMaxLength(int [] arr ,int k){ if(arr==null||arr.length&lt;0||k&lt;0){ return 0; } int right =0; int left=0; int len=0; int sum=arr[0]; while (right&lt;arr.length){ if(sum==k){ len=Math.max(len,right-left+1); sum-=arr[left++]; }else if(sum&lt;k){ right++; if(right==arr.length){ break; } sum+=arr[right]; }else { sum-=arr[left++]; } } return len; } } 数组partition调整使数组的左部分单调有序给定一个有序数组arr，调整使得数组的左部分无重复元素且有序，右边部分不要求。如数组arr[]={1,2,2,2,3,3,4,5,6,9,9} ;调整过后可以为：[1, 2, 3, 4, 5, 6, 9, 2, 3, 2, 9] 。 思路：使用标记 u 其中arr[0…u] 表示已经处理过的没有重复元素且有序的区间，从arr[u+1…i-1]表示有重复元素的部分。则算法主要分为下面两部分。1. 比较 arr[i] 与 arr[u] 是否相同如果不同，则将 arr[i] 的值赋给arr[u+1],u++;2. i++遍历数组。 import java.util.HashSet; public class Main { public static void main(String[] args) { int[] arr = {1, 2, 2, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 8, 9}; leftUnique(arr); } public static void leftUnique(int[] arr) { if (arr.length == 0 || arr == null) { return; } int u=0; int i=1; while (i!=arr.length){ if(arr[i++]!=arr[u]){ swap(arr,i-1,++u); } } for( i=0;i&lt;arr.length;i++){ System.out.print(arr[i]+\" \"); } } public static int [] swap(int[] arr,int m, int n){ int temp= arr[m]; arr[m]=arr[n]; arr[n]=temp; return arr ; } } 将正方形矩阵顺时针转动90度题目：给定一个N*N的矩阵matrix,求把这个矩阵调整成顺时针转动90度后的形式。 例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 顺时针转动90度后为: 13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 要求：额外空间复杂度为O(1) public class Main { public static void main(String[] args) { int[][] m = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12}, {13,14,15,16} }; rotate(m); } public static void rotate(int[][] arr) { int tR=0; int tC=0; int dR=arr.length-1; int dC=arr[0].length-1; while (tR&lt;dR){ rotateEdge(arr,tR++,tC++,dR--,dC--); } for (int i=0;i&lt;arr.length;i++) { for (int j = 0; j &lt; arr[0].length; j++) { System.out.print(arr[i][j] + \" \"); } System.out.println(\" \"); } } public static void rotateEdge(int [][] arr ,int tR,int tC ,int dR ,int dC){ int times=dR-tR; int temp=0; for(int i=0;i!=times;i++){ temp = arr[tR][tC+i]; arr[tR][tC+i]=arr[dR-i][tC]; arr[dR-i][tC]=arr[dR][dC-i]; arr[dR][dC-i]=arr[tR+i][dC]; arr[tR+i][dC]=temp; } } } 找到无序数组中最小的K个数给定一个无序的整型数组arr，找到其中最小的k个数。 时间复杂度：O(nlogk) 维护一个有k个数的大根堆，这个堆代表目前选出的k个最小的数。在堆的k个元素中堆顶元素是最小的k个数中最大的那个。 接下来要遍历整个数组，遍历的过程中看当前数是否比堆顶元素小。如果是，就把堆顶元素替换成当前数，然后调整堆。如果不是，则不做任何操作，继续遍历下一个数。在遍历完成后，堆中的k个数就是所有数组中最小的k个数。 public class Main { public static void main(String[] args) { int[] arr = {5 ,9,3,4,7,2,8,1,6}; int k=3; int [] res= getMinKNumsByHeap(arr,k); for(int i=0;i&lt;res.length;i++){ System.out.println(res[i]); } } public static int [] getMinKNumsByHeap(int[] arr,int k) { if(k&lt;1&amp;&amp;k>arr.length){ return arr; } int kHeap[]=new int [k]; for(int i=0;i!=k;i++){ heapInsert(kHeap,arr[i],i); } for(int i = k;i !=arr.length;i++){ if(arr[i]&lt;kHeap[0]){ kHeap[0]=arr[i]; heapify(kHeap,0,k); } } return kHeap; } public static void heapify(int [] arr, int index ,int heapsize){ int left= index*2+1; int right=index*2+2; int largest=index; while(left&lt;heapsize){ if(arr[left]>arr[index]){ largest=left; } if(right&lt;heapsize &amp;&amp; arr[right]>arr[largest]){ largest=right; } if(largest!=index){ swap(arr,largest,index); }else { break; } index=largest; left= index*2+1; right=index*2+2; } } public static void heapInsert(int [] kHeap ,int arri ,int i){ kHeap[i]=arri; while (i!=0){ int parent=(i-1)/2; if(kHeap[parent]&lt;kHeap[i]){ swap(kHeap,parent,i); i=parent; }else { break; } } } public static void swap(int [] arr ,int m ,int n){ int temp=arr[m]; arr[m]=arr[n]; arr[n]=temp; } } 三数排序给定一个数组，其中只有三个数0,1,2三个值，请实现arr排序。 三个颜色的球排序 用left和right标记数组头和尾，用index遍历，遇到该交换的交换，直到index==right为止。 import java.util.HashSet; public class Main { public static void main(String[] args) { int[] arr = {1,0,2,0,1,2,1,0 ,2, 2,0}; leftUnique(arr); } public static void leftUnique(int[] arr) { if (arr.length &lt;2 || arr == null) { return; } int left=-1; int index=0; int right=arr.length; while (index&lt;right){ if(arr[index]==0){ swap(arr,++left,index++); }else if(arr[index]==2){ swap(arr,--right,index); }else { index++; } } for(int i=0;i&lt;arr.length;i++){ System.out.print(arr[i]+\" \"); } } public static int [] swap(int[] arr,int m, int n){ int temp= arr[m]; arr[m]=arr[n]; arr[n]=temp; return arr ; } } 转圈打印矩阵给一个整型矩阵matrix，按照转圈的方式打印它。 1 2 3 4 5 6 7 8 9 打印就是：1 2 3 6 9 8 7 4 5 public class CircleDynamic { public static void main(String [] args){ int [][] m= {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}, {13,14,15,16}}; spirOrderPrint(m); } public static void spirOrderPrint(int [][]matrix){ int tR = 0; int tC = 0; int dR=matrix.length-1; int dC=matrix[0].length-1; while (tR&lt;=dR &amp;&amp; tC&lt;=dC){ printEdge(matrix,tR++,tC++,dR--,dC--); } } public static void printEdge(int [][] matrix ,int tR ,int tC,int dR , int dC){ if(tR==dR){ for(int i=0;i&lt;=dC;i++){ System.out.print(matrix[tR][i]+\" \"); } }else if(tC==dC){ for(int i=0;i&lt;dR ;i++){ System.out.print(matrix[i][tC]+ \" \"); } }else { int curC=tC; int curR=tR; while (curC != dC){ System.out.print(matrix[tR][curC]+\" \"); curC++; } while (curR!=dR){ System.out.print(matrix[curR][dC]+\" \"); curR++; } while (curC != tC){ System.out.print(matrix[dR][curC]+\" \"); curC--; } while (curR!=tR){ System.out.print(matrix[curR][tC]+\" \"); curR--; } } } } “之”字形打印矩阵 上坐标（tR,tC）初始为（0,0），先向右走（tC++）,再向下走tR++ 下坐标类似 打印斜线方向用boolean判断 public class CircleDynamic { public static void main(String [] args){ int [][] m= {{1,2,3, 4}, {5,6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}; printMatrixZigZag(m); } public static void printMatrixZigZag(int [][] matrix){ int tR = 0; int tC = 0; int dR = 0; int dC = 0; int endR = matrix.length-1; int endC = matrix[0].length-1; boolean flag=false; while (tR!=matrix.length){ printZigZag(matrix,tR,tC,dR,dC,flag); tC=tC==endC?tC:tC+1; tR= tC==endC ?tR+1:tR; dR=dR==endR?dR:dR+1; dC=dR==endR?dC+1:dC; flag=!flag; } } public static void printZigZag(int [][] matrix,int tR,int tC,int dR,int dC,boolean flag ){ if(flag){ while (tR!=dR+1){ System.out.print(matrix[tR++][tC--]+\" \"); } }else { while (dR!=tC-1) { System.out.print(matrix[dR--][dC++]+\" \"); } } } } 自然数数组的排序给定一个长度为N的整型数组arr，其中有N个互不相等的自然数1N，请实现arr的排序，但是不要把下标0N-1位置上的数值通过直接赋值的方式替换成1~N。 要求：时间复杂度为O(N)，额外空间复杂度为O(1)。 思路： 1.从左向右遍历arr，假设当前遍历到i位置。 2.if arr[i]==i+1,不需要调整，继续遍历。 3.if arr[i]!=i+1,进行调整。 根据调整功能的方法不同，可以有不同的实现过程。 public class CircleDynamic { public static void main(String [] args){ int [] m= {1,2,5,3, 4}; m=sort(m); for(int i=0;i&lt;m.length;i++){ System.out.println(m[i]); } } public static int [] sort(int [] matrix){ for(int i=0;i&lt;matrix.length;i++){ while(matrix[i]!=i+1){ int temp=matrix[matrix[i]-1]; matrix[matrix[i]-1]=matrix[i]; matrix[i]=temp; } } return matrix; } } 奇数下标都是奇数或偶数下标都是偶数给定一个长度不小于2的数组arr，实现一个函数调整arr，要么使所有的偶数下标都是偶数，要么使所有的奇数下标都是奇数。 要求：时间复杂度为O(N),额外空间复杂度为O(1)。 算法解释： 最后位置的数是偶数，就替换前面的偶数下标，最后位置的是奇数，就替换前面的奇数下标，每替换一次，最后位置的数都是变化的，这样就都替换了。 public class CircleDynamic { public static void main(String [] args){ int [] m= {1,8,3,2,4,6}; modify(m); } public static void modify(int [] matrix){ if(matrix==null || matrix.length&lt;2){ return; } int even=0; int odd=1; int end=matrix.length-1; while (even&lt;=end &amp;&amp; odd&lt;=end){ if((matrix[end]&amp;1)==0){ swap(matrix,even,end); even+=2; }else { swap(matrix,odd,end); odd+=2; } } for(int i=0;i&lt;matrix.length;i++){ System.out.println(matrix[i]); } } public static void swap(int [] m,int index1,int index2){ int temp=m[index1]; m[index1]=m[index2]; m[index2]=temp; } } 子数组的最大累加和问题给定一个数组，返回子数组的最大累加和。 例如：arr=[1,-2,3,5,-2,6,-1]，所有子数组中，[3,5,-2,6]可以累加出最大的和12，return 12. 时间复杂度为O(N)，额外空间复杂度为O(1)。 如果arr中没有正数，产生的最大累加和一定是数组中的最大值。 如果arr中有正数，从左向右遍历arr，用变量cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。当cur&lt;0时，舍弃当前部分，令cur=0，表示重新从下一个数开始累加。当cur&gt;=0时，每一次的累加都可能是最大的累加和，所以，用另外一个变量max全程跟踪cur出现的最大值。 cur累加到负数就重新累加，max记录当前cur的最大值。 public class CircleDynamic { public static void main(String [] args){ int [] m= {1,-2,3,5,-2,6,-1}; maxSum(m); } public static void maxSum(int[] m){ if(m==null||m.length==0){ return; } int cur=0; int max=0; for(int i=0;i&lt;m.length;i++){ cur+=m[i]; if(max&lt;cur){ max=cur; } if(cur&lt;0){ cur=0; } } System.out.println(max); } } 子矩阵的最大累计和问题给定一个矩阵，其中的值有正、有负、有0。返回子矩阵的最大累计和。 如果一个矩阵一共有K行且限定必须含有K行元素的情况下，只要把矩阵中每一行的K个元素累加生成一个累加数组，然后求出这个数组的最大累加和，这个最大累加和就是必须含有K行元素的子矩阵中的最大累加和。 用i动态测试每一层往下累计的最大值，i+1实际上是把i层之上的全部不算。实现动态遍历 j和k是普通遍历 用s[k]存每次往下加的数字 cur加s[k]如果大就保存，如果不是最大就不存，如果小于0就清零。 public class Main { public static void main(String[] args) { int[][] m = {{-90, 48, 78}, {64, -40, 64}, {-81, -7, 66}}; maxSum(m); } public static void maxSum(int[][] m) { if (m == null || m.length == 0 || m[0].length == 0) { return; } int cur = 0; int max = Integer.MIN_VALUE; int []s=null; for (int i = 0; i &lt; m.length; i++) { s = new int[m[0].length]; for (int j = i; j &lt; m.length; j++) { cur = 0; for (int k = 0; k &lt; m[0].length; k++) { s[k] += m[j][k]; cur += s[k]; max = Math.max(max, cur); if (cur &lt; 0) { cur = 0; } } } } System.out.println(max); } } 在数组中找到一个局部最小的位置定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]为局部最小。如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小。如果0&lt;i&lt;N-1，arr[i]&lt;arr[i+1]&amp;&amp;arr[i]&lt;arr[i-1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任何两个相邻的数不相等。写一个函数，只需返回arr中任何一个局部最小出现的位置即可。 利用二分查找可以做到时间复杂度O(logN)、额外空间复杂度为O(1) public class Main { public static void main(String[] args) { int[] m = {90,78, 48, 78}; System.out.println(getLessIndex(m)); } public static int getLessIndex(int[] arr) { if(arr==null || arr.length==0){ return -1; } if(arr[0]&lt;arr[1]){ return 0; } if(arr[arr.length-1]&lt;arr[arr.length-2]){ return arr[arr.length-1]; } int left = 1; int right= arr.length-2; int mid=0; while (left&lt;right){ mid=(right+left)/2; if(arr[mid]>arr[mid-1]){ right=mid-1; }else if(arr[mid]>arr[mid+1]){ left=mid+1; }else { return mid; } } return left; } } 不包含本位置值的累乘数组给定一个整型数组，返回不包含本位置的累乘数组。 例如：arr=[2,3,1,4],返回[12,8,24,6],即除自己外，其他位置的类乘。 1.时间复杂度为O(N). 2.除需要返回的结果数组之外，额外空间复杂度为O(1). 使用除法： 结果数组记为res，所有数的乘积记为all。如果数组中不含0，则设置res[i]=all/arr[i]。如果数组中有一个0，对唯一的arr[i]==0的位置令res[i]=all,其他位置都是0。如果数组中0的数量大于1，那么res所有位置上的值都是0。 不使用除法： 1.生成两个长度和arr一样的新数组lr[]和rl[]，lr[i]=arr[0…i],rl[i]=arr[i…N-1]。 2.res[i]=lr[i-1]*rl[i+1] 3.res[0]=rl[1],res[N-1]=lr[N-2] 这里又额外使用了两个数组，可以通过res数组复用的方式省略掉这两个数组，先把res数组作为辅助计算的数组，然后把res调整成结果数组返回。 public class Main { public static void main(String[] args) { int[] m = {2,3, 1, 4}; m= product(m); for(int i=0;i&lt;m.length;i++){ System.out.println(m[i]); } } public static int [] product(int[] arr) { if(arr==null || arr.length==0){ return null; } int[] res=new int [arr.length]; res[arr.length-1]=1; for(int i=arr.length-2;i>=0;i--){ res[i]=res[i+1]*arr[i+1]; } int temp=1; for(int i=0;i&lt;arr.length;i++){ res[i]*=temp; temp*=arr[i]; } return res; } } 求最短通路值用一个整形矩阵matrix表示一个网络，1代表有路，0代表没路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右下角的最短通路值。 例如： 1 0 1 1 1 1 0 1 0 1 1 1 1 0 1 0 0 0 0 1 通路只有1条，由12个1组成，所以返回12。 使用宽度优先遍历即可，如果矩阵大小为NM，时间复杂度为O(NM)， 1.开始时生成map矩阵，map[i][j]的含义是从（0,0）位置走到（i，j）位置最短的路径值。然后将左上角位置（0,0）的行坐标和列坐标放入行队列rQ、列队列 cQ。 2.不断从队列弹出一个位置（r,c）,然后看这个位置的上下左右四个位置哪些在matrix上的值是1，这些都是能走的位置。 3.将那些能走的位置设置好各自在map中的值，即map[r][c]+1。同时将这些位置加入到rQ和cQ的中，用队列完成宽度优先遍历。 4.在步骤3中，如果一个位置走过，就不要重复走，这个逻辑可以根据一个位置在map中的值来确定，比如map[i][j]!=0，就可以知道这个位置之前走过。 5.一直重复步骤2~步骤4。直到遇到右下角位置，说明已经找到终点，返回终点在map中的值即可，如果rQ和cQ已经为空都没有遇到终点位置，return 0。 import java.util.LinkedList; import java.util.Queue; public class Main { public static void main(String[] args) { int[][] m = { {1,0,1,1,1}, {1,0,1,0,1}, {1,1,1,0,1}, {0,0,0,0,1} }; System.out.println(minPathValue(m)); } public static int minPathValue(int [][] m){ if(m==null || m.length==0|| m[0].length==0||m[0][0]!=1||m[m.length-1][m[0].length-1]!=1){ return 0; } int res=0; int [][] map=new int [m.length][m[0].length]; map[0][0]=1; Queue&lt;Integer> rQ=new LinkedList&lt;Integer>(); Queue&lt;Integer> cQ=new LinkedList&lt;Integer>(); rQ.add(0); cQ.add(0); int r=0; int c=0; while (!rQ.isEmpty()){ r=rQ.poll(); c=cQ.poll(); if( ( r==m.length-1 ) &amp;&amp; ( c==m[0].length-1)){ //查map路径 for(int i=0;i&lt;map.length;i++){ for (int j=0;j&lt;map[0].length;j++){ System.out.print(map[i][j]+\" \"); } System.out.println(\" \"); } //输出结果 return map[r][c]; } walkTo(map[r][c],r-1,c,m,map,rQ,cQ); walkTo(map[r][c],r+1,c,m,map,rQ,cQ); walkTo(map[r][c],r,c-1,m,map,rQ,cQ); walkTo(map[r][c],r,c+1,m,map,rQ,cQ); } return res; } public static void walkTo(int pre,int toR,int toC ,int [][]m , int [][] map,Queue&lt;Integer> rQ , Queue&lt;Integer> cQ ){ if (toR &lt; 0 || toR == m.length || toC &lt; 0 || toC == m[0].length || m[toR][toC] != 1 || map[toR][toC] != 0) { return; } map[toR][toC]=pre+1; rQ.add(toR); cQ.add(toC); } } ---res: 1 0 7 8 9 2 0 6 0 10 3 4 5 0 11 0 0 0 0 12 12 最长的可整合数组的长度如果一个数组再排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之后为[2,3,4,5,6],符合每相邻两个数差的绝对值为1，所以这个数组为可整合数组。 给定一个整型数组，请返回其中最大可整合子数组的长度。例如，[5,5,3,2,6,4,3]的最大可整合子数组为[5,3,2,6,4]，所以返回5. 一个数组中如果没有重复元素，并且如果最大值减去最小值，再加上1的结果等于元素的个数（max-min+1=元素个数）,那么这个数组就是可整合数组。 这样，验证一个数组是否是可整合数组的时间复杂度可以从第一种方法的O(NlogN)减少至O(1),整个过程的时间复杂度为O(N^2) 无需排序，仅仅只需要遍历比较大小 public class Main { public static void main(String[] args) { int[] m = { 5,5,3,2,6,4,3}; System.out.println(getLIL(m)); } public static int getLIL(int [] arr){ if(arr.length==0||arr==null){ return 0; } int max=0; int min=0; int len=0; HashSet&lt;Integer> set=new HashSet&lt;Integer>(); for(int i=0;i&lt;arr.length;i++){ max=Integer.MIN_VALUE; min=Integer.MAX_VALUE; for(int j=i;j&lt;arr.length;j++){ if(set.contains(arr[j])){ break; } set.add(arr[j]); max=Math.max(max,arr[j]); min=Math.min(min,arr[j]); if(max-min==j-i){ len=Math.max(len,j-i+1); } } set.clear(); } return len; } } 边界都是1的最大正方形大小给定一个M*N的矩阵，在这个矩阵中，只有0和1两种值，返回边框全是1的最大正方形的边长长度。 例如： ​ [0, 1, 1, 1, 1], ​ [0, 0, 1, 0, 1], ​ [0, 1, 1, 0, 1], ​ [0, 1, 1, 1, 1], ​ [0, 1, 0, 1, 1] 其中，边框全是1的最大正方形的大小为4。 解析： 1.正方形边长为0&lt;=size&lt;=Math.min(rows,cols); 2.边长为size时，左上角的坐标范围为 0&lt;=i&lt;=rows-size，0&lt;=j&lt;=cols-size; 3.使用预处理矩阵right和down，空间换时间，right[i][j]保存matrix[i][j]包括自己往右边有多少个1，同理down[i][j]。 3.对每一个左上角的边长为size的矩形判断边上是否全为1，发现有满足的直接返回当前size。 public class Main { public static void main(String[] args) { int[][] arr = { {0,1,1,1,1}, {0,1,0,0,1}, {0,1,0,0,1}, {0,1,1,1,1}, {0,1,0,1,1}}; System.out.println(getMaxSize(arr)); } public static int getMaxSize(int [][]m){ int [][] right=new int [m.length][m[0].length]; int [][] down= new int [m.length][m[0].length]; setBorderMap(m,right,down); for(int size=Math.min(m.length,m[0].length);size!=0;size--){ if(hasSizeOfBorder(size,right,down)){ return size; } } return 0; } public static void setBorderMap(int [][] m,int [][]right ,int [][]down){ int r=m.length; int c=m[0].length; if(m[r-1][c-1]==1){ right[r-1][c-1]=1; down[r-1][c-1]=1; } for(int i=r-2;i>=0;i--){ if(m[i][c-1]==1){ right[i][c-1]=1; down[i][c-1]=down[i+1][c-1]+1; } } for(int j=c-2;j>=0;j--){ if(m[r-1][j]==1){ right[r-1][j]=right[r-1][j+1]+1; down[r-1][j]=1; } } for(int i=r-2;i>=0;i--){ for (int j=c-2;j>=0;j--){ right[i][j]=right[i][j+1]+1; down[i][j]=down[i+1][j]+1; } } } public static boolean hasSizeOfBorder(int size ,int [][]right ,int [][] down){ for(int i=0;i&lt;right.length-size+1;i++){ for(int j=0;j&lt;right[0].length-size+1;j++){ if(right[i][j]>=size&amp;&amp;down[i][j]>=size &amp;&amp;right[i+size-1][j]>=size &amp;&amp;down[i][j+size-1]>=size) return true; } } return false; } } 需要排序的最短子数组长度package Array; /** * Created by zdmein on 2017/9/15. * 需要排序的最短子数组长度 * 思路： 用noMin 记录从右到左，可以遍历的，最左边开始需要重新排的 用noMax 记录从左到右，可以遍历的，最右边需要重新排的 1, 5,3,4,2, 6,7 返回 4 */ public class getMinLength1 { public static void main(String args[]){ int []arr={1,5,3,4,2,6,7}; System.out.println(getMinLength(arr)); } public static int getMinLength(int [] arr){ if(arr==null||arr.length&lt;2){ return 0; } int min=arr[arr.length-1]; int noMin=-1; for(int i=arr.length-2;i>=0;i--){ if(arr[i]>min){ noMin=i; }else { min=Math.min(arr[i],min); } } if(noMin==-1) return 0; int max=arr[0]; int noMax=-1; for(int i=1;i&lt;arr.length;i++){ if(arr[i]&lt;max){ noMax=i; }else { max=Math.max(max,arr[i]); } } return noMax-noMin+1; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"Java基础-2","slug":"Java基础-2","date":"2017-08-11T06:38:55.000Z","updated":"2017-09-15T07:13:28.414Z","comments":true,"path":"2017/08/11/java-ji-chu-2/","link":"","permalink":"http://www.zhoudamin.com/2017/08/11/java-ji-chu-2/","excerpt":"实干兴邦","text":"实干兴邦 J2SE基础 九种基本数据类型的大小，以及他们的封装类。 基本类型 大小(位) 字节 最小值 最大值 封装类 boolean - 1 - - Boolean byte 8 1 -128 127 Byte char 16 2 Unicode 0 Unicode 2^16-1 Character short 16 2 -2^15 2^15-1 Short int 32 4 -2^31 2^31-1 Integer float 32 4 Float double 64 8 Double long 64 8 -2^63 2^63-1 Long void - - - Void Switch能否用string做参数？JDK1.7之前是只支持int 或char JDK1.7开始支持String JDK1.5 开始支持 Enum 类 equals与==的区别“==” 用于基本数据类型的比较，判断引用是否指向堆内存的同一快地址。 equals 用于判断两个变量是否是对同一个对象的引用，即堆中的内容是否相同，返回值为布尔类型。 可以用equals方法检测两个字符串是否相等。 一定不能使用 == 运算符检测两个字符串是否相等！== 用来确定两个字符串是否放置在同一个位置上。 如果虚拟机始终将相同的字符串共享，就可以使用 == 运算符检测是否相等。但是实际上只有字符串常量是共享的，而+或者substring等操作产生的结果并不是共享的。 Object有哪些公用方法？ equals方法 Object类中的equals方法用于检测一个对象是否等于另外一个对象。 hashCode方法 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 toString方法 用于返回表示对象值的字符串。 Java的四种引用，强弱软虚，用到的场景 强引用 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收期绝不会回收它。 软引用 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些 对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可以用来实现内存敏感的高速缓存。 弱引用 弱引用与软引用的区别在于：只具有弱引用的对象具有更短暂的生命周期。 在垃圾回收器线程扫描它所管辖的内存区域过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。 不过，由于垃圾回收器是一个优先级很低的线程，因此不一样很快发现那些只有弱引用的对象。 如果你想引用一个对象，但这个对象具有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。 虚引用 虚引用不会决定对象的生命周期，如果一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何适合都可能被垃圾回收器回收。 总结： Java 4种引用的级别由高到低依次为： 强》软》弱》虚 Hashcode的作用hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的 ArrayList、LinkedList、Vector的区别ArrayList本质上是一个数组，当更多的元素添加到ArrayList中时，其大小会动态的增长，内部元素通过get和set方式进行访问。不是线程安全的。 LinkedList是一个双链表，因此在删除和添加元素的时候优于数组形式的ArrayList，但是在get和set方面弱于ArrayList； Vector几乎和ArrayList一样，但是Vector是线程安全的，在更多元素进来时，Vector每次请求双倍的空间，而ArrayList每次对size增长50%。 String、StringBuffer与StringBuilder的区别String是不可变类 StringBuffer是可变类 StringBuilder不是线程安全的 在执行效率方面，StringBuilder最高，StringBuffer次之，String最低 如果要操作的数据量比较小，应优先用String类 如果是在单线程下操作大量数据，应优先用StringBuilder类 如果在多线程下操作大量数据，应优先考虑StringBuffer类。 Map、Set、List、Queue、Stack的特点与用法 Map 键映射到值的对象。 一个映射不能包含重复的键，每个键最多只能映射到一个值。 某些映射实现可明确保证其顺序，如TreeMap类；另一些映射实现不保证顺序，如HashMap类。 Map中元素，可以将key序列，value序列单独抽取出来。 使用keySet()抽取key序列，将map中所有keys生成一个Set。 使用 values() 抽取value序列，将map中的所有values生成一个Collection。 为什么一个是Set，一个是Collection。因为key是独一无二的，value允许重复。 Set 一个不包含重复元素的Collection。 不可随机访问包含的元素 只能用lterator实现单向遍历 Set没有同步方法 List 可随机访问包含的元素 元素是有序的 可在任意位置增删元素 不管访问多少次，元素位置不变 允许重复元素 用Iterator实现单向遍历，也可用ListIterator实现双向遍历 Queue 先进先出 用offer()来加入元素 用poll()来获取并移出元素 peek()方法查看或使用前端元素 Queue实现通常不允许插入null元素 Stack 后进先出 Stack继承自Vector，是同步的 提供了push、pop、peek、empty方法 用法 如果涉及到堆栈，队列等操作，应该考虑用List 对于需要快速插入，删除元素，应该用LinkedList 如果需要快速随机访问元素，应该用ArrayList 如果单线程环境，考虑非同步的类，效率较高。 HashMap和HashTable的区别主要区别：线程安全，同步，速度 HashMap几乎等价于HashTable，除了HashMap是非同步的，并可以接受nullHashMap和ConcurrentHashMap的区别，HashMap的底层源码 HashMap的本质是数组加链表。根据key取得hash值，然后计算出数组下标，如果多个key对应到同一个下标，就用链表串起来，新插入的在前面。 ConcurrentHashMap在HashMap的基础上，将数据分为多个segment，默认16个，然后每次操作对一个segment加锁，避免多线程锁的几率，提高并发效率。 HashMap就是一个Entry数组，Entry数组中包含了键和值，其中next也是一个Entry对象，当hash冲突时，形成一个链表。 static class Entry&lt;K,V> implements Map.Entry&lt;K,V> { final K key; V value; Entry&lt;K,V> next; final int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V> n) { value = v; next = n; //hash值冲突后存放在链表的下一个 key = k; hash = h; } ......... } HashMap存储数据的put方法 public V put(K key, V value) { if (key == null) //如果键为null的话，调用putForNullKey(value) return putForNullKey(value); int hash = hash(key.hashCode());//根据键的hashCode计算hash码 int i = indexFor(hash, table.length); for (Entry&lt;K,V> e = table[i]; e != null; e = e.next) { //处理冲突的，如果hash值相同，则在该位置用链表存储 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { //如果key相同则覆盖并返回旧值 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null; } 当我们往HashMap中put元素时，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了，如果这个元素的位置上已经存在其他元素了，那么在同一个位子上的元素将会以链表的形式存放，新加入的放链表头，之前加入的放后面。 从HashMap中get元素时，首先计算key的hash值，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 如果没有与key相同的键，则调用addEntry方法创建一个Entry对象： void addEntry(int hash, K key, V value, int bucketIndex) { Entry&lt;K,V> e = table[bucketIndex]; //如果要加入的位置有值，将该位置原先的值设置为新entry的next,也就是新entry链表的下一个节点 table[bucketIndex] = new Entry&lt;>(hash, key, value, e); if (size++ >= threshold) //如果大于临界值就扩容 resize(2 * table.length); //以2的倍数扩容 } 扩容数据 void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable);//用来将原先table的元素全部移到newTable里面 table = newTable; //再将newTable赋值给table threshold = (int)(newCapacity * loadFactor);//重新计算临界值 } TreeMap、HashMap、LindedHashMap的区别。Collection包结构，与Collections的区别。try catch finally，try里有return，finally还执行么？ try中没有异常且try中有return try—finally—return try中有异常，try中有return try—catch—finally—return 总之finally永远执行 Excption与Error包结构。OOM你遇到过哪些情况，SOF你遇到过哪些情况。 Java面向对象的三个特征与含义。 Override和Overload的含义与区别 重写（Override） 重写是子类对父类的允许访问的方法的实现过程进行重新编写。 返回值和形参都不能改变。即外壳不变，重写内在实现。 重写的好处在于子类可以根据需要，定义特定于自己的行为。 public class LiftOff { public static void main(String args []){ Animal a= new Animal(); Animal b = new pig(); a.eat(); b.eat(); } } class Animal{ public void eat(){ System.out.println(\"Animal eat xx \"); } } class pig extends Animal{ public void eat(){ System.out.println(\"pig eat siliao\"); } } Animal eat xx pig eat siliao 重写规则： 参数列表必须完全与被重写方法相同（也就是说重写，不能添加写方法，不能添加参数。） 返回类型必须完全与被重写方法的返回类型相同 父类的成员方法只能被他的子类重写 声明为final的方法不能被重写 声明为static的方法不能被重写，但是能再次声明。 构造方法不能被重写 重载（Overload） 重载是在同一个类里，方法名字相同，参数不同，返回类型可相同也可不同的多个方法。 每个重载的方法都必须有一个独一无二的参数类型列表。 被重载的方法必须改变参数列表，被重载的方法可以改变返回类型，被重载的方法可以改变访问修饰符，方法能在同一个类中或在一个子类中被重载。 public class LiftOff { public int test(){ System.out.println(\"Overload1\"); return 1; } public void test(int a){ System.out.println(\"Overload1\"+ a); } public String test(String a1 , String a2){ System.out.println(\"Overload1\"+ a1+a2); return a1; } public static void main(String args []){ LiftOff t=new LiftOff(); System.out.println(t.test()); t.test(2); System.out.println(t.test(\"asd\",\"erf\")); } } Overload1 1 Overload12 Overload1asderf asd 重载和重写区别： 重载方法（Overload） 重写方法（Override） 参数列表 必须修改 不能改 返回类型 可以修改 不能改 异常 可以修改 可以减少或删除，不能抛出新的 访问修饰符 可以修改 只能降低限制，不能变高限制 限制又低到高： public、protected、private Interface与abstract类的区别如果一个类中包含抽象方法，那么这个类就是抽象类。类或方法声明为abstract 接口就是指一个方法的集合，接口中所有方法都没有方法体，接口通过关键字interface实现。 接口和抽象类的相同点： 都不能被实例化 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才才能被实例化。 不同点： 接口只有定义，其方法不能在接口中实现，只有实现接口的类才能实现接口中定义的方法；而抽象类可以有定义和实现，即其方法可以在抽象类中被实现。 接口需要实现（用implement），但抽象类只能被继承（用extends），一个类可以实现多个接口，但是一个类只可以继承一个抽象类，因此使用接口可以间接达到多重继承的目的。 接口强调特定功能的实现，”has - a” ；抽象类强调所属关系，”is - a “ 接口中定义的成员变量默认为 public static final ， 只能够有静态的不能被修改的数据成员，而且，必须给其赋值，其所以的成员方法都是public，abstract的，而且只能被这两个关键字修饰。而抽象类可以有自己的数据成员变量，也可以有非抽象的成员方法，而且，抽象类中的成员变量默认为default，当然也可以定义为private，protected，public。所以，当功能需要累积时，用抽象类，不需要累积时，用接口。 接口被运用于实现比较常用的功能，便于以后的维护；抽象类更倾向于充当公共类的角色，不适用于日后重新修改内部代码。 Static class 与non static class的区别java多态的实现原理实现多线程的两种方法：Thread与Runable线程同步的方法：sychronized、lock、reentrantLock等 锁的等级：方法锁、对象锁、类锁 Java中锁的机制： synchronized 在修饰代码块的时候需要一个reference对象作为锁的对象。 在修饰方法的时候默认是当前对象作为锁的对象。 在修饰类的时候默认是当前的Class对象作为锁的对象。 线程同步的方法： sychronized、lock、reentrantLock分析 方法锁（synchronized修饰方法时） 通过在方法声明中加入synchronized关键字来声明synchronized方法。 对象锁（synchronized修饰方法或代码块） 当一个对象中有synchronized method 或 synchronized block 的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁，如何此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁） 写出生产者消费者模式。ThreadLocal的设计理念与作用。ThreadPool用法与优势。Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。wait()和sleep()的区别他们都是一种使线程暂停执行的方法 区别： 原理不同。sleep()是Thread类的静态方法；wait()方法是Object类的方法。 对锁的处理机制不同。sleep不放，wait释放。 使用区域不同 sleep()必须捕获异常，wait()不需要 foreach与正常for循环效率对比Java IO与NIO。反射的作用与原理反射机制能够实现在运行时对类进行装在，因此能增加程序的灵活性。 功能： 得到一个对象所属的类； 获取一个类所有的成员变量和方法； 在运行时创建对象 在运行时调用对象的方法 Java创建对象的方式有几种 通过new实例化一个对象 通过反射机制创建对象 clone() 反序列化的方式 泛型常用特点，List能否转为List。解析XML的几种方式的原理与特点：DOM、SAX、PULL。Java与C++对比。Java8新特性 Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 设计模式：单例、工厂、适配器、责任链、观察者等等JNI的使用Java里有很多很杂的东西，有时候需要你阅读源码，大多数可能书里面讲的不是太清楚，需要你在网上寻找答案。 推荐书籍：《java核心技术卷I》《Thinking in java》《java并发编程》《effictive java》《大话设计模式》 JVM 内存模型以及分区，需要详细到每个区放什么。 堆里面的分区：Eden，survival from to，老年代，各自的特点。 对象创建方法，对象的内存分配，对象的访问定位。 GC的两种判定方法：引用计数与引用链。 GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？ GC收集器有哪些？CMS收集器与G1收集器的特点。 Minor GC与Full GC分别在什么时候发生？ 几种常用的内存调试工具：jmap、jstack、jconsole。 类加载的五个过程：加载、验证、准备、解析、初始化。 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。 分派：静态分派与动态分派。 JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。 推荐书籍：《深入理解java虚拟机》 TCP/IP OSI与TCP/IP各层的结构与功能，都有哪些协议。 TCP与UDP的区别。 TCP报文结构。 TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用。 TCP拥塞控制。 TCP滑动窗口与回退N针协议。 Http的报文结构。 Http的状态码含义。 Http request的几种类型。 Http1.1和Http1.0的区别 Http怎么处理长连接。 Cookie与Session的作用于原理。 电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。 Ping的整个过程。ICMP报文是什么。 C/S模式下使用socket通信，几个关键函数。 IP地址分类。 路由器与交换机区别。 网络其实大体分为两块，一个TCP协议，一个HTTP协议，只要把这两块以及相关协议搞清楚，一般问题不大。 推荐书籍：《TCP/IP协议族》 项目关于项目，这部分每个人的所做的项目不同，所以不能具体的讲。项目不再与好与不好，在于你会不会包装，有时候一个很low的项目也能包装成比较高大上的项目，多用一些专业名词，突出关键字，能使面试官能比较容易抓住重点。在聊项目的过程中，其实你的整个介绍应该是有一个大体的逻辑，这个时候是在考验你的表达与叙述能力，所以好好准备很重要。 面试官喜欢问的问题无非就几个点： XXX（某个比较重要的点）是怎么实现的？ 你在项目中遇到的最大的困难是什么，怎么解决的？ 项目某个部分考虑的不够全面，如果XXXX，你怎么优化？ XXX（一个新功能）需要实现，你有什么思路？ 其实你应该能够预料到面试官要问的地方，请提前准备好，如果被问到没有准备到的地方，也不要紧张，一定要说出自己的想法，对不对都不是关键，主要是有自己的想法，另外，你应该对你的项目整体框架和你做的部分足够熟悉。 SpringBoot的主要特性其他你应该问的问题 面试里，最后面完之后一般面试官都会问你，你有没有什么要问他的。其实这个问题是有考究的，问好了其实是有加分的，一般不要问薪资，主要应该是：关于公司的、技术和自身成长的。 以下是我常问的几个问题，如果需要可以参考： 贵公司一向以XXX著称，能不能说明一下公司这方面的特点？ 贵公司XXX业务发展很好，这是公司发展的重点么？ 对技术和业务怎么看？ 贵公司一般的团队是多大，几个人负责一个产品或者业务？ 贵公司的开发中是否会使用到一些最新技术？ 对新人有没有什么培训，会不会安排导师？ 对Full Stack怎么看？ 你觉得我有哪些需要提高的地方？ 知识面除了基础外，你还应该对其他领域的知识有多少有所涉猎。对于你所熟悉的领域，你需要多了解一点新技术与科技前沿，你才能和面试官谈笑风生。 软实力什么是软实力，就是你的人际交往、灵活应变能力，在面试过程中，良好的礼节、流畅的表达、积极的交流其实都是非常重要的。很多公司可能不光看你的技术水平怎么样，而更看重的是你这个人怎么样的。所以在面试过程中，请保持诚信、积极、乐观、幽默，这样更容易得到公司青睐。 很多时候我们都会遇到一个情况，就是面试官的问题我不会，这时候大多数情况下不要马上说我不会，要懂得牵引，例如面试官问我C++的多态原理，我不懂，但我知道java的，哪我可以向面试官解释说我知道java的，类似的这种可以往相关的地方迁移（但是需要注意的是一定不要不懂装懂，被拆穿了是很尴尬的），意思就是你要尽可能的展示自己，表现出你的主动性，向面试官推销自己。 还有就是遇到智力题的时候，不要什么都不说，面试官其实不是在看你的答案，而是在看你的逻辑思维，你只要说出你自己的见解，有一定的思考过程就行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://www.zhoudamin.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"读书笔记之《程序员代码面试指南（递归和动态规划）》","slug":"读书笔记之《程序员代码面试指南（递归和动态规划）》","date":"2017-08-10T00:49:54.000Z","updated":"2018-08-03T14:54:10.234Z","comments":true,"path":"2017/08/10/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-di-gui-he-dong-tai-gui-hua/","link":"","permalink":"http://www.zhoudamin.com/2017/08/10/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-di-gui-he-dong-tai-gui-hua/","excerpt":"递归：将问题分解成子问题求解，从较小的问题逐渐逼近原始问题，很多时候只需要在f（n-1）中加入或移除某些东西或稍作修改就可以求得f（n） 递归 是 考虑所有的情况，一般使用搜索（DFS /BFS）来实现。 一般可以使用记忆化搜索进行优化的递归算法，我们可以使用DP来进行优化。","text":"递归：将问题分解成子问题求解，从较小的问题逐渐逼近原始问题，很多时候只需要在f（n-1）中加入或移除某些东西或稍作修改就可以求得f（n） 递归 是 考虑所有的情况，一般使用搜索（DFS /BFS）来实现。 一般可以使用记忆化搜索进行优化的递归算法，我们可以使用DP来进行优化。 斐波那契系列问题经典斐波那契问题代码就不写了，这个基本都会，需要注意的是： 递归方法的时间复杂度是：$O(2^N)$ 顺序计算的时间复杂度是：$O(N)$ 二阶递推数列的时间复杂度是：$O(logN)$ 大牛小牛问题假设农场中成熟的母牛每年只会生1头小母牛，并且永远不会死。 第一年农场有1只成熟的母牛，从第二年开始，母牛开始生小母牛。 每只小母牛3年之后成熟又可以生小母牛。 给定整数N，求出N年后牛的数量。 【举例】N=6，第1年1头成熟母牛记为a； 第2年a生了新的小母牛，记为b，总牛数为2； 题目最优解第3年a生了新的小母牛，记为c，总牛数为3； 第4年a生了新的小母牛，记为d，总牛数为4。 第5年b成熟了，a和b分别生了新的小母牛，总牛数为6； 第6年c也成熟了，a、b和c分别生了新的小母牛，总牛数为9，返回9。 【要求】对以上所有的问题，请实现时间复杂度O(logN)的解法。 有 $F(N)=F(N-1)+F(N-3)$ 用一个矩阵乘法，且状态矩阵为$3*3$ public int c3(int n){ if(n&lt;1){ return 0; } if(n==1||n==2||n=3){ return n; } int base[][]={{1,1,0},{0,0,1},{1,0,0}}; //构造矩阵 int [][] res = matrixPower(base,n-3); //矩阵n-3次方 return 3*res[0][0]+2*res[1][0]+res[2][0]; } 矩阵的最小路径和题目描述 有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。 给定一个矩阵map及它的行数n和列数m，请返回最小路径和。 EG： 1 、3 、5 、9 8 、1 、3、4 5、0、6、1 8、8、4、0 经典动态规划方法最终生成的dp矩阵如下： 1、4、9、18 9、5、8、12 14、5、11、12 22、13、15、12 因为第一行和第一列只有一条路走，就是一直沿着走； 第二行，第二列开始就是选择从上往下还是从左往右走； 每次都把每一步的最小路径加起来 时间复杂度$O(MN)$ ，空间复杂度$O(MN)$ public class CircleDynamic { public static void main(String [] args){ int [][] m= {{1,3,5,9}, {8,1,3,4}, {5,0,6,1}, {8,8,4,0}}; System.out.println(minPathSum1(m)); } public static int minPathSum1(int [] []m){ if (m == null || m.length == 0 || m[0]==null || m[0].length==0) { return 0; } int row=m.length; int col=m[0].length; int [][] dp=new int [row][col]; dp[0][0]=m[0][0]; for(int i=1;i&lt;row;i++){ dp[i][0]=dp[i-1][0]+m[i][0]; } for(int j=1;j&lt;col;j++){ dp[0][j]=dp[0][j-1]+m[0][j]; } for(int i=1;i&lt;row;i++){ for(int j=1;j&lt;col;j++){ dp[i][j]=Math.min(dp[i][j-1]+m[i][j],dp[i-1][j]+m[i][j]); } } return dp[row-1][col-1]; } } 压缩空间方法时间复杂度$O(M*N)$ ，空间复杂度$O(min ( M,N ))$ public class CircleDynamic { public static void main(String [] args){ int [][] m= {{1,3,5,9}, {8,1,3,4}, {5,0,6,1}, {8,8,4,0}}; System.out.println(minPathSum1(m)); } public static int minPathSum1(int [] []m){ if (m == null || m.length == 0 || m[0]==null || m[0].length==0) { return 0; } int more = Math.max(m.length,m[0].length); int less= Math.min(m.length,m[0].length); boolean rowmore=more==m.length; int arr[] = new int [less]; arr[0]=m[0][0]; for(int i=1;i&lt;less;i++){ arr[i]=arr[i-1]+(rowmore?m[0][i]:m[i][0]); } for(int i=1;i&lt;more;i++){ arr[0]=arr[0]+(rowmore?m[i][0]:m[0][i]); for(int j=1;j&lt;less;j++){ arr[j]=Math.min(arr[j],arr[j-1])+(rowmore?m[i][j]:m[j][i]); } } return arr[less-1]; } } 换钱的最少货币数题目： 给定数组arr, arr中所有的值都为正数且不重复。每个值代表一中面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求组成aim的最少货币数。 思路: 如果arr的长度为N, 则生成一个行数为N, 列数为aim+1的动态规划表dp[N][aim+1], dp[i][j]的含义为:在可以任意使用arr[0…i]货币的情况下，组成j所需的最小张数。 设: arr=[5,2,3,1] aim = 5 1.dp[0..N-1][0]的值表示找钱数为0时需要的最少张数，所以全设为0。（矩阵的第一列） 0 0 0 0 0 0 dp= 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ​ 2.dp[0][0…aim]的值表示只能使用arr[0]货币也就是5的情况下，找0 ,1,2,3,4,5的钱的情况下。其中无法找开的一律设为32位的最大值，记为max. 0 max max max max 1 dp= 0 0 0 3.剩下的位置依次从左到右，再从上到下计算。假设计算到(i,j)位置，dp[i][j]的值可能来自下面的情况: 完全不使用当前货币arr[i]情况系的最少张数，即dp[i-1][j]的值 只使用一张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-arr[i]]+1 其中 j-arr[i]的值为使用了一张arr[i]后，还需要找多少钱。 i-1是指使用arr[i]之前的钱来兑换 只使用两张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-2*arr[i]]+2 只使用三张当前货币arr[i]的情况下的最少张数，即dp[i-1][j-3*arr[i]]+3 所有情况中，取最小的纸张数。所以: dp[i][j] = min{dp[i-1][j], dp[i-1][j-k*arr[i]]} + k ==&gt; dp[i][j] = min{dp[i-1][j], min{dp[i-1][j-x*arr[i]]+x (x &gt;= 1)}} ==&gt; 设x-1 = y &gt;= 0 ==&gt; x = y +1代入得 dp[i][j] = min{dp[i-1][j], min{dp[i-1][j-arr[i]-y*arr[i]+y+1 (y&gt;=0)}} 又因为min{dp[i-1][j-arr[i]-y*arr[i]+ y (y&gt;=0)] =&gt; dp[i][j-arr[i]] 因为其中 dp[i-1][j-y*arr[i]+y] = dp[i][j] 最终有:dp[i][j] = min{dp[i-1][j], dp[i][j-arr[i]+1]} 如果 j-arr[i] &lt; 0,即发生越界。 说明arr[i]太大了，用一张都会超出钱数j，所以令dp[i][j]=dp[i-1][j]即可。 0 max max max max 1 dp = 0 max 1 max 2 1 0 max 1 1 2 1 0 1 1 1 2 1 public class CircleDynamic { public static void main(String [] args){ int [] m= {5,2,5,3}; int aim = 15; System.out.println(minCoins(m,aim)); } public static int minCoins(int [] arr,int aim){ if(arr==null || arr.length==0|| aim&lt;0){ return -1; } int n=arr.length; int max=Integer.MAX_VALUE; int [][] dp=new int [n][aim+1]; for(int j=1;j&lt;aim;j++){ dp[0][j]=max; if(j-arr[0]>=0 &amp;&amp; dp[0][j-arr[0]]!=max){ dp[0][j]=dp[0][j-arr[0]]+1; } } int left = 0; for(int i=1;i&lt;n ;i++){ for(int j=1;j&lt;aim;j++){ left=max; if(j-arr[i]>=0&amp;&amp;dp[i][j-arr[i]]!=max){ left=dp[i][j-arr[i]]+1; } dp[i][j]=Math.min(left,dp[i-1][j]); } } for(int i=0;i&lt;n ;i++){ for(int j=0;j&lt;aim;j++){ System.out.print(dp[i][j]+ \" \" ); if(j==aim-1){ System.out.println(\" \"); } } } return dp[n-1][aim] !=max ?dp[n-1][aim-1]:-1; } } Result: 0 2147483647 2147483647 2147483647 2147483647 1 2147483647 2147483647 2147483647 2147483647 2 2147483647 2147483647 2147483647 2147483647 0 2147483647 1 2147483647 2 1 3 2 4 3 2 4 3 5 4 0 2147483647 1 2147483647 2 1 3 2 4 3 2 4 3 5 4 0 2147483647 1 1 2 1 2 2 2 3 2 3 3 3 4 4 数组中最长的连续数字序列给定一个无序的整数序列， 找最长的连续数字序列。 例如： 给定[100, 4, 200, 1, 3, 2], 最长的连续数字序列是[1, 2, 3, 4]。 输出4. public class Main { public static void main(String[] args) { int[] arr = {100,4,200,1,3,2}; System.out.println(longestConsecutive(arr)); } public static int longestConsecutive(int [] arr){ if(arr.length==0||arr==null){ return 0; } int max=1; HashMap&lt;Integer,Integer> map=new HashMap&lt;Integer,Integer>(); for(int i=0;i&lt;arr.length;i++){ if(!map.containsKey(arr[i])){ map.put(arr[i],1); if(map.containsKey(arr[i]-1)){ max=Math.max(max,merge(map,arr[i]-1,arr[i])); } if(map.containsKey(arr[i]+1)){ max=Math.max(max,merge(map,arr[i],arr[i]+1)); } } } return max; } public static int merge(HashMap&lt;Integer,Integer> map,int less,int more){ //计算左边有几个数 int left=less-map.get(less)+1; //计算右边有几个数 int right=more+map.get(more)-1; //合计 int len=right-left+1; //标记 map.put(left,len); map.put(right,len); return len; } } 龙于地下城游戏问题给定一个二维数组map，含义是一张地图，例如： {{-2,-3,3}, {-5,-10,1}, {0,30,-5}} 游戏规则如下： 骑士从左上角出发，每次只能向下或者向右，直到右下才能见到公主； 每个格子代表骑士遭遇的事件，如果是负数，代表消耗血量，如果是正数，代表血瓶； 骑士走到任何一个位置，血量都不能低于1。 为了让骑士见到公主，骑士初始血量最少为多少？ 只能往下或往右，需要一个辅助数组dp[][] 来计算。那么可以逆着来计算。 public class Main { public static void main(String[] args) { int[][] arr = { {-2,-3,3}, {-5,-10,1}, {0,30,-5} }; System.out.println(minHP(arr)); } public static int minHP(int [] [] arr){ if(arr.length==0||arr==null){ return 1; } int row=arr.length; int col=arr[0].length; int[][] dp=new int [row--][col--]; dp[row][col]=arr[row][col]>0?1:1-arr[row][col]; for(int j=col-1;j>=0;j--){ dp[row][j]=Math.max(dp[row][j+1]-arr[row][j],1); //计算初步差异值 } int right=0; int down=0; for(int i=row-1;i>=0;i--){ dp[i][col]=Math.max(dp[i+1][col]-arr[i][col],1); //计算初步上下差异值 for(int j=col-1;j>=0;j--){ right=Math.max(dp[i][j+1]-arr[i][j],1); //向右走 down=Math.max(dp[i+1][j]-arr[i][j],1); //向下走 dp[i][j]=Math.min(right,down); //取最小的差异值 } } return dp[0][0]; } } 最长公共子串问题所谓最长公共子串，比如 串 str1=”1AB2345CD” 串 str2=”12345EF”; 则它们的最长公共子串为串 “2345”,输出4 public class Main { public static void main(String[] args) { String str1=\"1AB2345CD\"; String str2=\"12345EF\"; System.out.println(getdp(str1,str2)); } public static int getdp(String str1,String str2){ int dp[][]=new int [str1.length()][str2.length()]; for(int i=0;i&lt;str1.length();i++){ if(str1.charAt(i)==str2.charAt(0)){ dp[i][0]=1; } } for(int j=1;j&lt;str2.length();j++){ if(str1.charAt(0)==str2.charAt(j)){ dp[0][j]=1; } } int max=0; for(int i=1;i&lt;str1.length();i++){ for(int j=1;j&lt;str2.length();j++){ if(str1.charAt(i)==str2.charAt(j)){ dp[i][j]=dp[i-1][j-1]+1; } System.out.print(dp[i][j]+\" \"); max=Math.max(max,dp[i][j]); } System.out.println(\"\"); } return max; } } --- 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 3 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 跳跃游戏package RecursiveAndDynamic; /** * Created by zdmein on 2017/9/14. * 跳跃游戏 给出一个非负整数数组，你最初定位在数组的第一个位置。 数组中的每个元素代表你在那个位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 给出数组A = [2,3,1,1,4]，最少到达数组最后一个位置的跳跃次数是2 (从数组下标0跳一步到数组下标1，然后跳3步到数组的最后一个位置，一共跳跃2次) 思路：贪心算法; * 从第一个数开始, 寻找可以一个可以跳最远的点; * 例1：3 1 2 4 1 0 0 * 1.从第一个位置0,可以跳到位置1和位置2和位置3; * 2.如果跳到位置1,那么最远就可以跳到位置(1+1); * 3.如果跳到位置2,那么最远就可以跳到位置(2+2); * 4.如果跳到位置3,那么最远就可以跳到位置(3+4); * 5.故选择跳到位置3 ,重复1.2.3步; * * 算法分析： * 1.如果选择跳到位置3 ,就无法跳到位置2和位置3, 那么会不会因此错过最优解？ 答：不会！ * 2.因为任意位置1和位置2能到达的位置, 位置3都可以到达; * 3.故不会错过最优解; */ public class jump1 { public static void main(String [] args){ int [] arr={3,2,3,1,1,4}; System.out.println(jump(arr)); } public static int jump(int [] arr){ if(arr==null||arr.length==0){ return 0; } int jump=0; int cur=0; int next=0; for (int i=0;i&lt;arr.length;i++){ if(cur&lt;i){ jump++; cur=next; } next=Math.max(next,i+arr[i]); } return jump; } } ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《操作系统概念》","slug":"读书笔记之《操作系统概念》","date":"2017-08-09T06:54:40.000Z","updated":"2017-08-09T09:00:12.665Z","comments":true,"path":"2017/08/09/du-shu-bi-ji-zhi-cao-zuo-xi-tong-gai-nian/","link":"","permalink":"http://www.zhoudamin.com/2017/08/09/du-shu-bi-ji-zhi-cao-zuo-xi-tong-gai-nian/","excerpt":"非常小型的操作系统，如篇首的小恐龙所使用的驱动手持设备的操作系统，是Silberschatz、Galvin和Gagne第七版《操作系统概念》中的一种前沿应用。通过保留最新的，保持有意义的，并改编为课程最需要的内容，这本引导市场潮流的教材继续指导着操作系统课程。","text":"非常小型的操作系统，如篇首的小恐龙所使用的驱动手持设备的操作系统，是Silberschatz、Galvin和Gagne第七版《操作系统概念》中的一种前沿应用。通过保留最新的，保持有意义的，并改编为课程最需要的内容，这本引导市场潮流的教材继续指导着操作系统课程。 第二部分 进程管理第四章 进程进程状态 创建、运行、等待、就绪、终止 进程：一个具有单个控制线程的执行程序。 第五章 线程线程：是CPU使用的基本单元 多线程编程优点： 响应度高 资源共享 经济 多处理器体系结构的利用 多线程模型 多对一 Many-to-one 优点： 线程之间切换快 可以用用户自己的方式管理线程库 缺点： 如果一个线程执行了阻塞系统调用，那么整个系统就会阻塞。 一对一 One - to - one 优点：更好的并发能力 缺点：创建一个用户线程就需要创建一个相应的内核线程 多对多 Many-to - many 优点：没有many-to-One和 one-to -one的缺点 线程池 在进程开始时创建一定数量的线程，并放入到池中坐以等待工作。 如果池中没有可用的线程，那么服务器会一直等待直到有空线程为止。 优点： 用现有线程处理请求要比等待创建新的线程要快 线程池限制了在任何时候可存在线程的数量 第七章 进程同步多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关，称为竞争条件。 两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。当出现这样的状态时，这些进程称为死锁（deadlocked）。 第八章 死锁 必要条件 互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。 占有并等待：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。 非抢占：资源不能被抢占；即，只有进程完成其任务之后，才会释放其资源。 循环等待：一组进程，循环等待下一个的资源。 所有四个条件必须同时满足才会出现死锁。 为了预防死锁，要确保这四个必要条件中的一个不成立。 死锁恢复 进程终止 终止所有死锁进程 一次只终止一个进程直到取消死锁循环为止 资源抢占 选择一个牺牲品 回滚 饥饿 从理论上来说，有三种方法可以处理死锁： 使用一些协议来预防或避免死锁，确保系统永远都不会进到死锁状态。 允许系统进入死锁状态，检测死锁，并恢复。 忽视所有问题，并假设系统中永远都不会出现死锁。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"读书","slug":"读书","permalink":"http://www.zhoudamin.com/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.zhoudamin.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"读书笔记之《程序员代码面试指南（栈和队列）》","slug":"读书笔记之《程序员代码面试指南（栈和队列）》","date":"2017-08-09T01:33:15.000Z","updated":"2018-08-03T14:54:36.720Z","comments":true,"path":"2017/08/09/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-zhan-he-dui-lie/","link":"","permalink":"http://www.zhoudamin.com/2017/08/09/du-shu-bi-ji-zhi-cheng-xu-yuan-dai-ma-mian-shi-zhi-nan-zhan-he-dui-lie/","excerpt":"第一章、栈和队列","text":"第一章、栈和队列 有getMin功能的栈使用两个栈，一个用来保存当前栈中的元素，记为stackData，一个用来保存每一步的最小值，即为stackMin. public class MyStack { public static void main (String [] args){ int [] Arr = {1,2,3}; push(Arr[0]); push(Arr[1]); System.out.println(pop()+\" \" + getMin()); } private static Stack&lt;Integer > stackData=new Stack&lt;Integer>(); private static Stack &lt;Integer> stackMin =new Stack&lt;Integer>(); public static void push(int newNum){ stackData.push(newNum); if(stackMin.isEmpty()){ stackMin.push(newNum); }else if(newNum&lt;stackMin.peek()){ stackMin.push(newNum); } } public static int pop(){ if(stackData.peek()==stackMin.peek()){ stackMin.pop(); } return stackData.pop(); } public static int getMin(){ if(stackMin.isEmpty()){ throw new RuntimeException(\"you stack is empty.\"); } return stackMin.peek(); } } 由两个栈组成的队列 一个栈stackPush专门用来存数据 一个栈stackPop专门用来取数据 每次取数据前stackPop必须清空 每次stackPush压入数据到stackPop中时，必须一次性全部压入 public class MyStack { private static Stack&lt;Integer > stackPush =new Stack&lt;Integer>(); private static Stack &lt;Integer> stackPop =new Stack&lt;Integer>(); public static void add(int pushInt){ stackPush.push(pushInt); } public static int poll(){ if(stackPush.isEmpty()&amp;&amp;stackPop.isEmpty()){ throw new RuntimeException(\"Queue is Empty ！\"); }else if(stackPop.isEmpty()){ while (!stackPush.isEmpty()){ stackPop.push(stackPush.pop()); } } return stackPop.pop(); } public static int peek(){ if(stackPush.isEmpty()&amp;&amp;stackPop.isEmpty()){ throw new RuntimeException(\"Queue is Empty ！\"); }else if(stackPop.isEmpty()){ while (!stackPush.isEmpty()){ stackPop.push(stackPush.pop()); } } return stackPop.peek(); } } 用栈解决汉诺塔问题修改后的汉诺塔问题不能从左直接到右，也不能从右直接到左，必须通过中间； 左、中、右三个地点依次记为LS，LM，RS； 则仅有四个动作：LS–&gt;LM 、LM–&gt;LS 、LM–&gt;RS 、RS–&gt;LM 动作：某一个栈（from）把栈顶元素弹出 ，然后压入到另一个栈里（to），作为这一个栈（to）的栈顶。 两个原则： 一个动作能发生的先决条件是不违反小压大的原则。 还一个是相邻不可逆原则。 意思是，L-&gt;M ，那么M-&gt;L，就重复了，如果要最小步法完成，必须不走重复步。 核心 游戏的第一个动作一定是L-&gt;M 在走出任何最小步数过程中，四个动作，只有一个动作不违反原则，其余三个一定会违反。 public class MyStack { public enum Action { No , LToM , MToL , MToR , RToM } public static int hannoProblem(int num , String left , String mid ,String right){ Stack&lt;Integer > ls =new Stack&lt;Integer>(); Stack &lt;Integer> ms =new Stack&lt;Integer>(); Stack &lt;Integer> rs =new Stack&lt;Integer>(); ls.push(Integer.MAX_VALUE); ms.push(Integer.MAX_VALUE); rs.push(Integer.MAX_VALUE); for( int i=num ;i>0;i--){ ls.push(i); } Action [] record = {Action.No}; int step = 0; while (rs.size()!=num+1){ step+= fStackTotStack(record,Action.MToL,Action.LToM,ls,ms , left , mid); step+= fStackTotStack(record,Action.LToM,Action.MToL,ms,ls , mid , left); step+= fStackTotStack(record,Action.RToM,Action.MToR,ms,rs , mid , right); step+= fStackTotStack(record,Action.MToR,Action.RToM,rs,ms , right, mid); } return step; } public static int fStackTotStack(Action [] record , Action preNoAct , Action nowAct , Stack&lt;Integer> fStack , Stack&lt;Integer> tStack, String from , String to){ if(record[0] != preNoAct &amp;&amp; fStack.peek()&lt;tStack.peek()){ tStack.push(fStack.pop()); System.out.println(\"Move\"+\" \"+tStack.peek()+\" \"+\"from\" +\" \"+ from +\" \"+ \"to\" +\" \"+ to); record[0]=nowAct; return 1; } return 0; } public static void main (String [] args){ int num=2; String left=\"left\"; String mid =\"mid\"; String right= \"right\"; System.out.println(hannoProblem(num,left,mid,right)); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"读书笔记之《深入理解Java虚拟机》","slug":"读书笔记之《深入理解Java虚拟机》","date":"2017-08-08T02:35:12.000Z","updated":"2018-08-03T14:55:24.082Z","comments":true,"path":"2017/08/08/du-shu-bi-ji-zhi-shen-ru-li-jie-java-xu-ni-ji/","link":"","permalink":"http://www.zhoudamin.com/2017/08/08/du-shu-bi-ji-zhi-shen-ru-li-jie-java-xu-ni-ji/","excerpt":"","text":"第13章 线程安全与锁优化分类1. 不可变不可变的对象一定是线程安全的 不可变带来的安全性是最简单和最纯粹的 基本数据类型：final 对象：java.lang.String 2. 绝对线程安全在Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。 Java.util.Vector是一个线程安全的容器，因为它的add()、get()、size()这类方法都是被synchronized修饰的。 在多线程中，还需在调用端做额外的同步措施。 3. 相对线程安全通常意义上讲的线程安全 在Java中，大部分的线程安全类都属于这种类型，如Vector、HashTable、Collection、的synchronizedCollection()方法包装的集合等。 4. 线程兼容指对象本身并不是线程安全的，但是可以在同步端正确使用同步手段保证对象在并发环境中可以安全地使用。 Java API 中大部分的类都是属于线程兼容的，如Vector 和 HashTable相对应的集合类ArrayList 和 HashMap 等。 5. 线程对立指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。 一个线程对立的例子是Thread类的 suspend() 和 resume() 方法。 线程安全实现方法互斥同步Mutual Exclusion &amp; Synchronization 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信息量的时候）线程使用。 互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信息量（Semaphore）都是主要的互斥实现方式。 互斥是因，同步是果。互斥是方法，同步是目的。 互斥同步最主要的问题是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。 Synchronized在Java中，最基本的互斥同步手段就是synchronized关键字 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成） ReentrantLock重人锁 原生语法层面的互斥锁。 等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。只需要多次调用newCondition()方法即可。 非阻塞同步乐观的并发策略 先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施。 测试并设置 获取并增加 交换 比较并交换 加载链接/条件存储 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/tags/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}]},{"title":"读书笔记之《Java编程思想》","slug":"读书笔记之《Java编程思想》","date":"2017-08-08T01:07:57.000Z","updated":"2017-08-10T09:47:54.678Z","comments":true,"path":"2017/08/08/du-shu-bi-ji-zhi-java-bian-cheng-si-xiang/","link":"","permalink":"http://www.zhoudamin.com/2017/08/08/du-shu-bi-ji-zhi-java-bian-cheng-si-xiang/","excerpt":"","text":"17. 容器Set存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。 Set接口不保证维护元素的次序 Map映射表（关联数组）的基本思想是维护的是键-值（对）关联，因此可以用键来查找值。 基本方法 Map.put() Map.get() 21. 并发 阻塞： 如果程序中的某个任务因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或线程阻塞了。 Java的线程机制是抢占式的。 一个线程就是在进程中的一个单一的顺序控制流，因此，单个进程可以拥有多个并发执行的任务。 LiftOff任务将显示发射之前的倒计时： public class LiftOff implements Runnable{ protected int countDown = 10; private static int taskCount =0; private final int id=taskCount++; public LiftOff(){ this.countDown=countDown; } public String status(){ return \"#\"+id +\"(\"+(countDown>0 ? countDown:\"LiftOff ！\")+\").\"; } public void run(){ while(countDown-->0){ System.out.println(status()); Thread.yield(); } } } /*************************************************************/ public class ThreadPro { public static void main(String [] args){ for(int i=0;i&lt;5;i++) new Thread(new LiftOff()).start(); System.out.println(\"Waiting for LiftOff !\"); } } 执行器（Executor） Executor允许你管理异步任务的执行，而无需显式地管理线程的生命周期。 优先级 线程的优先级将该线程的重要性传递给了调度器。 尽管CPU处理现有线程集的顺序使不确定的，但是调度器将倾向于让优先权最高的线程先执行。 另外会让优先级较低的线程执行的频率较低，故而优先权不会导致死锁。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"读书","slug":"读书","permalink":"http://www.zhoudamin.com/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"Java基础-1","slug":"Java基础-1","date":"2017-08-07T07:54:27.000Z","updated":"2017-09-12T03:11:44.992Z","comments":true,"path":"2017/08/07/java-ji-chu-1/","link":"","permalink":"http://www.zhoudamin.com/2017/08/07/java-ji-chu-1/","excerpt":"Java基本功","text":"Java基本功 Java是否存在内存泄露内存泄露是指一个不再被程序使用的对象或变量还在内存中占有存储空间。 如果开发人员忘记释放已分配的内存就会造成内存泄露。 在Java中，判断一个内存空间是否符合垃圾回收机制标准有两个： 给对象赋予了null，以后再没使用过 给对象赋予了新值，重新分配了内存空间 内存泄露主要有两种情况： 在堆中申请的空间没有被释放 对象已经不再使用，但还是在内存中保留着 Java中的垃圾回收机制可以解决情况1，所以内存泄露主要是情况2 在Java中，引起内存泄露的主要原因有： 静态集合类 各种连接，如数据库连接、网络联结以及IO连接等 监听器 变量不合理的作用域 单例模式可能会造成内存泄露 Java中的堆和栈有什么区别堆和栈都是内存中存放数据的地方 堆主要用来存放对象，栈用来执行程序 栈的存取速度比堆快 堆可以在运行中动态的分配内存 当main()方法退出后，栈中的变量会被回收 Java Collections 框架是什么Java Collections框架中包含了大量集合接口、这些接口的实现类、操作他们的算法。 Set表示数学意义上的集合概念。特点是集合中的元素不能重复 HashSet TreeSet ：容器中的元素是有序的 List又称为有序的Collection。 按对象进入的顺序保存对象，多以它能对列表中的每个元素的插入和删除位置进行精准的控制。 同时，它可以保存重复的对象。 Map提供了一个从键映射到值的数据结构。它用于保存键值对，其中值可以重复，键是唯一的。 HashMap 是基于散列表实现的，采用对象 HashCode 可以进行快速查询。 LinkedHashMap 采用列表来维护内部的顺序。 TreeMap 基于红黑树的数据结构来实现的，内部元素是按需排列的。 cookie和session区别 cookie保存在客户端，数据存放在客户的浏览器上；session机制采取保存在服务器端的方案，数据存放在服务器上。 cookie安全性不够，session信息存放在服务器，因此较为安全。 cookie性能更高 单个cookie保存的数据大小不能超过4 KB，而session不存在这个问题。 Hibernate优点 提高开发效率 可以完全采用面向对象的思想，不需要关心数据库的关系模型 有很好的移植性 支持透明持久化 使用Hibernate提高性能 延迟加载 缓存技术 优化查询语句 分页机制当数据量很大时，如果一次性的把数据取出来，不仅浪费时间，还消耗大量的内存 采用分页机制使得查询的结果集中数据量减少了，同时也降低了内存的消耗，因此可以显著降低响应时间，有助于提高系统的可用性，增强用户体验。 方法： 框架自带分页机制 SQL语句实现分页 GC自动检测对象的作用域，自动的把不再被使用的存储空间释放掉。 作用 分配内存 确保被引用的对象不被错误的回收 回收不再被引用的对象的内存空间 垃圾回收算法 引用计数法：缺点是无法处理循环引用问题 标记-清除法：标记所有从根节点开始的可达对象，缺点是会造成内存空间不连续，不连续的内存空间的工作效率低于连续的内存空间 复制算法：将内存空间分成两块，每次将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块。适用于新生代（存活对象少，垃圾对象多） 标记-压缩算法：清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清除边界所有空间。适用于老年代。 分代 死锁当线程需要持有多个锁时，就有可能产生死锁。 线程A当前持有互斥锁lock1，线程B当前持有互斥锁lock2。 A想要lock2，B也想要lock1，互相试图获取对方的，又不肯先释放自己的，就陷入了无尽的等待/阻塞。 这种情况成为死锁。 ArrayList、Vector、LinkedList区别 容器 动态 扩充大小 同步？ 安全？ 效率 ArrayList 可伸缩数组 1.5倍 非同步 不是线程安全 索引or在末端增删元素效率高 Vector 可伸缩数组 2倍 绝大多数方法同步 线程安全 索引or在末端增删元素效率高、多线程 LinkedList 可伸缩数组 非线程安全 双向列表实现，插入数据高，指定位置插入or删除元素效率高 排序算法对比 排序算法 最好时间 平均时间 最坏时间 辅助存储 稳定性 备注 简单选择排序 $O（n^2）$ $O（n^2）$ $O（n^2）$ $O（1）$ 不稳定 n小时较好 直接插入排序 $O（n）$ $O（n^2）$ $O（n^2）$ $O（1）$ 稳定 大部分已有序时较好 冒泡排序 $O（n）$ $O（n^2）$ $O（n^2）$ $O（1）$ 稳定 n小时较好 希尔排序 $O（n）$ $O（nlogn）$ $O（n^s）(1&lt;s&lt;2)$ $O（1）$ 不稳定 s是所选分组 快速排序 $O（nlogn）$ $O（nlogn）$ $O（n^2）$ $O（logn）$ 不稳定 n大时较好 堆排序 $O（nlogn）$ $O（nlogn）$ $O（nlogn）$ $O（1）$ 不稳定 n大时较好 归并排序 $O（nlogn）$ $O（nlogn）$ $O（nlogn）$ $O（n）$ 稳定 n大时较好 什么是值传递和引用传递 值传递：方法调用时，实参会把它的值传递给形参，形参用实参的值初始化一个临时的存储单元，因此值一样，存储单元不一样，形参的改变不会影响实参。 引用传递：在方法调用时，传递的是对象，形参与实参指向同一块存储单元，对形参的改变就会改变实参。 面向对象的三个基本元素 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 多态： 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 是否可以主动通知JVM进行垃圾回收？由于垃圾回收器的存在，Java语言没有提供给开发人员释放已分配内存的方法，开发人员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 但是开发可以调用System.gc()方法来“通知”垃圾回收器运行，当然，JVM也不会马上运行。 Java中堆和栈的区别 栈内存主要用来存放基本数据类型和引用变量；堆内存用来存放运行时创建的对象 堆主要用来存放对象，栈主要用来执行程序 线程状态有哪些，它们之间是如何转换的 New（新建）：刚创建，还没调用start方法 Runnable（可运行）：可以在Java虚拟机中运行的状态 Blocked（被阻塞）：当一个线程获取其他线程的内部对象锁而不得 Waiting（等待）：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态 Timed waiting（计时等待）：有超时参数的方法会让线程进入计时等待，如果超时或者出现通知，会切换到可运行状态 Terminated（被终止）：因为run方法正常退出或因为没有捕获的异常终止了run方法而死亡 线程与进程的区别，各有什么优缺点线程：是指程序在执行过程中，能够执行程序代码的一个执行单元。4个状态：运行，就绪，挂起，结束。 进程：是指一段正在执行的程序。 创建一个线程比创建一个进程所要的资源少。 当你在浏览器输入一个网址，如http://www.taobao.com，按回车之后发生了什么？请从技术的角度描述，如浏览器、网络（UDP、TCP、HTTP等），以及服务器等各种参与对象上由此引发的一系列活动，请尽可能的涉及到所有的关键技术点。 1.DNS域名解析：浏览器缓存、系统缓存、路由器、ISP的DNS服务器、根域名服务器。把域名转化成IP地址。 2.与IP地址对应的服务器建立TCP连接，经历三次握手：SYN，ACK、SYN，ACK 3.以get，post方式发送HTTP请求，get方式发送主机，用户代理，connection属性，cookie等 4.获得服务器的响应，显示页面 ----------------------------------------------------------- 1 查缓存 2 DNS解析 3 获取ip 4 建立tcp连接 5 发http数据 6 接受http数据并解析 7 close ------------------------------------------------------------------- 1、根据域名查询域名的IP。浏览器缓存->操作系统缓存->本地域名服务器缓存->域名服务器。 2、得到IP后发起基于TCP的HTTP请求。如果浏览器存储了该域名下的cookie，那么会把cookie放入HTTP请求头里。 3、TCP被包装为IP包，通过网络（可能经过很多路由器、交换机）发送到IP地址对应的服务器。这个服务器可能只是一个反向代理服务器，如果是，则HTTP请求被转交给内网中真实的某一个服务器（可能有多个服务器）。 4、服务器分析HTTP请求，生成HTTP响应（可能是HTML、图片等）后，将响应发送给客户端浏览器。 5、浏览器得到响应后，根据响应内容显示结果。如果响应的是图片，则将图片”画“在浏览器页面上；如果是HTML，则渲染HTML并”画“在浏览器页面上，在分析HTML时，若发现引用了其他资源，例如css、图片等，则发起HTTP请求，得到响应资源。 linux中cat、more、less命令区别均可用来查看文件内容 命令 区别 功能对比 cat 一次性显示整个文件的内容，还可以将多个文件连接起来显示，常与重定向符号配合使用，适用于文件内容少的情况 一般 more 一般用于显示文件内容超过一屏的内容，提供翻页的功能。提供分页显示。 强 less 一般用于显示文件内容超过一屏的内容，提供翻页的功能。翻页、跳转、查找。 更强 索引的作用及代价？如何建好索引？索引的原理 Hash算法 算法：二分查找算法，冒泡排序、选择排序算法、插入排序、归并、希尔、快排算法 锁：乐观锁和悲观锁 什么情况下会产生死锁？如何避免死锁？ JVM GC：介绍垃圾回收机制，垃圾回收算法。 JAVA的反射机制 Java集合类有哪些，分别在哪些场景使用 Linux下如何快速查找某个文件 Linux下如何设置环境变量 Linux下如何查看TCP连接状态LISTEN： 侦听来自远方的TCP端口的连接请求 listen SYN-SENT： 再发送连接请求后等待匹配的连接请求 syn-sent SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认 syn-received ESTABLISHED： 代表一个打开的连接 FIN-WAIT-1： 等待远程TCP连接中断请求，或先前的连接中断请求的确认 FIN-WAIT-2： 从远程TCP等待连接中断请求 CLOSE-WAIT： 等待从本地用户发来的连接中断请求 CLOSING： 等待远程TCP对连接中断的确认 LAST-ACK： 等待原来的发向远程TCP的连接中断请求的确认 TIME-WAIT： 等待足够的时间以确保远程TCP接收到连接中断请求的确认 CLOSED： 没有任何连接状态 简述一次HTTP请求的基本流程 什么是JDBC，为什么需要什么是JDBC？实现原理是什么？ Get和Post的区别 Cookie和Session的区别，分别用于什么场景 为什么需要编码？UTF-8和GBK是如何进行编码的 分别介绍下JDK，JRE和JVM HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别 索引有什么用？如何建索引？ ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。 equals方法实现 面向对象 线程状态，BLOCKED和WAITING有什么区别 JVM如何加载字节码文件 JVM GC，GC算法。 什么情况会出现Full GC，什么情况会出现yong GC。 JVM内存模型Java内存模型，指Java程序在运行时内存的模型，而Java代码运行在Java虚拟机上，所以也就指Java虚拟机的运行时内存模型。 Java运行时数据区 事务的实现原理 技术深度 有没有看过JDK源码，看过的类实现原理是什么。 HTTP协议 TCP协议 一致性Hash算法 JVM如何加载字节码文件 类加载器如何卸载字节码 IO和NIO的区别，NIO优点 Java线程池的实现原理，keepAliveTime等参数的作用。 HTTP连接池实现原理 数据库连接池实现原理 数据库的实现原理 技术框架 看过哪些开源框架的源码 为什么要用Redis，Redis有哪些优缺点？Redis如何实现扩容？ Netty是如何使用线程池的，为什么这么使用 为什么要使用Spring，Spring的优缺点有哪些 Spring的IOC容器初始化流程 Spring的IOC容器实现原理，为什么可以通过byName和ByType找到Bean Spring AOP实现原理 消息中间件是如何实现的，技术难点有哪些 系统架构 如何搭建一个高可用系统 哪些设计模式可以增加系统的可扩展性 介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。 抽象能力，怎么提高研发效率。 什么是高内聚低耦合，请举例子如何实现 什么情况用接口，什么情况用消息 如果AB两个系统互相依赖，如何解除依赖 如何写一篇设计文档，目录是什么 什么场景应该拆分系统，什么场景应该合并系统 系统和模块的区别，分别在什么场景下使用 分布式系统 分布式事务，两阶段提交。 如何实现分布式锁 如何实现分布式Session 如何保证消息的一致性 负载均衡 正向代理（客户端代理）和反向代理（服务器端代理） CDN实现原理 怎么提升系统的QPS和吞吐量 实战能力 有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。 开发中有没有遇到什么技术问题？如何解决的 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。 新浪微博是如何实现把微博推给订阅者 Google是如何在一秒内把搜索结果返回给用户的。 12306网站的订票系统如何实现，如何保证不会票不被超卖。 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。 软能力 如何学习一项新技术，比如如何学习Java的，重点学习什么 有关注哪些新的技术 工作任务非常多非常杂时如何处理 项目出现延迟如何处理 和同事的设计思路不一样怎么处理 如何保证开发质量 职业规划是什么？短期，长期目标是什么 团队的规划是什么 能介绍下从工作到现在自己的成长在那里 基础概念 多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改为同步。 并发：在 操作系统 中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个 处理机 上运行。其中两种并发关系分别是同步和互斥 互斥：进程间相互排斥的使用临界资源的现象，就叫互斥。 同步： 进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。 其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。 并行：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。 多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。 constructor在一个对象被new时执行 @java中关于继承的描述：一个子类只能继承一个父类; 继承具有传递性;父类一般具有通用性，子类更具体。 当一个对象不再被引用后就成为垃圾可以被回收，但是线程就算没有被引用也可以独立运行的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://www.zhoudamin.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Spring-Boot-之-排序算法","slug":"Spring-Boot-之-排序算法","date":"2017-08-06T01:49:25.000Z","updated":"2018-04-25T03:37:39.045Z","comments":true,"path":"2017/08/06/spring-boot-zhi-pai-xu-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2017/08/06/spring-boot-zhi-pai-xu-suan-fa/","excerpt":"一些网站内容排序算法","text":"一些网站内容排序算法 前言-网页排序核心思想 交互越好，排名越好 时间越新，排名越好 Hacker Newshttps://news.ycombinator.com/ $$Score=(P-1)/(T+2)^G$$P：投票数，-1是把自己投的过滤掉T：发布到现在的时间间隔，单位小时，+2防止除数太小G：重力加速度，分值根据时间降低速率 ![微信图片_20170806095556](E:\\Program Files\\DarminBlog\\public\\Picture\\微信图片_20170806095556.png) Reddithttps://www.reddit.com/ t = (time of entry post) - (Dec 8, 2005)x = upvotes - downvotes y = {1 if x &gt; 0, ​ 0 if x = 0, ​ -1 if x &lt; 0)z = {1 if x &lt; 0, otherwise x} $$f(t,y,z)=log(z) + (y * t)/45000$$时间是最重要的权重，由于流量比较大，所以对于高赞文章有所优势，适合新闻类排序 StackOverflowhttp://stackoverflow.com (log(Qviews)*4) + ((Qanswers * Qscore)/5) + sum(Ascores) -------------------------------------------------------- ((QageInHours+1) - ((QageInHours - Qupdated)/2)) ^ 1.5 Qviews：问题浏览数，通过log来平滑Qanswer：问题回答数，有回答的题目才是好问题Qscore：问题赞踩差，赞的越多，问题越好sum（Ascores）：回答赞踩差，回答的越多问题越好QageInHours：题目发布时间差，时间越久排名越后Qupdated：最新的回答时间，越新关注度越高 IMDBhttp://www.imdb.com/chart/top 加权排名(WR) = (v ÷(v+m)) ×R + (m ÷(v+m)) ×C R = 某电影投票平均分 v = 有效投票人数 m = 最低投票人数，1250 C = 所有电影平均值 投票人数越多，越偏向于用户打分值，防止冷门电影小数人高分导致的高分 http://www.imdb.com/help/show_leaf?votestopfaq Marathon Match Rating System适合用于比赛中，互相排名。 https://community.topcoder.com/longcontest/?module=Static&amp;d1=support&amp;d2=ratings document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.zhoudamin.com/tags/SpringBoot/"}]},{"title":"Spring Boot 之 Redis详解","slug":"Spring-Boot-之-Redis详解","date":"2017-08-01T13:30:48.000Z","updated":"2017-08-16T08:50:08.246Z","comments":true,"path":"2017/08/01/spring-boot-zhi-redis-xiang-jie/","link":"","permalink":"http://www.zhoudamin.com/2017/08/01/spring-boot-zhi-redis-xiang-jie/","excerpt":"Redis是目前业界使用最广泛的内存数据存储。 Redis支持丰富的数据结构，同时支持数据持久化。 Redis还提供一些类数据库的特性，比如事务，HA，主从库。 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。","text":"Redis是目前业界使用最广泛的内存数据存储。 Redis支持丰富的数据结构，同时支持数据持久化。 Redis还提供一些类数据库的特性，比如事务，HA，主从库。 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis特点Redis支持数据的持久化，可以将内存中的数据保存到磁盘中，重启的时候可以再次加载使用 Redis不仅仅支持简单的key-value类型的数据，同时还支持list，set，zset，hash等数据结构的存储 Redis支持数据的备份 支持主从同步，数据存在内存中，性能卓越。 Redis数据结构String（字符串）String是redis最基本的类型，一个key对应一个value 127.0.0.1:6379> set name \"runoob\" OK 127.0.0.1:6379> get name \"runoob\" set 和 get 命令，key为name，value为runoob。 List（列表）双向列表，适用于最新列表，关注列表 列表是最简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部或者尾部 127.0.0.1:6379> lpush runoob redis (integer) 1 127.0.0.1:6379> lpush runoob mongodb (integer) 2 127.0.0.1:6379> lpush runoob damin (integer) 3 127.0.0.1:6379> lrange runoob 0 10 1) \"damin\" 2) \"mongodb\" 3) \"redis\" lpush存入链表，lrange列出链表 Set（集合）适用于无顺序的集合，点赞点踩，抽奖，已读，共同好友 Redis的Set是String类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找，都是$O(1)$ $asdd$命令：添加一个string元素命令到key对应的set集合中，成功返回1，如果元素已经存在，返回0，key对应的set不存在返回错误。 127.0.0.1:6379> SADD damin redis (integer) 1 127.0.0.1:6379> SADD damin mysql (integer) 1 127.0.0.1:6379> SADD damin mongodb (integer) 1 127.0.0.1:6379> SADD damin mysql (integer) 0 127.0.0.1:6379> SMEMBERS damin 1) \"mongodb\" 2) \"mysql\" 3) \"redis\" SortedSet（有序集合）排行榜，优先队列 和set一样，zadd也是不允许重复的成员 Hash（哈希）对象属性，不定长属性数 是一个键名对集合 hash特别适合用于存储对象 127.0.0.1:6379> HMSET user:1 username runoob password runoob points 200 OK 127.0.0.1:6379> HGETALL user:1 1) \"username\" 2) \"runoob\" 3) \"password\" 4) \"runoob\" 5) \"points\" 6) \"200\" Redis HMSET , HGETALL 命令，user:1为键值 KV：单一数值，验证码，PV，缓存 启动Redis1、用cmd命令转到redis根目录下 2、执行cmd命令：redis-server redis.windows.conf Redis基础基本指令功能 /** * Created by nowcoder on 2016/7/30. */ @Service public class JedisAdapter implements InitializingBean { private static final Logger logger = LoggerFactory.getLogger(JedisAdapter.class); private JedisPool pool; public static void print(int index, Object obj) { System.out.println(String.format(\"%d, %s\", index, obj.toString())); } public static void main(String[] argv) { Jedis jedis = new Jedis(\"redis://localhost:6379/9\"); jedis.flushDB(); // get set jedis.set(\"hello\", \"world\"); print(1, jedis.get(\"hello\")); //输出hello对应的world jedis.rename(\"hello\", \"newhello\"); //newhello替代hello print(1, jedis.get(\"newhello\")); //指向输出world jedis.setex(\"hello2\", 1800, \"world\"); print(1,jedis.get(\"hello2\")); jedis.set(\"pv\",\"100\"); //点踩功能 jedis.incr(\"pv\"); //加1 jedis.incrBy(\"pv\",5); //加5 print(2,jedis.get(\"pv\")); jedis.decrBy(\"pv\",2); //减2 print(2,jedis.get(\"pv\")); print(3,jedis.keys(\"*\")); //输出所有表 String listName =\"list\"; jedis.del(listName); for(int i=0;i&lt;10;i++){ jedis.lpush(listName,\"a\"+String.valueOf(i)); //添加进表 } print(4,jedis.lrange(listName,0,12)); //输出范围0-12的内容 print(4,jedis.lrange(listName,0,2)); //输出范围0-2的内容 print(5,jedis.llen(listName)); //输出长度 print(6,jedis.lpop(listName)); //弹出最前一个的内容 print(10,jedis.linsert(listName,BinaryClient.LIST_POSITION.AFTER,\"a4\",\"dd\")); print(11,jedis.lrange(listName,0,11)); String userKey = \"userxx\"; jedis.hset(userKey,\"name\",\"jim\"); jedis.hset(userKey,\"age\",\"12\"); jedis.hset(userKey,\"phone\",\"1562225555\"); print(12,jedis.hget(userKey,\"name\")); //取出对应信息 print(13,jedis.hgetAll(userKey)); //全部取出 jedis.hdel(userKey,\"phone\"); print(14,jedis.hgetAll(userKey)); //取出全部信息 print(15,jedis.hexists(userKey,\"email\")); //有没有email print(16,jedis.hexists(userKey,\"age\")); //有没有age print(17,jedis.hkeys(userKey)); //输出key print(18,jedis.hvals(userKey));// 输出值 jedis.hsetnx(userKey,\"school\",\"zju\"); //添加学校属性 jedis.hsetnx(userKey,\"name\",\"yxy\"); //如果存在则不改写 print(19,jedis.hgetAll(userKey)); //set String likeKey1=\"commentLike1\"; String likeKey2=\"commentLike2\"; for(int i=0;i&lt;10 ; ++i){ jedis.sadd(likeKey1,String.valueOf(i)); jedis.sadd(likeKey2,String.valueOf(i*i)); } print(20,jedis.smembers(likeKey1)); print(21,jedis.smembers(likeKey2)); print(22,jedis.sunion(likeKey1,likeKey2));//求并 print(23,jedis.sdiff(likeKey1,likeKey2));//我有你无 print(24,jedis.sinter(likeKey1,likeKey2)); //求公共的 print(25,jedis.sismember(likeKey1,\"12\")); print(25,jedis.sismember(likeKey2,\"16\")); //查询对象在不在里面 jedis.srem(likeKey1,\"5\"); print(27,jedis.smembers(likeKey1)); User user = new User(); user.setName(\"xx\"); user.setPassword(\"ppp\"); user.setHeadUrl(\"a.png\"); user.setSalt(\"salt\"); user.setId(1); print(46,JSONObject.toJSONString(user)); jedis.set(\"user1\",JSONObject.toJSONString(user)); String value = jedis.get(\"user1\"); User user2=JSON.parseObject(value,User.class); print(47,user2); int k=2; } @Override public void afterPropertiesSet() throws Exception { } } Redis事务redis事务可以一次执行多个命令，并且有以下2个属性： 事务是一个单独的隔离操作，事务中所有命令都会序列化，按顺序地执行，事务在执行的过程中，不会被其他客户端发送过来的命令请求所中断 事务是一个原子操作，事务中的命令要不全部被执行，要不都不执行 一个事务从开始到执行有三个阶段 ： 开始事务 命令入队 执行事务 实例： 先以MULTI开始一个事务，然后将多个命令入队到事务中，最后由EXEC命令触发事务，一并执行事务中的所有命令 127.0.0.1:6379> MULTI OK 127.0.0.1:6379> set book-name \"Java Thinking in\" QUEUED 127.0.0.1:6379> GET book-name QUEUED 127.0.0.1:6379> SADD tag \"JAVA\" \"Coding\" QUEUED 127.0.0.1:6379> SMEMBERS tag QUEUED 127.0.0.1:6379> EXEC 1) OK 2) \"Java Thinking in\" 3) (integer) 2 4) 1) \"JAVA\" 2) \"Coding\" 事务相关命令： DISCARD：取消事务discard，放弃执行事务中所有命令 EXEC：执行所有事务块内的命令 exec MULTI：标记一个事务块的开始multi UNWATCH：取消watch命令对所有key的监视 Redis脚本Redis脚本用Lua解释器来执行脚本，脚本执行的命令为EVAL 127.0.0.1:6379> EVAL \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\" 2 key1 key2 first second 1) \"key1\" 2) \"key2\" 3) \"first\" 4) \"second\" Redis 连接Redis连接服务器 127.0.0.1:6379> AUTH \"password\" (error) ERR Client sent AUTH, but no password is set //没有密码，所以... 127.0.0.1:6379> ping PONG 127.0.0.1:6379> 连接命令： AUTH password：验证密码是否正确 PONG：查看服务器是否运行 ECHO message ： 打印字符串 QUIT：关闭当前连接 SELECT index ：切换到指定的数据库 Java使用Redis添加jedis.jar 包 然后就可以嗨起来了 连接服务器import redis.clients.jedis.Jedis; public class RedisJava { public static void main(String [] args){ //连接本地的Redis服务 Jedis jedis =new Jedis(\"localhost\"); System.out.println(\"连接成功\"); //查看服务器是否运行 System.out.println(\"服务正在运行：\"+jedis.ping()); } } --- 连接成功 服务正在运行：PONG 字符串import redis.clients.jedis.Jedis; public class RedisJava { public static void main(String [] args){ //连接本地的Redis服务 Jedis jedis =new Jedis(\"localhost\"); System.out.println(\"连接成功\"); jedis.set(\"damin\",\"zhoudm.com\"); System.out.println(\"redis 存储的字符串为：\"+jedis.get(\"damin\")); } } --- 连接成功 redis 存储的字符串为：zhoudm.com Redis Java Listimport redis.clients.jedis.Jedis; import java.util.List; public class RedisJava { public static void main(String [] args){ //连接本地的Redis服务 Jedis jedis =new Jedis(\"localhost\"); System.out.println(\"连接成功\"); jedis.lpush(\"zhoudm\",\"zhoudm.com\"); jedis.lpush(\"zhoudm\",\"baidu.com\"); jedis.lpush(\"zhoudm\",\"360.com\"); jedis.lpush(\"zhoudm\",\"google.com\"); List&lt;String> list=jedis.lrange(\"zhoudm\",0,3); for(int i=0;i&lt;list.size();i++) { System.out.println(\"列表为：\" + list.get(i)); } } } --- 连接成功 列表为：google.com 列表为：360.com 列表为：baidu.com 列表为：zhoudm.com Redis Java Keysimport redis.clients.jedis.Jedis; import java.util.Set; import java.util.Iterator; public class RedisJava { public static void main(String [] args){ //连接本地的Redis服务 Jedis jedis =new Jedis(\"localhost\"); System.out.println(\"连接成功\"); Set&lt;String> keys=jedis.keys(\"*\"); Iterator&lt;String> it=keys.iterator(); while(it.hasNext()){ String key = it.next(); System.out.println(key); } } } --- 连接成功 zhoudm spring:session:sessions:7ff2fe7e-9454-48a1-b44c-9b5f6b7b1507 book-name spring:session:sessions:9a02f60c-fd16-49b5-9977-08446f4ffff5 spring:session:sessions:f1312270-95cf-4d19-a88d-5af26b03a61c spring:session:sessions:expires:9a02f60c-fd16-49b5-9977-08446f4ffff5 spring:session:expirations:1504881480000 user:1 spring:session:sessions:f31624a8-b014-4768-826d-8b5b484b63a7 collector spring:session:sessions:expires:f1312270-95cf-4d19-a88d-5af26b03a61c spring:session:sessions:expires:f31624a8-b014-4768-826d-8b5b484b63a7 name spring:session:expirations:1504409460000 damin runoob tag spring:session:expirations:1505295120000 spring:session:expirations:1504252440000 spring:session:sessions:expires:7ff2fe7e-9454-48a1-b44c-9b5f6b7b1507 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"框架","slug":"框架","permalink":"http://www.zhoudamin.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.zhoudamin.com/tags/SpringBoot/"}]},{"title":"Spring Boot 之 项目业务逻辑","slug":"Spring-Boot-之-项目业务逻辑","date":"2017-08-01T02:54:17.000Z","updated":"2018-04-25T03:37:33.373Z","comments":true,"path":"2017/08/01/spring-boot-zhi-xiang-mu-ye-wu-luo-ji/","link":"","permalink":"http://www.zhoudamin.com/2017/08/01/spring-boot-zhi-xiang-mu-ye-wu-luo-ji/","excerpt":"业务逻辑","text":"业务逻辑 开发流程 Database Column Model：模型定义，和数据库相匹配 DAO：数据读取 Service：服务包装 Controller：业务入口 Test 评论CommentDAO 添加评论 addComment 根据一个实体选出全部评论 selectCommentByEntity 选一个实体下有多少评论 Service 添加评论 得到评论数 删除评论-controller调用Service，Service更新状态就可以了 Controller 增加评论 POSTquestionId 是多少content 是多少评论内容也需要过滤一次( Html &amp; 自己写的算法)hostHolder！=null 说明你是登陆的没登陆？：要不登陆、要不匿名 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.zhoudamin.com/tags/SpringBoot/"}]},{"title":"Spring Boot 之 Web Notes","slug":"Spring-Boot-之-Web-Notes","date":"2017-07-31T06:50:41.000Z","updated":"2018-04-25T06:41:06.537Z","comments":true,"path":"2017/07/31/spring-boot-zhi-web-notes/","link":"","permalink":"http://www.zhoudamin.com/2017/07/31/spring-boot-zhi-web-notes/","excerpt":"一些Web的笔记！","text":"一些Web的笔记！ 开发流程 Database Column Model：模型定义，和数据库匹配 Dao：数据读取 Service：服务包装 Controller：业务入口 Test solr官方网站： http://lucene.apache.org/solr/ …\\bin&gt; solr -e cloud -noprompt 搜索语法： +包含关键词 -不需要某关键词 云模式solr start -e cloud –noprompt 单机solr start solr create_collection wenda 关闭 solr stop -all 核心概念： Document：每个被索引的文档 Field：文档里的各个属性值 IKAnanlyzer分词配置（managed-schema） &lt;fieldTypename=\"text_ik\" class=\"solr.TextField\"> &lt;!--索引时候的分词器--> &lt;analyzer type=\"index\"> &lt;tokenizerclass=\"org.wltea.analyzer.util.IKTokenizerFactory\" useSmart=“false\"/> &lt;filter class=\"solr.LowerCaseFilterFactory\"/> &lt;/analyzer> &lt;!--查询时候的分词器--> &lt;analyzer type=\"query\"> &lt;tokenizerclass=\"org.wltea.analyzer.util.IKTokenizerFactory\" useSmart=“true\"/> &lt;/analyzer> &lt;/fieldType> &lt;field name=\"question_title\" type=\"text_ik\" indexed=\"true\" stored=\"true\" multiValued=\"true\"/> &lt;field name=\"question_content\" type=\"text_ik\" indexed=\"true\" stored=\"true\" multiValued=\"true\"/> 数据库数据导入 solrconfig.xml &lt;requestHandlername=\"/dataimport\" class=\"org.apache.solr.handler.dataimport.DataImportHandler\"> &lt;lstname=\"defaults\"> &lt;strname=\"config\">data-config.xml&lt;/str> &lt;/lst> &lt;/requestHandler> data-config.xml &lt;dataConfig> &lt;dataSource type=\"JdbcDataSource\" driver=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost/wenda\" user=\"root\" password=\"nowcoder\"/> &lt;document> &lt;entity name=\"question\" query=\"select id,title,content from question\"> &lt;field column=\"content\" name=\"question_content\"/> &lt;field column=\"title\" name=\"question_title\"/> &lt;/entity> &lt;/document> &lt;/dataConfig> 敏感词前缀树• 根节点不包含字符，除根节点外每一个节点都只包含一个字符• 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串• 每个节点的所有子节点包含的字符都不相同 过滤掉符号避免敏感词中间空格就识别不出了 @Service public class SensitiveService implements InitializingBean { private static final Logger logger = LoggerFactory.getLogger(SensitiveService.class); /** * 默认敏感词替换符 */ private static final String DEFAULT_REPLACEMENT = \"***\"; private class TrieNode { /** * true 关键词的终结 ； false 继续 */ private boolean end = false; /** * key下一个字符，value是对应的节点 */ private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); /** * 向指定位置添加节点树 */ void addSubNode(Character key, TrieNode node) { subNodes.put(key, node); } /** * 获取下个节点 */ TrieNode getSubNode(Character key) { return subNodes.get(key); } boolean isKeywordEnd() { return end; } void setKeywordEnd(boolean end) { this.end = end; } public int getSubNodeCount() { return subNodes.size(); } } /** * 根节点 */ private TrieNode rootNode = new TrieNode(); /** * 判断是否是一个符号 */ private boolean isSymbol(char c) { int ic = (int) c; // 0x2E80-0x9FFF 东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (ic &lt; 0x2E80 || ic &gt; 0x9FFF); } /** * 过滤敏感词 */ public String filter(String text) { if (StringUtils.isBlank(text)) { return text; } String replacement = DEFAULT_REPLACEMENT; StringBuilder result = new StringBuilder(); TrieNode tempNode = rootNode; int begin = 0; // 回滚数 int position = 0; // 当前比较的位置 while (position &lt; text.length()) { char c = text.charAt(position); // 空格直接跳过 if (isSymbol(c)) { if (tempNode == rootNode) { result.append(c); ++begin; } ++position; continue; } tempNode = tempNode.getSubNode(c); // 当前位置的匹配结束 if (tempNode == null) { // 以begin开始的字符串不存在敏感词 result.append(text.charAt(begin)); // 跳到下一个字符开始测试 position = begin + 1; begin = position; // 回到树初始节点 tempNode = rootNode; } else if (tempNode.isKeywordEnd()) { // 发现敏感词， 从begin到position的位置用replacement替换掉 result.append(replacement); position = position + 1; begin = position; tempNode = rootNode; } else { ++position; } } result.append(text.substring(begin)); return result.toString(); } private void addWord(String lineTxt) { TrieNode tempNode = rootNode; // 循环每个字节 for (int i = 0; i &lt; lineTxt.length(); ++i) { Character c = lineTxt.charAt(i); // 过滤空格 if (isSymbol(c)) { continue; } TrieNode node = tempNode.getSubNode(c); if (node == null) { // 没初始化 node = new TrieNode(); tempNode.addSubNode(c, node); } tempNode = node; if (i == lineTxt.length() - 1) { // 关键词结束， 设置结束标志 tempNode.setKeywordEnd(true); } } } @Override public void afterPropertiesSet() throws Exception { rootNode = new TrieNode(); //读取文本 try { InputStream is = Thread.currentThread().getContextClassLoader() .getResourceAsStream(\"SensitiveWords.txt\"); InputStreamReader read = new InputStreamReader(is); BufferedReader bufferedReader = new BufferedReader(read); String lineTxt; while ((lineTxt = bufferedReader.readLine()) != null) { lineTxt = lineTxt.trim(); addWord(lineTxt); } read.close(); } catch (Exception e) { logger.error(\"读取敏感词文件失败\" + e.getMessage()); } } public static void main(String[] argv) { SensitiveService s = new SensitiveService(); s.addWord(\"色情\"); s.addWord(\"好色\"); System.out.print(s.filter(\"你好X色情XX\")); } }Web敏感词过滤public int addQuestion(Question question) { //Html过滤 question.setTitle(HtmlUtils.htmlEscape(question.getTitle())); question.setContent(HtmlUtils.htmlEscape(question.getContent())); // 敏感词过滤 question.setTitle(sensitiveService.filter(question.getTitle())); question.setContent(sensitiveService.filter(question.getContent())); return questionDAO.addQuestion(question) &gt; 0 ? question.getId() : 0; }多线程优势•充分利用多处理器•可以异步处理任务 挑战•数据会被多个线程访问，有安全性问题•不活跃的线程也会占用内存资源•死锁 Thread1.extends Thread，重载run()方法2.implements Runnable()，实现run()方法 new Thread(new Runnable() { @Override public void run() { Random random = new Random(); for (int i = 0; i &lt; 10; ++i) { sleep(random.nextInt(1000)); System.out.println(String.format(\"T%d : %d\", tid, i)); } } }, String.valueOf(i)).start();Synchronized－内置锁1.放在方法上会锁住所有synchronized方法2.synchronized(obj) 锁住相关的代码段 public static void testSynchronized1() { synchronized (obj) { Random random = new Random(); for (int i = 0; i &lt; 10; ++i) { sleep(random.nextInt(1000)); } } }BlockingQueue 同步队列ThreadLocal1.线程局部变量。即使是一个static成员，每个线程访问的变量是不同的。2.常见于web中存储当前用户到一个静态工具类中，在线程的任何地方都可以访问到当前线程的用户。3.参考HostHolder.java里的users Executor1.提供一个运行任务的框架。2.将任务和如何运行任务解耦。3.常用于提供线程池或定时任务服务ExecutorService service = Executors.newFixedThreadPool(2);service.submit(new Runnable() {@Overridepublic void run() {for (int i = 0; i &lt; 10; ++i) {sleep(1000);System.out.println(“Execute %d” + i);}}}); Future线程间通信1.返回异步结果2.阻塞等待返回结果3.timeout4.获取线程中的Exception public static void testFuture() { ExecutorService service = Executors.newSingleThreadExecutor(); Future&lt;Integer&gt; future = service.submit(new Callable&lt;Integer&gt;() { @Overridepublic Integer call() throws Exception {sleep(1000); //throw new IllegalArgumentException(\"一个异常\"); return 1; } }); service.shutdown(); try { System.out.println(future.get()); //System.out.println(future.get(100, TimeUnit.MILLISECONDS)); } catch (Exception e) { e.printStackTrace(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.zhoudamin.com/tags/SpringBoot/"}]},{"title":"Spring Boot 之 MyBatis集成","slug":"Spring-Boot-之-MyBatis集成","date":"2017-07-29T03:40:30.000Z","updated":"2017-07-31T06:53:37.407Z","comments":true,"path":"2017/07/29/spring-boot-zhi-mybatis-ji-cheng/","link":"","permalink":"http://www.zhoudamin.com/2017/07/29/spring-boot-zhi-mybatis-ji-cheng/","excerpt":"MyBatis是现在业界互联网流行的数据操作层框架","text":"MyBatis是现在业界互联网流行的数据操作层框架 流程 用注解的方法 先定义一个Dao，和数据库做交互 注解上写@Mapper： Dao和数据库做一个Mapper 把@Insert通过一个注解的方式写进去 写SQL语句，语法有点不同，导进去 增删改查 Mysql创建数据库创建表userDROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(64) NOT NULL, `password` varchar(128) NOT NULL COMMENT '密码', `salt` varchar(32) not null default '', `head_url` varchar(256) not null default '', PRIMARY KEY (`id`), UNIQUE KEY `name_UNIQUE` (`name`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='这是用户表'创建表questionCREATE TABLE `question` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(255) NOT NULL, `content` text, `user_id` int(11) NOT NULL, `created_date` datetime NOT NULL, `comment_count` int(11) NOT NULL, PRIMARY KEY (`id`), KEY `date_index` (`created_date`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8添加pom.xml依赖&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;添加application.properties配置spring.datasource.url=jdbc:mysql://localhost:3306/wenda?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false spring.datasource.username=root spring.datasource.password=1621 mybatis.config-location=classpath:mybatis-config.xmlDao层先定义一个@Mapper下面就可以写SQL语句了未来扩展：独立数据语句 @Mapper public interface UserDao { //以后数据库有变更，就只要改这里就可以了 String TABLE_NAME=\" user \"; String INSERT_FIELDS=\" name , password ,salt ,head_url \"; String SELECT_FIELDS=\" id,\"+ INSERT_FIELDS ; @Insert({\"insert into \", TABLE_NAME, \"(\", INSERT_FIELDS, \") values (#{name},#{password},#{salt},#{headUrl})\"}) int addUser(User user); }User层添加与读取set与get public class User { private int id; private String name; private String password; private String salt; private String headUrl; public User(){ } public User(String name){ this.name =name; this.password=\"\"; this.salt=\"\"; this.headUrl=\"\"; } public String getName(){return name;} public void setName(String name) {this.name=name;} public String getPassword() {return password;} public void setPassword(String password) {this.password=password;} public String getSalt() {return salt ;} public void setSalt(String salt ) {this.salt=salt;} public String getHeadUrl() {return headUrl;} public void setHeadUrl(String headUrl) {this.headUrl=headUrl;} public int getId() {return id;} public void setId(int id) {this.id=id;} }测试@RunWith( SpringJUnit4ClassRunner.class) @SpringApplicationConfiguration(classes = WendaApplication.class) @Sql(\"/init-schema.sql\") public class InitDatabaseTests { @Autowired UserDao userDao; @Test public void contextLoads() { Random random=new Random(); for(int i=0;i&lt;11;++i){ User user= new User(); user.setHeadUrl(String.format(\"http://images.nowcoder.com/head/%dt.png\",random.nextInt(1000))); user.setName(String.format(\"USER%d\",i)); user.setPassword(\"\"); user.setSalt(\"\"); userDao.addUser(user); } } }数据库写入结果id name password salt head_url 1 USER0 http://images.nowcoder.com/head/165t.png 2 USER1 http://images.nowcoder.com/head/269t.png 3 USER2 http://images.nowcoder.com/head/961t.png 4 USER3 http://images.nowcoder.com/head/395t.png 5 USER4 http://images.nowcoder.com/head/13t.png 6 USER5 http://images.nowcoder.com/head/84t.png 7 USER6 http://images.nowcoder.com/head/179t.png 8 USER7 http://images.nowcoder.com/head/593t.png 9 USER8 http://images.nowcoder.com/head/77t.png 10 USER9 http://images.nowcoder.com/head/600t.png 11 USER10 http://images.nowcoder.com/head/497t.png传入多个参数@Mapper public interface QuestionDao { String TABLE_NAME = \" question \"; String INSERT_FIELDS = \" title, content, created_date, user_id, comment_count \"; String SELECT_FIELDS = \" id, \" + INSERT_FIELDS; @Insert({\"insert into \", TABLE_NAME, \"(\", INSERT_FIELDS, \") values (#{title},#{content},#{createdDate},#{userId},#{commentCount})\"}) int addQuestion(Question question); List&lt;Question&gt; selectLatestQuestions(@Param(\"userId\") int userId, @Param(\"offset\") int offset, @Param(\"limit\") int limit); }QuestionDao.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt; &lt;mapper namespace=\"com.nowcoder.dao.QuestionDao\"&gt; &lt;sql id=\"table\"&gt;question&lt;/sql&gt; &lt;sql id=\"selectFields\"&gt;id, title, content, comment_count,created_date,user_id &lt;/sql&gt; &lt;select id=\"selectLatestQuestions\" resultType=\"com.nowcoder.model.Question\"&gt; SELECT &lt;include refid=\"selectFields\"/&gt; FROM &lt;include refid=\"table\"/&gt; &lt;if test=\"userId != 0\"&gt; WHERE user_id = #{userId} &lt;/if&gt; ORDER BY id DESC LIMIT #{offset},#{limit} &lt;/select&gt; &lt;/mapper&gt;测试 Question question=new Question(); question.setCommentCount(i); Date date=new Date(); date.setTime(date.getTime()+1000*3600*i); question.setCreatedDate(date); question.setUserId(i+1); question.setTitle(String.format(\"TITLE{%d}\",i)); question.setContent(String.format(\"Balalalalalalalala Content %d\" , i) ); questionDao.addQuestion(question);结果 1 TITLE{0} Balalalalalalalala Content 0 1 2017-07-29 20:30:33 0 2 TITLE{1} Balalalalalalalala Content 1 2 2017-07-29 21:30:33 1 3 TITLE{2} Balalalalalalalala Content 2 3 2017-07-29 22:30:33 2 4 TITLE{3} Balalalalalalalala Content 3 4 2017-07-29 23:30:33 3 5 TITLE{4} Balalalalalalalala Content 4 5 2017-07-30 00:30:33 4 6 TITLE{5} Balalalalalalalala Content 5 6 2017-07-30 01:30:33 5 7 TITLE{6} Balalalalalalalala Content 6 7 2017-07-30 02:30:33 6 8 TITLE{7} Balalalalalalalala Content 7 8 2017-07-30 03:30:33 7 9 TITLE{8} Balalalalalalalala Content 8 9 2017-07-30 04:30:33 8 10 TITLE{9} Balalalalalalalala Content 9 10 2017-07-30 05:30:33 9 11 TITLE{10} Balalalalalalalala Content 10 11 2017-07-30 06:30:33 10 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"框架","slug":"框架","permalink":"http://www.zhoudamin.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.zhoudamin.com/tags/SpringBoot/"}]},{"title":"Spring Boot 之 Ioc-Aop","slug":"Spring-Boot-之-Ioc-Aop","date":"2017-07-28T16:36:35.000Z","updated":"2017-07-29T01:16:48.087Z","comments":true,"path":"2017/07/29/spring-boot-zhi-ioc-aop/","link":"","permalink":"http://www.zhoudamin.com/2017/07/29/spring-boot-zhi-ioc-aop/","excerpt":"非常重要的特性！","text":"非常重要的特性！ Ioc依赖注入：无需关注这些变量的初始化，只需要通过注解表示 Service层服务层@Service public class WendaService { public String getMessage(int userId){ return \"Hello Message: \" +String.valueOf(userId); } }Controller层原本是： WendaService wendaService=new WendaService();在用的地方依赖注入 @Autowired WendaService wendaService;完整code: @Controller public class IndexController { @Autowired WendaService wendaService; @RequestMapping(path = {\"/setting\" },method = {RequestMethod.GET}) @ResponseBody public String setting(HttpSession httpSession){ return \"Setting OK. \" + wendaService.getMessage(1); } }http://127.0.0.1:8080/setting/ Setting OK. Hello Message: 1Aop/Log面向切面，所有业务都要处理的业务好处：关注系统性能时，可以查看每个方法调用多少次，每个方法调用时间，额外注释，数据记录统计等都非常方便！ 添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt;aspect@Component @Aspect public class LogAspect { private static final Logger logger= LoggerFactory.getLogger(LogAspect.class); @Before(\"execution(* com.nowcoder.controller.IndexController.*(..))\") public void beforeMethod(){ logger.info(\"before method\"); } @After(\"execution(* com.nowcoder.controller.IndexController.*(..))\") public void afterMethod(){ logger.info(\"after method\"); } }调用IndexController.class前后会执行切面代码 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.3.6.RELEASE) 2017-07-29 09:00:17.625 INFO 5652 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring FrameworkServlet 'dispatcherServlet' 2017-07-29 09:00:17.625 INFO 5652 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet 'dispatcherServlet': initialization started 2017-07-29 09:00:17.635 INFO 5652 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet 'dispatcherServlet': initialization completed in 10 ms 2017-07-29 09:00:17.655 INFO 5652 --- [nio-8080-exec-1] com.nowcoder.aspect.LogAspect : before method 2017-07-29 09:00:17.657 INFO 5652 --- [nio-8080-exec-1] com.nowcoder.aspect.LogAspect : after method document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"框架","slug":"框架","permalink":"http://www.zhoudamin.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.zhoudamin.com/tags/SpringBoot/"}]},{"title":"Spring Boot 之 HelloWorld详解","slug":"Spring-Boot-之-HelloWorld详解","date":"2017-07-28T15:49:43.000Z","updated":"2017-08-01T02:23:43.579Z","comments":true,"path":"2017/07/28/spring-boot-zhi-helloworld-xiang-jie/","link":"","permalink":"http://www.zhoudamin.com/2017/07/28/spring-boot-zhi-helloworld-xiang-jie/","excerpt":"SpringBoot介绍~&lt;暂时假装有&gt;","text":"SpringBoot介绍~&lt;暂时假装有&gt; 配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.nowcoder&lt;/groupId&gt; &lt;artifactId&gt;wenda&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;wenda&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;Controller层简单Hello输出@Controller public class IndexController { @RequestMapping(path = {\"/\",\"/index\"}) @ResponseBody public String index(){ return \"Hello\"; } }访问： http://127.0.0.1:8080/index http://127.0.0.1:8080/输出： Hello参数解析输出路径传递 @Controller public class IndexController { @RequestMapping(path = {\"/\",\"/index\"}) @ResponseBody public String index(){ return \"Hello\"; } @RequestMapping(path = {\"/profile/{userId}\"}) @ResponseBody public String profile(@PathVariable(\"userId\") int userId ){ return String.format(\"Profile Page of %d\",userId); } }访问http://127.0.0.1:8080/profile/2 ： Profile Page of 2参数解析输出例2@RequestMapping(path = {\"/profile/{groupId}/{userId}\"}) @ResponseBody public String profile(@PathVariable(\"userId\") int userId , @PathVariable(\"groupId\") String groupId ){ return String.format(\"Profile Page of %s / %d\",groupId,userId); }访问http://127.0.0.1:8080/profile/admin/10086 Profile Page of admin / 10086eg3请求参数传递@RequestMapping(path = {\"/profile/{groupId}/{userId}\"}) @ResponseBody public String profile(@PathVariable(\"userId\") int userId , @PathVariable(\"groupId\") String groupId , @RequestParam(\"type\") int type , @RequestParam(\"key\") String key ){ return String.format(\"Profile Page of %s / %d , t:%d k:%s\",groupId,userId,type,key); }访问http://127.0.0.1:8080/profile/admin/10086?type=2&amp;key=w Profile Page of admin / 10086 , t:2 k:w模板Velocity使用controller @RequestMapping(path = {\"/vm\"},method = {RequestMethod.GET}) public String template(Model model){ model.addAttribute(\"value1\",\"vvvv1\"); return \"home\"; }指向home.html 渲染 &lt;html&gt; &lt;body&gt; &lt;pre&gt; #* 你看不到我~~~~ *# $!{value1} $!{value2} ## 如果不存在，强制为空 ${value3} &lt;/pre&gt; &lt;/body&gt; &lt;/html&gt;依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-velocity&lt;/artifactId&gt; &lt;/dependency&gt;application.properties 配置 spring.velocity.suffix=.html访问http://127.0.0.1:8080/vm vvvv1 ${value3}总结 @Controller 注释来定义说这是一个网页入口 @RequestMapping 指定访问地址or传入参数 用@PathVariable和@RequestParam对传入参数做解析 用@ResponseBody or 模板文件 返回结果 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"框架","slug":"框架","permalink":"http://www.zhoudamin.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.zhoudamin.com/tags/SpringBoot/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2017-07-27T08:38:39.000Z","updated":"2017-10-02T11:58:45.226Z","comments":true,"path":"2017/07/27/shu-ju-jie-gou-yu-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2017/07/27/shu-ju-jie-gou-yu-suan-fa/","excerpt":"一些基本的数据结构与算法","text":"一些基本的数据结构与算法 数据结构(1)数组 (Array) 在程序设计中，为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。 这些按序排列的同类数据元素的集合称为数组。 在Ｃ语言中， 数组属于构造数据类型。 一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。 因此按数组元素的类型不同，数组又可分为数值数组、字符数组、指针数组、结构数组等各种类别。 (2)栈 (Stack) 是只能在某一端插入和删除的特殊线性表。 它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶， 需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。 (3)队列 (Queue) 一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。 进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。 (4)链表 (Linked List) 是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。 每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 (5)树 (Tree) 是包含n（n>0）个结点的有穷集合K，且在K中定义了一个关系N，N满足 以下条件： （1）有且仅有一个结点 k0，他对于关系N来说没有前驱，称K0为树的根结点。简称为根（root）。 （2）除K0外，k中的每个结点，对于关系N来说有且仅有一个前驱。 （3）K中各结点，对关系N来说可以有m个后继（m>=0）。 (6)图 (Graph) 图是由结点的有穷集合V和边的集合E组成。 其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对， 若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。 链表定义结点class Node { Node next=null; int data; public Node (int data){ this.data=data; } }找单链表中倒数第K个元素一次遍历的方法：用2个指针，第一个指针先走K步；然后2个指针一起走；直到第一个指针到达尾部。 public Node findElem(Node head,int k){ if(k&lt;1||k&gt;this.length()){ return null; } Node p1=head; Node p2=head; for(int i=0;i&lt;k-1;i++){ p1=p1.next; } while (p1!=null){ p1=p1.next; p2=p2.next; } return p2; }从链表中删除重复数据方法1：HashTable需要额外存储空间时间复杂度较低 public void deleteDuplecate(Node head){ Hashtable&lt;Integer,Integer&gt; table = new Hashtable&lt;Integer,Integer&gt;(); Node tmp=head; Node pre=null; while (tmp!=null){ if(table.containsKey(tmp.data)){ pre.next=temp.next; }else { table.put(tmp.data,1); pre=tmp; } tmp=tmp.next; } }方法2：双指针法对链表进行双重循环外循环正常遍历链表，当前设为cur内循环从cur开始遍历若遇到与cur所指向结点值相同则删除这个结点 public void deleteDuplecate(Node head){ Node cur=head; while(cur!=null){ Node q=cur; while(q.next!=null){ if(cur.data==q.next.data){ q.next=q.next.next; }else { q=q.next; } } cur=cur.next; } }在不知道头指针的情况下删除指定结点 若待删除结点为链表尾结点，则无法删除，因为前驱next指针为空 若删除不是尾结点，则先交换该节点和后继结点，再删除！public boolean deleteNode(Node n){ if(n==null || n.next==null){ return false; } int temp=n.data; n.data=n.next.data; n.next.data=temp; //先交换当前与后继data n.next=n.next.next; //再指向下下结点 return true; } 判断两个链表是否相交如果两个链表相交，那么他们一定有着相同的尾结点。分别遍历两个链表，记录他们的尾结点，如果他们的尾结点相同，那么这两个链表相交，否则不相交。 public boolean isIntersect (Node h1, Node h2){ if(h1==null || h2==null){ return false; } //遍历链表 1 Node tail1=h1; while (tail1.next!=null){ tail1=tail1.next; } //遍历链表 2 Node tail2=h2; while (tail2.next!=null){ tail2=tail2.next; } return tail1==tail2; }检测一个链表是否有环fast每次进2slow每次进1 public boolean isLoop(Node head){ Node fast=head; Node slow=head; if(fast==null){ return false; } //如果无环，就总会到尾巴然后退出 //如果有环，就总会追上 while (fast!=null &amp;&amp; fast.next!=null){ fast=fast.next.next; slow=slow.next; if(fast==slow){ return true; } } return !(fast==null &amp;&amp; fast.next==null); } } 栈和队列实现栈public class MyStack&lt;E>{ private Object[] stack; private int size; public MyStack(){ stack=new Object[10]; } //判断堆栈是否为空 public boolean isEmpty(){ return size==0; } public E peek(){ if(isEmpty()){ return null; } return (E) stack[size-1]; } public E pop(){ E e=peek(); stack[size-1]=null; size--; return e; } public E push(E item){ ensureCapacity(size+1);//检查容器 stack[size++]=item; return item; } //判断数组是否已满，若满，则扩容 private void ensureCapacity(int size){ int len=stack.length; if(size>len){ int newlen=10;//每次扩容10 stack= Arrays.copyOf(stack,newlen); } } } 用O(1)的时间复杂度求栈中最小元素栈–后进先出因此pop和push只对栈顶元素进行操作使用两个栈结构，一个栈用来存储数据另一个栈用来存储栈的最小元素 入栈当前入栈元素比之前栈中最小值还小，则压入最小栈中 出栈如果当前出栈的元素是最小值，则把最小值栈的最小值也出栈，留下的就是栈的第二小值成了最小值 public class MyStack1{ MyStack&lt;Integer> elem; MyStack&lt;Integer> min; public MyStack1(){ elem=new MyStack&lt;Integer>(); min = new MyStack&lt;Integer>(); } public void push(int data){ elem.push(data); if(min.isEmpty()){ min.push(data); }else if(data&lt;min.peek()){ min.push(data); } } public int pop() { int topData = elem.peek(); elem.pop(); if (topData == this.min()) { min.pop(); } return topData; } public int min(){ if(min.isEmpty()){ return Integer.MAX_VALUE; }else { return min.peek(); } } } 排序位运算用移位操作实现乘法运算把一个数向左移动n位相当于把该数乘以2的n次方 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"m : \"); int m = scanner.nextInt(); System.out.println(\"n : \"); int n= scanner.nextInt(); System.out.println(powerN(m,n)); } public static int powerN(int m,int n){ for(int i=0;i&lt;n ; i++ ){ m=m&lt;&lt;1; } return m; } } 判断一个数是否为2的n次方最直观的方法—直接递增对比 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"m : \"); int m = scanner.nextInt(); System.out.println(power2(m)); } public static boolean power2(int m){ if(m&lt;1) return false; int i=1; while (i&lt;=m){ if(i==m) return true; i=i&lt;&lt;1; } return false; } } 效率更高的方法2的n次方，二进制中只有一个1，所以用 m&amp;(m-1) 就可以判断了 int num=m&amp;(m-1)； return num==0; 二进制中1的个数首先判断最后一位是否为1，是，则计数加1；然后右移丢弃最后一位 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"m : \"); int m = scanner.nextInt(); System.out.println(countOne(m)); } public static int countOne(int m){ int count=0; while (m>0){ if((m&amp;1)==1){ count++; } m>>=1; } return count; } } 更好的方法每与一次都消除1个1eg: 11001100 &amp; 1011 = 1000 , conut = 11000 &amp; 0111 = 0000 , count = 2 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"m : \"); int m = scanner.nextInt(); System.out.println(countOne(m)); } public static int countOne(int m){ int count=0; while (m>0){ if(m!=0){ m=m&amp;(m-1); count++; } } return count; } } 数组判断一个数组中数值是否连续相邻一个数组序列 元素取值范围为0-65535 相同数值不会重复出现 0可以反复出现 设计一种算法，从数组中随机选取5个数值，判断这5个数值是否连续相邻 注意： 5个数值允许是乱序的，如{8,7,5,0,6} 0可以通配任意数值 0可以多次出现 全0算连续，只有一个非0算连续 思路： 如果没有0的存在，最大值与最小值相差必须等于4 如果0存在，则最大和最小相差小于4 public class Main { public static boolean IsContinuous(int[] array) { int min=-1; int max=-1; for(int i=0;i&lt;array.length;i++){ if(array[i]!=0) { if (max &lt; array[i] || max == -1) { max = array[i]; } if (min > array[i] || min == -1) { min = array[i]; } } } return (max-min)&lt;=4; } public static void main(String[] args) { int[] array = {8,7,5,0,6}; int k=2; System.out.print(IsContinuous(array)); } } 寻找数组中的最小值与最大值取双元素法维持两个全局变量Max，Min每次比较相连两个数将最大与Max比将最小与Min比遍历比较次数为1.5N public class Main { static int Max=Integer.MIN_VALUE; static int Min=Integer.MAX_VALUE; public static void GetMaxandMin(int [] array) { for (int i = 0; i &lt; array.length; i += 2) { if (i + 1 > array.length - 1) { if (array[i] > Max) Max = array[i]; if (array[i] &lt; Min) Min = array[i]; } else { if (array[i] > array[i + 1]) { if (array[i] > Max) Max = array[i]; if (array[i + 1] &lt; Min) Min = array[i + 1]; } if (array[i] &lt; array[i + 1]) { if (array[i + 1] > Max) Max = array[i + 1]; if (array[i] &lt; Min) Min = array[i]; } } } } public static void main(String[] args) { //int [] array= {3,5,6,8,1,4,2}; int [] array= {3,5,6}; GetMaxandMin(array); System.out.println(\"Max = \"+ Max); System.out.println(\"Min = \"+ Min); } } 求最大子数组之和连续子数组，输出最大连续子数组之和 public class Main { public static int[] maxSubArray(int[] array) { int begin = 0; int end = 0; int nStart = 0; int max = Integer.MIN_VALUE; int nSum = 0; for (int i = 0; i &lt; array.length; i++) { if (nSum &lt; 0) { nSum = array[i]; nStart = i; } else { nSum += array[i]; } if (nSum > max) { max = nSum; begin = nStart; end = i; } } int[] num = {begin, end}; return num; } public static void main(String[] args) { int [] array= {3,5,6,-24,1,4,2}; // int [] array= {3,5,6}; int [] num=maxSubArray(array); for (int i=num[0];i&lt;=num[1];i++) System.out.println(array[i]); } } 找出数组中重复元素最多的数 public static int findMostFreInArray(int[] array) { Map&lt;Integer ,Integer > map=new HashMap&lt;Integer,Integer>(); for(int i=0;i&lt;array.length;i++){ if (map.containsKey(array[i])) { map.put(array[i],map.get(array[i])+1); }else { map.put(array[i],1); } } 找出数组中只出现一次的数字一个数组中除了一个数字外，其他数字都出现了2次。 异或运算：任何数字异或它自己都等于0 如果从头到尾异或，那么最后得到的结果就是那个单一数字，其余都被抵消！ public class Main { public static int findNotDouble(int[] array) { int num = array[0]; for (int i = 1; i &lt; array.length; i++) { num ^= array[i]; } return num; } public static void main(String[] args) { int[] array = {3,3,4,76,4,7,76}; int num = findNotDouble(array); System.out.println(num); } } 求数组中两两相加等于20的组合种数先排序 begin end 同时遍历 public class Main { public static void findNotDouble(int[] array,int p) { Arrays.sort(array); int begin=0; int end=array.length-1; int num=0; while (begin&lt;end){ if (array[begin]+array[end]==p) { System.out.println(array[begin]+\",\"+array[end]); begin++; end--; }else if(array[begin]+array[end]>p){ end--; }else { begin++; } } } public static void main(String[] args) { int[] array = {3,3,4,76,4,7,17,16,76}; int point=20; findNotDouble(array,point); } } 把一个数组循环右移k位把12345678右移2位 得到78123456 把78 和123456 看成2个整体,右移k位就是把两部分交换。 只进行三次逆序操作，时间复杂度为O（n）。 逆序数组子序列123456，变成65432178 逆序78，变成65432187 全部逆序，变成78123456 public class Main { public static void reverse(int[] array,int p) { reverpart(array,0,array.length-p-1); reverpart(array,array.length-p,array.length-1); reverpart(array,0,array.length-1); } public static void reverpart(int [] arr,int a,int b){ int temp=0; while (a&lt;b){ temp=arr[a]; arr[a]=arr[b]; arr[b]=temp; a++; b--; } } public static void main(String[] args) { int[] array = {1,2,3,4,5,6,7,8}; int point=2; reverse(array,point); for(int i=0;i&lt;array.length;i++){ System.out.print(array[i]+\" \"); } } } 字符串实现字符串的反转how are you you are how 两次反转过程 how are you uoy era woh you are how public class List { public static void main(String[] args){ String str=\"how are you\"; System.out.println(swapword(str)); } public static String swapword(String str){ char [] cStr=str.toCharArray(); swap(cStr,0,cStr.length-1); int begin=0; for (int end=1;end&lt;cStr.length;end++){ if(cStr[end]==' '){ swap(cStr,begin,end-1); begin=end+1; end++; } if(end==cStr.length-1){ swap(cStr,begin,end); } } return new String(cStr); } public static void swap(char [] str,int n ,int m){ while (n&lt;m){ char temp=str[n]; str[n]=str[m]; str[m]=temp; n++; m--; } } } 判断两个字符串是否由相同字符组成aaaabbc和abcbaaa是不是相同的字符组成 public class List { public static void main(String[] args){ String str1=\"aaaabbce\"; String str2=\"abcbaaad\"; System.out.println(compare(str1,str2)); } public static boolean compare(String str1,String str2){ int [] num=new int [256]; int str1len=str1.length()-1; int str2len=str2.length()-1; while (str1len>=0){ // char temp=str1.charAt(0); num[str1.charAt(str1len)]++; str1len--; } while (str2len>=0){ // char temp=str1.charAt(0); num[str2.charAt(str2len)]--; str2len--; } for (int i=0;i&lt;num.length;i++){ if(num[i]!=0){ return false; } } return true; } } 删除字符串中重复的字符简单的用数组[256]去判断 public class List { public static void main(String[] args){ String str1=\"aaaabbce\"; System.out.println(removeDuplicate(str1)); } public static String removeDuplicate(String str){ int [] num=new int [256]; char [] cStr=new char[str.length()]; int j=0; for(int i=0;i&lt;str.length();i++){ if(num[str.charAt(i)]==0){ num[str.charAt(i)]++; cStr[j++]=str.charAt(i); } } return new String(cStr,0,j); } } 统计一行字符中有多少个单词用一个count 字母前有空格，则表示单词开始 count++ 字母前还是字母，则还没结束该单词 public class List { public static void main(String[] args){ String str1=\"how are you\"; System.out.println(wordCount(str1)); } public static int wordCount(String str){ int count =0; int i=1; for(;i&lt;str.length();i++){ if(str.charAt(i-1)!=' '&amp;&amp;str.charAt(i)==' '){ count++; } } if( str.charAt(i-1)!=' '){ count++; } return count; } } 二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://www.zhoudamin.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.zhoudamin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java程序员面试笔试宝典","slug":"Java程序员面试笔试宝典","permalink":"http://www.zhoudamin.com/tags/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%AE%9D%E5%85%B8/"}]},{"title":"Java Draw","slug":"Java-Draw","date":"2017-07-23T12:27:16.000Z","updated":"2017-07-24T00:18:04.975Z","comments":true,"path":"2017/07/23/java-draw/","link":"","permalink":"http://www.zhoudamin.com/2017/07/23/java-draw/","excerpt":"Java绘图基础！","text":"Java绘图基础！ 简单绘画直线矩形圆根据矩阵画图 package com.zhoudm; import java.awt.*; import javax.swing.*; public class Draw extends JFrame { MyPanel mp = null ; public static void main(String[] args) { // TODO Auto-generated method stub Draw qwe = new Draw(); } public Draw() { mp = new MyPanel(); this.add(mp); this.setSize(400,300); this.setVisible(true); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } class MyPanel extends JPanel //我自己的面板，用于绘图和实现绘图区域 { //覆盖JPanel的paint方法 //Graphics是绘图的重要类，可以理解成一支画笔 public void paint(Graphics g) { //1.调用父类函数完成初始化 super.paint(g); //这句话不能少 //System.out.println(\"被调用\"); //证明别调用 //画圆 int [][] drawnum={{1,0,1,1}, {0,1,0,1}, {1,0,1,1}, {1,1,0,1}}; for(int i=0;i&lt;drawnum.length;i++){ for(int j=0;j&lt;drawnum[0].length;j++){ if(drawnum[i][j]==1){ g.drawOval(30*i+50,30*j+50,25,25); g.setColor(Color.BLUE); } } } // g.drawOval(10, 10, 30, 30); //画直线 // g.drawLine(20, 30, 20, 80); //画出矩形边框 // g.drawRect(50, 50, 100, 50); //画填充矩形 // g.setColor(Color.BLUE); //设置颜色 // g.fillRect(80,60,40,60); } } # Java嵌入图片 ``` class MyPanel extends JPanel //我自己的面板，用于绘图和实现绘图区域 { //覆盖JPanel的paint方法 //Graphics是绘图的重要类，可以理解成一支画笔 public void paint(Graphics g) { //放置图片 Image im = Toolkit.getDefaultToolkit().getImage (Panel.class.getResource(\"/sysu.jpg\")); g.drawImage(im, 50, 50, 70, 70, this); //this代指JPanel本身，意思是把图片放这上面 } } ``` # 将矩形图片切成圆形 周边透明！ ``` import java.awt.*; import java.awt.geom.Ellipse2D; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import javax.imageio.ImageIO; public class Main { public static void main(String[] args) throws IOException { BufferedImage bi1 = ImageIO.read(new File(“G:/code/Java/leetcode/src/mm.jpg”)); // 根据需要是否使用 BufferedImage.TYPE_INT_ARGB BufferedImage image = new BufferedImage(bi1.getWidth(), bi1.getHeight(), BufferedImage.TYPE_INT_ARGB); Ellipse2D.Double shape = new Ellipse2D.Double(0, 0, bi1.getWidth(), bi1 .getHeight()); Graphics2D g2 = image.createGraphics(); image = g2.getDeviceConfiguration().createCompatibleImage(bi1.getWidth(), bi1.getHeight(), Transparency.TRANSLUCENT); g2 = image.createGraphics(); g2.setComposite(AlphaComposite.Clear); g2.fill(new Rectangle(image.getWidth(), image.getHeight())); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC, 1.0f)); g2.setClip(shape); // 使用 setRenderingHint 设置抗锯齿 g2.drawImage(bi1, 0, 0, null); g2.dispose(); try { ImageIO.write(image, \"PNG\", new File(\"G:/code/Java/leetcode/src/mm2.jpg\")); } catch (IOException e) { e.printStackTrace(); } }} # 保存图片 但是保存不了组建图片Dimension imageSize = qwe.getSize(); BufferedImage image = new BufferedImage(imageSize.width, imageSize.height, BufferedImage.TYPE_INT_ARGB); Graphics2D g = image.createGraphics(); qwe.paint(g); g.dispose(); try { ImageIO.write(image, “png”, new File(“G:/code/Java/leetcode/src/sysu2.jpg”)); } catch (IOException e) { e.printStackTrace(); } ``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"绘图","slug":"绘图","permalink":"http://www.zhoudamin.com/tags/%E7%BB%98%E5%9B%BE/"}]},{"title":"常考面试算法题之贪心算法","slug":"常考面试算法题之贪心算法","date":"2017-07-22T08:56:46.000Z","updated":"2017-07-27T09:26:31.994Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-tan-xin-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-tan-xin-suan-fa/","excerpt":"贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。","text":"贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。 贪心算法基本思路1.建立数学模型来描述问题。 2.把求解的问题分成若干个子问题。 3.对每一子问题求解，得到子问题的局部最优解。 4.把子问题的解局部最优解合成原来解问题的一个解。 实现该算法的过程： 从问题的某一初始解出发； while 能朝给定总目标前进一步do 求出可行解的一个解元素； 由所有解元素组合成问题的一个可行解。 排序子序列牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。牛牛有一个长度为n的整数数组A,他现在有一个任务是把数组A分为若干段排序子序列,牛牛想知道他最少可以把这个数组分为几段排序子序列.如样例所示,牛牛可以把数组A划分为[1,2,3]和[2,2,1]两个排序子序列,至少需要划分为2个排序子序列,所以输出2输入描述:输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)第二行包括n个整数A_i(1 ≤ A_i ≤ 10^9),表示数组A的每个数字。输出描述:输出一个整数表示牛牛可以将A最少划分为多少段排序子序列示例1输入61 2 3 2 2 1输出2 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int m = scanner.nextInt(); int[] num = new int[m]; for (int i = 0; i &lt; m; i++) { num[i] = scanner.nextInt(); } System.out.println(NewSort(m, num)); } public static int NewSort(int m, int[] num) { if (m &lt;= 0) { return -1; } int count = 1; int flags = 0; for (int i = 1; i &lt; m; i++) { if (num[i] &gt; num[i - 1]) { if(flags==0){ flags=1; } if(flags==-1){ flags=0; count++; } } else if (num[i] &lt; num[i - 1]) { if(flags==0){ flags=-1; } if(flags==1){ count++; flags=0; } } } return count; } }组队竞赛训练部队 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"},{"name":"贪心","slug":"贪心","permalink":"http://www.zhoudamin.com/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"常考面试算法题之模拟实现","slug":"常考面试算法题之模拟实现","date":"2017-07-22T08:56:30.000Z","updated":"2017-07-23T03:30:41.774Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-mo-ni-shi-xian/","link":"","permalink":"http://www.zhoudamin.com/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-mo-ni-shi-xian/","excerpt":"","text":"平衡数 消除重复元素 奇怪的表达式求值 变换次数 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"常考面试算法题之数学","slug":"常考面试算法题之数学","date":"2017-07-22T08:56:17.000Z","updated":"2017-07-27T10:57:11.220Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-shu-xue/","link":"","permalink":"http://www.zhoudamin.com/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-shu-xue/","excerpt":"","text":"超级素数幂如果一个数字能表示为p^q(^表示幂运算)且p为一个素数,q为大于1的正整数就称这个数叫做超级素数幂。现在给出一个正整数n,如果n是一个超级素数幂需要找出对应的p,q。输入描述: 输入一个正整数n(2 ≤ n ≤ 10^18) 输出描述: 如果n是一个超级素数幂则输出p,q,以空格分隔,行末无空格。如果n不是超级素数幂，则输出No示例1输入27输出3 3 import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner=new Scanner(System.in); System.out.println(\"剩下数字个数 ：\"); long n=scanner.nextLong(); boolean flag=false; double p; for(int q=2;q*q&lt;n;q++){ p=Math.pow((double) n,1d/q); System.out.println(1d/q); System.out.println(1/q); if((long )p==p &amp;&amp; isPrimeNum((long)p)){ System.out.println((long)p+\" \"+q); flag=true; break; } } if(!flag){ System.out.println(\"No\"); } } public static boolean isPrimeNum(long num){ if (num&lt;=1){ return false; } for (int i=2;i*i&lt;=num;i++){ if(num%i==0){ return false; } } return true; } }用 1d 取double很关键！ 剩下数字个数 ： 27 0.5 0 0.3333333333333333 0 3 3找整除牛牛想在[a, b]区间内找到一些数满足可以被一个整数c整除,现在你需要帮助牛牛统计区间内一共有多少个这样的数满足条件？输入描述: 首先输入两个整数a,b,（-510^8 ≤ a ≤ b ≤ 510^8)接着是一个正整数c（1 &lt;= c &lt;= 1000） 输出描述: 输出一个整数表示个数。示例1输入0 14 5输出3 import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner=new Scanner(System.in); System.out.println(\"整数a ：\"); int a=scanner.nextInt(); System.out.println(\"整数b ：\"); int b=scanner.nextInt(); System.out.println(\"正整数c ：\"); int c=scanner.nextInt(); int count=0; for(int n=a/c ; n*c&lt;=b;n++ ){ if(c*n&gt;=a) { count++; } } System.out.println(count); } }魔力手环小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。输入描述: 输入数据包括两行：第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99. 输出描述: 输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。示例1输入 3 21 2 3输出8 9 7 混合颜料最大的奇约数末尾0的个数Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"常考面试算法题之DFS/BFS","slug":"常考面试算法题之DFS-BFS","date":"2017-07-22T08:56:06.000Z","updated":"2018-04-25T03:37:12.482Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-dfs-bfs/","link":"","permalink":"http://www.zhoudamin.com/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-dfs-bfs/","excerpt":"","text":"推箱子 工作安排 幸运的袋子 饥饿的小易 跳石板 地下迷宫 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"笔试","slug":"笔试","permalink":"http://www.zhoudamin.com/tags/%E7%AC%94%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://www.zhoudamin.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"常考面试算法题之动态规划","slug":"常考面试算法题之动态规划","date":"2017-07-22T08:55:42.000Z","updated":"2018-08-02T15:24:31.948Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-dong-tai-gui-hua/","link":"","permalink":"http://www.zhoudamin.com/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-dong-tai-gui-hua/","excerpt":"","text":"猴子摘桃小猴子下山，沿着下山的路有一排桃树，每棵树都结了一些桃子。小猴子想摘桃子，但是又一些条件需要遵守，小瘦子只能沿着下山的方向走，不能回头，每棵树最多摘一个，而且一旦摘了一棵树的桃子，就不能再摘比这棵树结的桃子少的树上的桃子，那么小猴子最多能摘到几课桃子呢？距离说明，比如有五棵树，分别结了10，4，5，12，8棵桃子，那么小猴子最多能摘3颗桃子，来自于结了4，5，12颗桃子的桃树。 public class Main { public static void main(String[] args) { int[] m = {10,4,5,12,8}; int maxP[]=new int [m.length]; for(int j=0;j&lt;m.length;j++){ maxP[j]=1; for (int k=0;k&lt;j;k++){ if(maxP[k]+1>maxP[j] &amp;&amp; m[j]>m[k]){ maxP[j]=maxP[k]+1; } } } int maxPeach=1; for (int k=0;k&lt;maxP.length;k++){ if(maxPeach&lt;maxP[k]){ maxPeach=maxP[k]; } } System.out.println(maxPeach); } } 页码统计牛牛新买了一本算法书，算法书一共有n页，页码从1到n。牛牛于是想了一个算法题目：在这本算法书页码中0~9每个数字分别出现了多少次？输入描述: 输入包括一个整数n(1 ≤ n ≤ 1,000,000,000) 输出描述: 输出包括一行10个整数，即0~9这些数字在页码中出现的次数，以空格分隔。行末无空格。示例1输入 999输出 189 300 300 300 300 300 300 300 300 300创造新世界双核处理堆砖块不等式数列牛牛的数列牛牛现在有一个n个数组成的数列,牛牛现在想取一个连续的子序列,并且这个子序列还必须得满足:最多只改变一个数,就可以使得这个连续的子序列是一个严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。输入描述: 输入包括两行,第一行包括一个整数n(1 ≤ n ≤ 10^5),即数列的长度;第二行n个整数a_i, 表示数列中的每个数(1 ≤ a_i ≤ 10^9),以空格分割。 输出描述: 输出一个整数,表示最长的长度。示例1输入 6 7 2 3 1 5 6输出 5暗黑的字符串数字和为sum的方法数Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"常考面试算法题之暴力枚举","slug":"常考面试算法题之暴力枚举","date":"2017-07-22T03:22:56.000Z","updated":"2018-08-02T15:23:55.027Z","comments":true,"path":"2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-bao-li-mei-ju/","link":"","permalink":"http://www.zhoudamin.com/2017/07/22/chang-kao-mian-shi-suan-fa-ti-zhi-bao-li-mei-ju/","excerpt":"结合2017春招和秋招真题，以下几类算法题最常考，汇总了一下：","text":"结合2017春招和秋招真题，以下几类算法题最常考，汇总了一下： 好多鱼！牛牛有一个鱼缸。鱼缸里面已经有n条鱼，每条鱼的大小为fishSize[i] (1 ≤ i ≤ n,均为正整数)，牛牛现在想把新捕捉的鱼放入鱼缸。鱼缸内存在着大鱼吃小鱼的定律。经过观察，牛牛发现一条鱼A的大小为另外一条鱼B大小的2倍到10倍(包括2倍大小和10倍大小)，鱼A会吃掉鱼B。考虑到这个，牛牛要放入的鱼就需要保证：1、放进去的鱼是安全的，不会被其他鱼吃掉2、这条鱼放进去也不能吃掉其他鱼鱼缸里面已经存在的鱼已经相处了很久，不考虑他们互相捕食。现在知道新放入鱼的大小范围minSize,maxSize,牛牛想知道有多少种大小的鱼可以放入这个鱼缸。 输入描述:输入数据包括3行.第一行为新放入鱼的尺寸范围minSize,maxSize(1 ≤ minSize,maxSize ≤ 1000)，以空格分隔。第二行为鱼缸里面已经有鱼的数量n(1 ≤ n ≤ 50)第三行为已经有的鱼的大小fishSize[i](1 ≤ fishSize[i] ≤ 1000)，以空格分隔。 输出描述:输出有多少种大小的鱼可以放入这个鱼缸。考虑鱼的大小都是整数表示示例1输入 1 12 1 1输出 3import java.util.Random; import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner = new Scanner(System.in); System.out.println(\"minSize :\"); int minSize = scanner.nextInt(); System.out.println(\"maxSize :\"); int maxSize = scanner.nextInt(); System.out.println(\"inNumber :\"); int inNumber = scanner.nextInt(); System.out.println(\"inFishSize[ ] :\"); int [] inFishSize = new int[inNumber]; for(int i=0;i&lt;inNumber;i++) { inFishSize[i]=scanner.nextInt(); } int count =0; for(int i=minSize;i&lt;=maxSize ;i++){ boolean flag=false; for(int j=0;j&lt;inNumber ;j++){ if(( i*2&lt;=inFishSize[j]&amp;&amp;inFishSize[j]&lt;=i*10 )||( inFishSize[j]*2&lt;=i &amp;&amp; inFishSize[j]*10&gt;=i )){ flag=true; break; } } if(!flag){ count++; } } System.out.println(count); } }DNA合成DNA分子是以4种脱氧核苷酸为单位连接而成的长链，这4种脱氧核苷酸分别含有A,T,C,G四种碱基。碱基互补配对原则：A和T是配对的，C和G是配对的。如果两条碱基链长度是相同的并且每个位置的碱基是配对的，那么他们就可以配对合成为DNA的双螺旋结构。现在给出两条碱基链，允许在其中一条上做替换操作：把序列上的某个位置的碱基更换为另外一种碱基。问最少需要多少次让两条碱基链配对成功输入描述:输入包括一行：包括两个字符串,分别表示两条链,两个字符串长度相同且长度均小于等于50。输出描述:输出一个整数，即最少需要多少次让两条碱基链配对成功示例1输入 ACGT TGCA输出 0import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner = new Scanner(System.in); System.out.println(\"输入碱基s1 :\"); String s1=scanner.nextLine(); System.out.println(\"输入碱基s2 :\"); String s2= scanner.nextLine(); if(s1.length()!=s2.length()||s1.isEmpty()||s2.isEmpty()){ return; } int count =0; for(int i=0;i&lt;s1.length();i++){ if(!( (s1.charAt(i)=='A' &amp;&amp; s2.charAt(i)=='T') || (s2.charAt(i)=='A' &amp;&amp; s1.charAt(i)=='T') || (s1.charAt(i)=='C' &amp;&amp; s2.charAt(i)=='G') || (s2.charAt(i)=='C' &amp;&amp; s1.charAt(i)=='G') )){ count++; } } System.out.println(count); } }连续整数牛牛的好朋友羊羊在纸上写了n+1个整数，羊羊接着抹除掉了一个整数，给牛牛猜他抹除掉的数字是什么。牛牛知道羊羊写的整数神排序之后是一串连续的正整数，牛牛现在要猜出所有可能是抹除掉的整数。例如：10 7 12 8 11 那么抹除掉的整数只可能是95 6 7 8 那么抹除掉的整数可能是4也可能是9输入描述:输入包括2行：第一行为整数n(1 &lt;= n &lt;= 50)，即抹除一个数之后剩下的数字个数第二行为n个整数num[i] (1 &lt;= num[i] &lt;= 1000000000)输出描述:在一行中输出所有可能是抹除掉的数,从小到大输出,用空格分割,行末无空格。如果没有可能的数，则输出mistake示例1输入 2 3 6输出 mistakeimport java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner scanner=new Scanner(System.in); System.out.println(\"剩下数字个数 ：\"); int n=scanner.nextInt(); int [] num=new int[n]; System.out.println(\"输入剩下数字 :\"); int max=Integer.MIN_VALUE; int min=Integer.MAX_VALUE; int s=0; for(int i=0;i&lt;n;i++){ num[i]=scanner.nextInt(); s+=num[i]; if(num[i]&lt;min) min=num[i]; if(num[i]&gt;max) max=num[i]; } if(max-min+1 == n){ if(s==(max+min)*n/2){ if(min&gt;1){ System.out.println((min-1)+\" \"+ (max+1)); }else { System.out.println(max+1); } }else { System.out.println(\"mistake!\"); } }else { if(max-min==n){ for(int j=1;j&lt;n;j++){ if(num[j]==num[j-1]){ System.out.println(\"mistake!\"); }else if (num[j]==num[j-1]+2){ System.out.println(num[j]-1); } } }else { System.out.println(\"mistake!\"); } } } }序列和01翻转最长公共连续子串 组装三角形 最小的矩形 字符串分类 优美的回文串 赶去公司 调整队形 集合 涂棋盘 小易记单词 分饼干 买帽子 度度熊回家 寻找三角形 有趣的排序 神奇数 添加字符 数组变换 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"面经-阿里1","slug":"面经-阿里1","date":"2017-07-20T02:10:20.000Z","updated":"2017-08-30T02:22:21.320Z","comments":true,"path":"2017/07/20/mian-jing-a-li-1/","link":"","permalink":"http://www.zhoudamin.com/2017/07/20/mian-jing-a-li-1/","excerpt":"阿里面经总结，查漏补缺~","text":"阿里面经总结，查漏补缺~ Java基础：面向对象和面向过程的区别面向过程就像一个细心的管家，什么事情都要考虑到；而面向对象就像家用电器，只需要知道他的功能，不用知道工作原理。面向过程是一种以事件为中心的编程思想，分析出解决问题所需要的步骤，然后用函数将这些步骤实现，并按顺序调用；面向对象是以对象为中心的编程思想。eg:汽车发动，汽车到站对面向过程来说，这是两个事件，关心的是事件，不是汽车本身，写两个事件函数，分别调用； Java的四个基本特性（抽象、封装、继承，多态）抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 封装：通常认为封装就是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装，我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类(超类、基类)；得到继承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 多态：多态是指允许不同子类型的对象对同一消息作出不同的响应。 多态的理解(实现方法)Overload和Override的区别方法重载–Overload：实现的是编译时的多态性(也称为前绑定)。 方法重写–Override：实现的是运行时的多态性(也称为后绑定)。运行时的多态是面向对象最精髓的东西。 要实现多态需要做两件事：1.方法重写子类继承父类并重写父类中已有的或抽象的方法2.对象造型用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为。 项目中对多态的应用举个栗子，在实验室信息管理系统中，有两种用户，教师和学生，两个用户都可以登陆系统，他们有相同的方法Login，但登陆之后他们会进入不同的页面，也就是在登陆时会有不同的操作，两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。 构造器Constructor是否可被override 访问控制符public,protected,private,以及默认的区别 是否可以继承String类 String和StringBuffer、StringBuilder的区别 hashCode和equals方法的关系 抽象类和接口的区别 自动装箱与拆箱 什么是泛型、为什么要使用以及泛型擦除 Java中的集合类及关系图 HashMap实现原理(看源代码) HashTable实现原理(看源代码) HashMap和HashTable区别HashTable的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap；HashTable不允许null值(key 和 value都不可以)，HashMap允许null值(key 和 value 都可以)；两者的遍历方式大同小异，HashTable仅仅比HashMap多一个elements方法； HashTable和HashMap都能通过values()方法返回一个Collection，然后进行遍历处理，两者也都可以通过entrySet()方法返回一个Set，然后进行遍历处理。 HashTable使用Enumeration，HashMap使用Iterator。 哈希值的使用不同，HashTable直接使用对象的HashCode，HashMap重新计算hash值，而且用于代替求模；HashTable中hash数组默认大小是11，增加的方式是old*2+1，HashMap中hash数组的默认大小是16，而且一定是2的指数；HashTable基于Dictionary，而HashMap基于AbstractMap类。 HashTable如何实现线程安全(看源代码) ArrayList和vector区别(看源代码) ArrayList和LinkedList区别及使用场景 Collection和Collections的区别 Concurrenthashmap实现原理(看源代码) Error、Exception区别 Unchecked Exception和Checked Exception，各列举几个 Java中如何实现代理机制(JDK、CGLIB) 多线程的实现方式 线程的状态转换 如何停止一个线程 什么是线程安全某个类的行为与其规范一致；不管多个线程是怎样的执行顺序和优先级，或是wait，sleep，join等控制方式，如果一个类在多线程访问下运转一切正常，并且访问类不需要进行额外的同步处理或协调，那么我们认为它是线程安全的。 如何保证线程安全对变量使用volitate对程序段进行加锁(synchronized,lock) Synchronized如何使用 synchronized和Lock的区别 多线程如何进行信息交互 sleep和wait的区别(考察的方向是是否会释放锁) 多线程与死锁 如何才能产生死锁 什么叫守护线程，用什么方法实现守护线程 Java线程池技术及原理线程池就是事先创建若干个可执行的线程放入一个池(容器)中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 java并发包concurrent及常用的类 volatile关键字 Java中的NIO，BIO，AIO分别是什么 IO和NIO区别 序列化与反序列化 常见的序列化协议有哪些 内存溢出和内存泄漏的区别 Java内存模型及各个区域的OOM，如何重现OOM 出现OOM如何解决 用什么工具可以查出内存泄漏 Java内存管理及回收算法 Java类加载器及如何加载类(双亲委派) xml解析方式 Statement和PreparedStatement之间的区别 JavaEE:servlet生命周期及各个方法①实例化阶段：服务器对Servlet进行实例化，调用Servlet的构造方法②初始化阶段：服务器调用Servlet的init方法进行初始化（只在第一次请求时调用）。③请求处理阶段：服务器调用Servlet的service方法，然后根据请求方式调用相应的doXXX方法。④服务终止阶段：服务器调用Servlet的destroy方法销毁Servlet实例 servlet中如何自定义filter JSP原理 JSP和Servlet的区别 JSP的动态include和静态include Struts中请求处理过程 MVC概念 8.Spring mvc与Struts区别 Hibernate/Ibatis两者的区别 Hibernate一级和二级缓存 Hibernate实现集群部署 Hibernate如何实现声明式事务 简述Hibernate常见优化策略 Spring bean的加载过程(推荐看Spring的源码) Spring如何实现AOP和IOC Spring bean注入方式 Spring的事务管理(推荐看Spring的源码) Spring事务的传播特性 springmvc原理 springmvc用过哪些注解 Restful有几种请求 Restful好处 Tomcat，Apache，JBoss的区别 memcached和redis的区别 有没有遇到中文乱码问题，如何解决的 如何理解分布式锁 你知道的开源协议有哪些 json和xml区别 设计模式：设计模式的六大原则 单一职责原则定义：不要存在多于一个导致类变更的原因。即一个类只负责一项职责。 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 开闭原则 常用的设计模式 用一个设计模式写一段代码或画出一个设计模式的UML 如何理解MVC 高内聚，低耦合方面的理解内聚性又称快内联系，指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素联系的越紧密，则它的内聚性就越高。耦合性也称块间联系，指软件系统结构中各模块间相互紧密程度的一种度量。模块间联系越紧密，其耦合性就越强。将软件系统化分模块时，尽量做到高内聚低耦合，提高模块的独立性。有个例子很容易明白：一个程序有50个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他49个函数都需要做修改，这就是高耦合的后果。一旦你理解了它，你编写概要设计的时候设计类或者模块自然会考虑到“高内聚，低耦合”。 算法： 深度优先、广度优先算法 排序算法及对应的时间复杂度和空间复杂度 写一个排序算法 查找算法 B+树和二叉树查找时间复杂度 KMP算法、hash算法 常用的hash算法有哪些 如何判断一个单链表是否有环？ 给你一万个数，如何找出里面所有重复的数？用所有你能想到的方法，时间复杂度和空间复杂度分别是多少？ 给你一个数组，如何里面找到和为K的两个数？ 100000个数找出最小或最大的10个？ 一堆数字里面继续去重，要怎么处理？ 数据结构： 队列、栈、链表、树、堆、图 编码实现队列、栈 Linux:linux常用命令 cd命令：切换目录 ls命令：查看文件与目录 grep命令：分析一行的信息 find命令：查找 cp命令：copy，复制文件 mv命令：move ，移动文件，目录或更名 rm命令: 该命令用于删除文件或目录，remove ps命令: 该命令用于将某个时间点的进程运行情况选取下来并输出，process之意 kill命令: 该命令用于向某个工作或者是某个PID（数字）传送一个信号 killall命令: 该命令用于向一个命令启动的进程发送一个信号 file命令: 该命令用于判断接在file命令后的文件的基本数据 tar命令: 该命令用于对文件进行打包 cat命令: 该命令用于查看文本文件的内容，后接要查看的文件名 chgrp命令: 该命令用于改变文件所属用户组 chown命令: 该命令用于改变文件的所有者 chmod命令: 该命令用于改变文件的权限 vim命令: 该命令主要用于文本编辑，它接一个或多个文件名作为参数 gcc命令: 对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序 time命令: 该命令用于测算一个命令（即程序）的执行时间 如何查看内存使用情况 Linux下如何进行进程调度 操作系统： 操作系统什么情况下会死锁 产生死锁的必要条件 死锁预防 数据库： 范式 数据库事务隔离级别 数据库连接池的原理 乐观锁和悲观锁 如何实现不同数据库的数据查询分页 SQL注入的原理，如何预防 数据库索引的实现(B+树介绍、和B树、R树区别) SQL性能优化 数据库索引的优缺点以及什么时候数据库索引失效 10.Redis的存储结构 网络： OSI七层模型以及TCP/IP四层模型 HTTP和HTTPS区别 HTTP报文内容 get提交和post提交的区别 get提交是否有字节限制，如果有是在哪限制的 TCP的三次握手和四次挥手 session和cookie的区别 HTTP请求中Session实现原理 redirect与forward区别 10.DNS TCP和UDP区别 安全： 如果客户端不断的发送请求连接会怎样 DDos攻击 DDos预防 那怎么知道连接是恶意的呢？可能是正常连接 其它： 说一个你参与的项目、其中作为什么角色 遇到最困的问题是什么，怎么解决的 你认为自己有那些方面不足 平常如何学习的 如何评价自己 智力题： 给你50个红球和50个黑球，有两个一模一样的桶，往桶里放球，让朋友去随机抽，采用什么策略可以让朋友抽到红球的概率更高？ 从100个硬币中找出最轻的那个假币？ Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"面经","slug":"面经","permalink":"http://www.zhoudamin.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"http://www.zhoudamin.com/tags/%E7%AC%94%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"},{"name":"阿里","slug":"阿里","permalink":"http://www.zhoudamin.com/tags/%E9%98%BF%E9%87%8C/"}]},{"title":"SemiCode测试流程","slug":"SemiCode测试流程","date":"2017-07-19T06:50:28.000Z","updated":"2018-04-25T06:41:43.864Z","comments":true,"path":"2017/07/19/semicode-ce-shi-liu-cheng/","link":"","permalink":"http://www.zhoudamin.com/2017/07/19/semicode-ce-shi-liu-cheng/","excerpt":"第一次写脚本测试！","text":"第一次写脚本测试！ 测试目的随机生成大量SemiCode，从译码检测算法完备性！ 测试结果1、第一次测试10万张码有5%的无法译出，单独调试发现是寻像算法寻像出错2、为了补充寻像算法，写了个图片旋转的算法3、第二次测试重新生成10万张码，全部译出4、第三次测试10万张，全部译出5、结论：代码的健壮性非常好！ 测试流程生成1、用随机字符串生成内容，用随机数字生成输入内容大小2、用时间戳给每张二维码命名3、将生成的二维码的名字（时间戳）保存到encode.txt文件4、将生成的二维码图片保存到encodePic文件夹5、for循环生成10万张SemiCode二维码 解码1、从encode.txt文本中分别读取每个图片的名字2、根据图片name从encodePic中调取图片3、for循环译码4、将无法译出的图片旋转测试（补充寻像算法）5、将译码结果保存到decode.txt6、从decode.txt中查找译码信息为null的二维码单独调试 # 关键代码 ## 生成随机字符串以及随机汉字 ``` public static String RandomString(int length) { String str = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:/?@#$&amp;*()+\"; Random random = new Random(); StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; length-1; i++) { int num = random.nextInt(73); if(num==72){ length-=1; } buf.append( num!=72? str.charAt(num):(char) (0x4e00 + (int) (Math.random() * (0x9fa5 - 0x4e00 + 1)))); } return buf.toString(); } ``` ## 生成随机数字 ``` public static int suijinum(int max) { int min=2; Random random = new Random(); int s = random.nextInt(max)%(max-min+1) + min; return s; } ``` ## 时间戳生成随机图片name ``` String pname = \"a\"; Random rand = new Random(); SimpleDateFormat df = new SimpleDateFormat(\"yyyyMMddHHmmss\");//设置日期格式 String time = df.format(new Date()); int randnum1 = rand.nextInt(900)+100; time=time.concat(String.valueOf(randnum1)); int randnum2 = rand.nextInt(90)+10; time=time.concat(String.valueOf(randnum2)); pname=time; ``` ## 读写txt文件 ``` import java.io.File; import java.io.InputStreamReader; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.FileWriter; public class cin_txt { static void main(String args[]) { try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw /* 读入TXT文件 */ String pathname = \"D:\\\\twitter\\\\13_9_6\\\\dataset\\\\en\\\\input.txt\"; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径 File filename = new File(pathname); // 要读取以上路径的input。txt文件 InputStreamReader reader = new InputStreamReader( new FileInputStream(filename)); // 建立一个输入流对象reader BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言 String line = \"\"; line = br.readLine(); while (line != null) { line = br.readLine(); // 一次读入一行数据 } /* 写入Txt文件 */ File writename = new File(\".\\\\result\\\\en\\\\output.txt\"); // 相对路径，如果没有则要建立一个新的output。txt文件 writename.createNewFile(); // 创建新文件 BufferedWriter out = new BufferedWriter(new FileWriter(writename)); out.write(\"我会写入文件啦\\r\\n\"); // \\r\\n即为换行 out.flush(); // 把缓存区内容压入文件 out.close(); // 最后记得关闭文件 } catch (Exception e) { e.printStackTrace(); } } } ## 计算代码时间long startTime=System.currentTimeMillis(); //获取开始时间doSomeThing(); //测试的代码段long endTime=System.currentTimeMillis(); //获取结束时间System.out.println(“程序运行时间： “+(endTime-startTime)+”ms”); ## 旋转图片测试,返回图片name /** * 旋转 * * @param degree * 旋转角度 * @throws Exception */ public static String spin(int degree ,String imgPath,String line) throws Exception { int swidth = 0; // 旋转后的宽度 int sheight = 0; // 旋转后的高度 int x; // 原点横坐标 int y; // 原点纵坐标 File file = new File(imgPath); if (!file.isFile()) { throw new Exception(\"ImageDeal&gt;&gt;&gt;\" + file + \" 不是一个图片文件!\"); } BufferedImage bi = ImageIO.read(file); // 读取该图片 // 处理角度--确定旋转弧度 degree = degree % 360; if (degree &lt; 0) degree = 360 + degree;// 将角度转换到0-360度之间 double theta = Math.toRadians(degree);// 将角度转为弧度 // 确定旋转后的宽和高 if (degree == 180 || degree == 0 || degree == 360) { swidth = bi.getWidth(); sheight = bi.getHeight(); } else if (degree == 90 || degree == 270) { sheight = bi.getWidth(); swidth = bi.getHeight(); } else { swidth = (int) (Math.sqrt(bi.getWidth() * bi.getWidth() + bi.getHeight() * bi.getHeight())); sheight = (int) (Math.sqrt(bi.getWidth() * bi.getWidth() + bi.getHeight() * bi.getHeight())); } x = (swidth / 2) - (bi.getWidth() / 2);// 确定原点坐标 y = (sheight / 2) - (bi.getHeight() / 2); BufferedImage spinImage = new BufferedImage(swidth, sheight, bi.getType()); // 设置图片背景颜色 Graphics2D gs = (Graphics2D) spinImage.getGraphics(); gs.setColor(Color.white); gs.fillRect(0, 0, swidth, sheight);// 以给定颜色绘制旋转后图片的背景 AffineTransform at = new AffineTransform(); at.rotate(theta, swidth / 2, sheight / 2);// 旋转图象 at.translate(x, y); AffineTransformOp op = new AffineTransformOp(at, AffineTransformOp.TYPE_BICUBIC); spinImage = op.filter(bi, spinImage); String linesp=line+degree; File sf = new File(\"G:/ProjectQRcode/SpringPro/Test/spanpic\", linesp + \".\" +\"png\"); ImageIO.write(spinImage, \"png\", sf); // 保存图片 return linesp; }``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"工具代码","slug":"工具代码","date":"2017-07-13T12:28:54.000Z","updated":"2017-07-13T15:32:51.917Z","comments":true,"path":"2017/07/13/gong-ju-dai-ma/","link":"","permalink":"http://www.zhoudamin.com/2017/07/13/gong-ju-dai-ma/","excerpt":"一些小的小工具代码","text":"一些小的小工具代码 随机字符串/** 产生一个随机的字符串*/ public static String RandomString(int length) { String str = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; Random random = new Random(); StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; length; i++) { int num = random.nextInt(62); buf.append(str.charAt(num)); } return buf.toString(); } # java生成指定范围的随机数 ``` import java.util.Random; public class RandomTest { public static void main(String[] args) { int max=20; int min=10; Random random = new Random(); int s = random.nextInt(max)%(max-min+1) + min; System.out.println(s); }} &lt;br/&gt; # 时间戳 String pname = \"a\"; Random rand = new Random(); SimpleDateFormat df = new SimpleDateFormat(\"yyyyMMddHHmmss\");//设置日期格式 String time = df.format(new Date()); int randnum1 = rand.nextInt(900)+100; time=time.concat(String.valueOf(randnum1)); int randnum2 = rand.nextInt(90)+10; time=time.concat(String.valueOf(randnum2)); pname=time; String imgPath = \"C:/Users/Administrator/Desktop/Timecode/\"+pname+\".png\"; &lt;br/&gt; # 读写text文件import java.io.File;import java.io.InputStreamReader;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileWriter; public class cin_txt { static void main(String args[]) { try { // 防止文件建立或读取失败，用catch捕捉错误并打印，也可以throw /* 读入TXT文件 */ String pathname = \"D:\\\\twitter\\\\13_9_6\\\\dataset\\\\en\\\\input.txt\"; // 绝对路径或相对路径都可以，这里是绝对路径，写入文件时演示相对路径 File filename = new File(pathname); // 要读取以上路径的input。txt文件 InputStreamReader reader = new InputStreamReader( new FileInputStream(filename)); // 建立一个输入流对象reader BufferedReader br = new BufferedReader(reader); // 建立一个对象，它把文件内容转成计算机能读懂的语言 String line = \"\"; line = br.readLine(); while (line != null) { line = br.readLine(); // 一次读入一行数据 } /* 写入Txt文件 */ File writename = new File(\".\\\\result\\\\en\\\\output.txt\"); // 相对路径，如果没有则要建立一个新的output。txt文件 writename.createNewFile(); // 创建新文件 BufferedWriter out = new BufferedWriter(new FileWriter(writename)); out.write(\"我会写入文件啦\\r\\n\"); // \\r\\n即为换行 out.flush(); // 把缓存区内容压入文件 out.close(); // 最后记得关闭文件 } catch (Exception e) { e.printStackTrace(); } } } &lt;br/&gt; # 计算代码时间long startTime=System.currentTimeMillis(); //获取开始时间doSomeThing(); //测试的代码段long endTime=System.currentTimeMillis(); //获取结束时间System.out.println(“程序运行时间： “+(endTime-startTime)+”ms”); ``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"剑指Offer(51-67)","slug":"剑指Offer(51-67)","date":"2017-07-11T07:33:24.000Z","updated":"2017-07-11T12:19:04.769Z","comments":true,"path":"2017/07/11/jian-zhi-offer-51-67/","link":"","permalink":"http://www.zhoudamin.com/2017/07/11/jian-zhi-offer-51-67/","excerpt":"英文新增面试题！","text":"英文新增面试题！ 题51：数组中重复的数字题目： 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。 思路： 1、排序 将数组排序，然后扫描排序后的数组即可。 时间复杂度：O(nlogn)，空间复杂度:O(1) 2、哈希表 从头到尾扫描数组，每扫描到一个数字，判断该数字是否在哈希表中，如果该哈希表还没有这个数字，那么加入哈希表，如果已经存在，则返回该数字； 时间复杂度：O(n)，空间复杂度:O(n) 3、交换 0~n-1正常的排序应该是A[i]=i；因此可以通过交换的方式，将它们都各自放回属于自己的位置； 从头到尾扫描数组A，当扫描到下标为i的数字m时，首先比较这个数字m是不是等于i， 如果是，则继续扫描下一个数字； 如果不是，则判断它和A[m]是否相等，如果是，则找到了第一个重复的数字（在下标为i和m的位置都出现了m）；如果不是，则把A[i]和A[m]交换，即把m放回属于它的位置； 重复上述过程，直至找到一个重复的数字； 时间复杂度：O(n)，空间复杂度：O(1) (将每个数字放到属于自己的位置最多交换两次) public class Main{ public static void main(String[] args){ int[] nums={2,3,1,0,2,5,3}; duplicate(nums); } public static void duplicate(int [] nums){ if(nums==null ||nums.length&lt;=0) return; for(int i=0;i&lt;nums.length;i++){ if(nums[i]&gt;nums.length) return ; } for(int i=0;i&lt;nums.length;i++){ while (nums[i]!=i){ if(nums[i]==nums[nums[i]]){ System.out.println(nums[i]); break; } int temp=nums[nums[i]]; nums[nums[i]]=nums[i]; nums[i]=temp; } } } } # 题52：构建乘积数组 题目： 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法 ``` public class Main{ public static void main(String[] args){ int[] nums={1,2,3,4,5}; ConstructAarry(nums); } public static void ConstructAarry(int [] nums){ int [] A =new int [nums.length] ; int [] B =new int [nums.length] ; int [] C =new int [nums.length] ; B[0]=1; C[0]=1; for(int i=1;i&lt;nums.length;i++){ B[i]=B[i-1]*nums[i-1]; C[i]=C[i-1]*nums[nums.length-i]; } for(int i=0;i&lt;nums.length;i++){ A[i]=B[i]*C[nums.length-i-1]; System.out.println(A[i]); } }} &lt;br/&gt; # 题53：正则表达式匹配 题目描述 请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但是与\"aa.a\"和\"ab*a\"均不匹配 &lt;br/&gt; # 题54：表示数值的字符串 题目： 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\",\"5e2\",\"-123\",\"3.1416\"和\"-1E-16\"都表示数值。 但是\"12e\",\"1a3.14\",\"1.2.3\",\"+-5\"和\"12e+4.3\"都不是。import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc=new Scanner(System.in); String str=sc.next(); char [] chr=str.toCharArray(); System.out.println(isNum(chr)); } public static boolean isNum(char [] chr){ if(chr==null) return false; int index=0; if(chr[index]=='+'||chr[index]=='-'){ index++; } if (index==chr.length) return false; boolean num=true; //数有多少个数字 while (index&lt;chr.length&amp;&amp;chr[index]&gt;='0'&amp;&amp;chr[index]&lt;='9'){ index++; } if(index!=chr.length){ if(chr[index]=='.'){ index++; while (index&lt;chr.length&amp;&amp;chr[index]&gt;='0'&amp;&amp;chr[index]&lt;='9'){ index++; } if(index&lt;chr.length&amp;&amp;(chr[index]=='E'||chr[index]=='e')){ num=isExponential(chr,index); }else num=false; } } return num&amp;&amp;index==chr.length; } public static boolean isExponential(char[]chr ,int index){ index++; if(index==chr.length) return false; if(chr[index]=='+'||chr[index]=='-'){ index++; } if(index==chr.length) return false; while (index&lt;chr.length&amp;&amp;chr[index]&gt;='0'&amp;&amp;chr[index]&lt;='9'){ index++; } return index==chr.length? true:false; }} &lt;br/&gt; # 题55：字符流中第一个不重复的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符\"go\"时，第一个只出现一次的字符是\"g\"。当从该字符流中读出前六个字符“google\"时，第一个只出现一次的字符是\"l\"。 输出描述: 如果当前字符流没有存在出现一次的字符，返回#字符。import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc=new Scanner(System.in); String str=sc.next(); System.out.println( FirstAppearingOnce(str)); } public static char FirstAppearingOnce(String str){ int [] hash=new int [256]; for(int i=0;i&lt;str.length();i++){ hash[str.charAt(i)]++; } int j=0; while (hash[str.charAt(j)]!=1){ j++; } return str.charAt(j); }} ``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.zhoudamin.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer(41-50)","slug":"剑指Offer(41-50)","date":"2017-07-11T07:33:07.000Z","updated":"2017-07-12T12:41:21.198Z","comments":true,"path":"2017/07/11/jian-zhi-offer-41-50/","link":"","permalink":"http://www.zhoudamin.com/2017/07/11/jian-zhi-offer-41-50/","excerpt":"","text":"题46：求1+2+3+…+n【题目描述】求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C） import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc=new Scanner(System.in); int num1=sc.nextInt(); int num2=sc.nextInt(); System.out.println( add(num1,num2)); } public static int add(int num1 ,int num2){ int sum ,carry; do { sum=num1^num2; carry=(num1&amp;num2)&lt;&lt;1; num1=sum; num2=carry; }while (carry!=0); return num1; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.zhoudamin.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"Java常用算法手册","slug":"Java常用算法手册","date":"2017-07-10T08:55:35.000Z","updated":"2017-07-13T08:49:46.247Z","comments":true,"path":"2017/07/10/java-chang-yong-suan-fa-shou-ce/","link":"","permalink":"http://www.zhoudamin.com/2017/07/10/java-chang-yong-suan-fa-shou-ce/","excerpt":"本书于黄埔图书馆（香雪馆）偶读之，算法不错！","text":"本书于黄埔图书馆（香雪馆）偶读之，算法不错！ 简单约瑟夫环算法1.算法背景:罗马人攻占了乔塔帕特，41人藏在一个山洞中躲过了这场浩劫。这41个人中，包括历史学家josephus和他的一个朋友。剩余的39个人为了表示不向罗马人屈服，决定集体自杀。大家决定了一个自杀方案，所有这41人围城一个圆圈，由第一个人开始顺时针报数，没报数为3的人就立刻自杀，然后由下一个人重新开始报数任然是每报数为3的人就立刻自杀,……,知道所有人都自杀死亡为止.约瑟夫和他的朋友并不像自杀，于是约瑟夫想到了一个计策，他们两个同样参数到自杀方案中，但是最后却躲过了自杀。请问是怎么做到的 public class Main{ static final int nums=41;//总人数 static final int killMan = 3; //数到3则杀 public static void main(String[] args){ Joseph(2); } public static void Joseph(int alive){ int []man =new int [nums]; // 存活者为0 int pos=-1; //数组角标 int i=0; //循环，与3比较 int count=1; //杀到第几个计数 while(count&lt;=nums){ do { pos=(pos+1)%nums; //环状处理 if(man[pos]==0) i++; if(i==killMan){ i=0; break; } }while (true); man[pos]=count; //记录pos+1位置的是第几个挂 count++; } alive=nums-alive; for(int j=0;j&lt;nums;j++){ if(man[j]&gt;alive){ System.out.println(\"不被杀的位置是：\"+(j+1)); //数组从0开始，所以位置是j+1 } } } }0 = 14 1 = 36 2 = 1 3 = 38 4 = 15 5 = 2 6 = 24 7 = 30 8 = 3 9 = 16 10 = 34 11 = 4 12 = 25 13 = 17 14 = 5 15 = 40 16 = 31 17 = 6 18 = 18 19 = 26 20 = 7 21 = 37 22 = 19 23 = 8 24 = 35 25 = 27 26 = 9 27 = 20 28 = 32 29 = 10 30 = 41 31 = 21 32 = 11 33 = 28 34 = 39 35 = 12 36 = 22 37 = 33 38 = 13 39 = 29 40 = 23 背包问题–动态规划背包问题具体例子：假设现有容量10kg的背包，另外有3个物品，分别为a1，a2，a3。物品a1重量为3kg，价值为4；物品a2重量为4kg，价值为5；物品a3重量为5kg，价值为6。将哪些物品放入背包可使得背包中的总价值最大？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://www.zhoudamin.com/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2017-07-05T09:08:50.000Z","updated":"2017-07-05T15:11:59.552Z","comments":true,"path":"2017/07/05/ji-suan-ji-wang-luo/","link":"","permalink":"http://www.zhoudamin.com/2017/07/05/ji-suan-ji-wang-luo/","excerpt":"读书笔记~","text":"读书笔记~ TCP/IP详解读书笔记分层应用层：Telnet、FTP和e-mail等运输层：TCP和UDP网络层：IP、ICMP和IGMP链路层：设备驱动程序及接口卡 中国大学MOOC-计算机网络第三周超文本传输协议 HyperText Transfer Protocol使用TCP传输服务 ·服务器在80端口等待客户的请求 ·浏览器发起到服务器的TCP连接（创建套接字Socket） ·服务器接收来自浏览器的TCP连接 ·浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息 ·关闭TCP连接Email应用构成：邮件客户端：读写email消息；与服务器交互，收发email消息。邮件服务器SMTP协议 # 计算机网络自顶向下方法 ## 第2章 应用层 1.TCP服务 ·面向连接服务 ·可靠数据传输服务 2.运输层协议 ·可靠数据传输 ·吞吐量 ·定时 ·安全性 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.zhoudamin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.zhoudamin.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"剑指Offer(31-40)","slug":"剑指Offer(31-40)","date":"2017-07-05T06:33:53.000Z","updated":"2017-07-13T11:18:31.898Z","comments":true,"path":"2017/07/05/jian-zhi-offer-31-40/","link":"","permalink":"http://www.zhoudamin.com/2017/07/05/jian-zhi-offer-31-40/","excerpt":"剑指Offer","text":"剑指Offer 题31：连续子数组的最大和题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。例子说明：例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和 18 。 public class Main{ public static void main(String[] args){ int [] arr={1, -2, 3, 10, -4, 7, 2, -5}; System.out.println(bigsum(arr)); } private static boolean flag=true; public static int bigsum(int [] arr){ if(arr==null || arr.length&lt;=0){ flag=false; return 0; } int bigsum=0; int sum=0; for(int i=0;i&lt;arr.length;i++){ if(sum&lt;=0){ sum=arr[i]; }else { sum+=arr[i]; } if(bigsum&lt;sum){ bigsum=sum; } } return bigsum; } } 题32：求从 1 到 n 的整数中 1 出现的次数题目：输入一个整数 n 求从 1 到 n 这 n 个整数的十进制表示中 1 出现的次数。举例说明： 例如输入 12 ，从 1 到 12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。 题33： # 题34： ``` &lt;br/&gt; # 题35：&lt;br/&gt; # 题36：&lt;br/&gt; # 题37：&lt;br/&gt; # 题38：&lt;br/&gt; # 题39：&lt;br/&gt; # 题40：``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.zhoudamin.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"剑指Offer(21-30)","slug":"剑指Offer(21-30)","date":"2017-07-03T03:23:05.000Z","updated":"2017-07-10T08:53:46.886Z","comments":true,"path":"2017/07/03/jian-zhi-offer-21-30/","link":"","permalink":"http://www.zhoudamin.com/2017/07/03/jian-zhi-offer-21-30/","excerpt":"","text":"题21：包含min函数的栈题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min，push及pop的时间复杂度都是O(1). public class Main{ private MyStack&lt;Integer&gt; minStack = new MyStack&lt;&gt;(); private MyStack&lt;Integer&gt; dataStack = new MyStack&lt;&gt;(); public void push(Integer item){ dataStack.push(item); if(minStack.length == 0 || item&lt;=minStack.head.data){ minStack.push(item); }else{ minStack.push(minStack.head.data); } } public Integer pop(){ if(dataStack.length == 0 || minStack.length == 0){ return null; } minStack.pop(); return dataStack.pop(); } public Integer min(){ if(minStack.length == 0){ return null; } return minStack.head.data; } public static void main(String[] args){ E21MinInStack test = new E21MinInStack(); test.push(3); test.push(2); test.push(1); System.out.println(test.pop()); System.out.println(test.min()); } } # 题28：字符串的排列 题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 ``` public class Main { public static void main(String[] args){ permutation(\"abc\"); } public static void permutation(String str){ int count=0; if(str==null){ return; } char [] chs=str.toCharArray();//将字符串转换为字符数组 int point=0; System.out.print(chs); System.out.print(“ “); count++; char temp1=chs[point]; chs[point]=chs[++point]; chs[point]=temp1; while (!String.valueOf(chs).equals(str)){ System.out.print(chs); System.out.print(“ “); count++; if(point==chs.length-1){ char temp=chs[point]; chs[point]=chs[0]; chs[0]=temp; point=0; }else { char temp=chs[point]; chs[point]=chs[++point]; chs[point]=temp; } } System.out.println(count); }} &lt;br/&gt; # 题29：数组中出现次数超过一半的数组 题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出null。public class Main { public static void main(String[] args){ int [] array={1,2,3,2,2,2,5,4,2}; System.out.println(morethanhalfnumber(array)); } public static Integer morethanhalfnumber(int [] array){ int count=1; int temp=array[0]; for(int i=1;i&lt;array.length;i++){ if(temp==array[i]){ count++; }else { count--; if(count==0){ temp=array[i]; count++; } } } int count1=0; for(int i=0;i&lt;array.length;i++){ if(array[i]==temp){ count1++; } } return count1&gt;=array.length/2 ? temp:null; }} &lt;br/&gt; # 题30：最小的k个数 题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。import java.util.ArrayList;import java.util.TreeSet; public class Main { public static void main(String[] args){ int [] array={4,5,1,6,2,7,3,8}; int k=4; System.out.println(MinKnumber(array,k)); } public static ArrayList&lt;Integer&gt; MinKnumber(int [] array, int k){ if(array==null) return null; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(k); if(k&gt;array.length) return list; TreeSet&lt;Integer&gt; tree=new TreeSet&lt;Integer&gt;(); for(int i=0;i&lt;array.length;i++){ tree.add(array[i]); } int i=0; for (Integer elem:tree){ if(i&gt;k-1) break; list.add(elem); i++; } return list; }} ``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.zhoudamin.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"LeetCode解题思路(二)","slug":"LeetCode解题思路-二","date":"2017-06-28T08:44:24.000Z","updated":"2017-06-28T08:44:24.828Z","comments":true,"path":"2017/06/28/leetcode-jie-ti-si-lu-er/","link":"","permalink":"http://www.zhoudamin.com/2017/06/28/leetcode-jie-ti-si-lu-er/","excerpt":"","text":"Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"剑指Offer(1-10)","slug":"剑指Offer(1-10)","date":"2017-06-28T08:33:26.000Z","updated":"2020-04-23T15:44:57.165Z","comments":true,"path":"2017/06/28/jian-zhi-offer-1-10/","link":"","permalink":"http://www.zhoudamin.com/2017/06/28/jian-zhi-offer-1-10/","excerpt":"剑指Offer题目解析！","text":"剑指Offer题目解析！ 题1：赋值运算符函数题2：实现单例模式题3：二维数组中的查找题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 public class Main { public static void main(String[] args) { int arr[][] ={{1,3,5,7,9}, {2,4,6,8,10}, {3,5,7,9,12}, {5,7,9,10,15}}; int key=5; System.out.print(\"Key has in arr :\" + find(arr,key)); } public static boolean find(int [][] array,int key){ if(array==null) return false; int clo=array[0].length-1; int row=0; while (clo&gt;=0&amp;&amp;row&lt;array.length){ if(array[row][clo]&gt;key){ clo--; }else if (array[row][clo]&lt;key){ row++; }else { return true; } } return false; } }题4：替换空格方法1：时间复杂度为 O(n) 的解法，思路是先数空格，再倒序插值! public class Main { public static void main(String[] args) { String str= \"we are happy.\"; String res=ResplaceBlank(str); System.out.println(res); } public static String ResplaceBlank(String str){ if(str==null) return str; int len=str.length(); int k=0; for(int i=0;i&lt;len;i++){ if(str.charAt(i)==' ') k++; } char [] strnew = new char[len+k*3]; for(int i=len+k*2-1,j=len-1;i&gt;=0;i--,j--){ if(str.charAt(j)!=' '){ strnew[i]=str.charAt(j); }else{ strnew[i--]='0'; strnew[i--]='2'; strnew[i]='%'; } } return new String(strnew); } }方法2：新数组，直接append public class Main { public static void main(String[] args) { String str= \"we are happy.\"; String res=ResplaceBlank(str); System.out.println(res); } public static String ResplaceBlank(String str){ if(str==null) return str; StringBuilder outputbuffer=new StringBuilder(); for(int i=0;i&lt;str.length();i++){ if(str.charAt(i)!=' '){ outputbuffer.append(str.charAt(i)); }else { outputbuffer.append('%'); outputbuffer.append('2'); outputbuffer.append('0'); } } return new String(outputbuffer); } }题5：从尾到头打印链表学会Stack的使用，Stack是一种先进后出的数据结构，pop出和push存 import java.util.Stack; public class Main { public static void main(String[] args) { ListNode node1=new ListNode(1); ListNode node2=new ListNode(2); ListNode node3=new ListNode(3); node1.next=node2; node2.next=node3; printReverseList(node1); } public static class ListNode{ int val; ListNode next; ListNode(int val){ this.val=val; this.next=null; } } public static void printReverseList(ListNode root){ if(root==null ) return ; ListNode node=root; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); while(node!=null){ stack.push(node); node=node.next; } while(!stack.isEmpty()){ int val=stack.pop().val; System.out.print(val+\" \"); } } }递归实现方法： public class Main { public static void main(String[] args) { ListNode node1=new ListNode(1); ListNode node2=new ListNode(2); ListNode node3=new ListNode(3); node1.next=node2; node2.next=node3; printReverseList(node1); } public static class ListNode{ int val; ListNode next; ListNode(int val){ this.val=val; this.next=null; } } public static void printReverseList(ListNode root){ if(root!=null){ if(root.next!=null){ printReverseList(root.next); } } System.out.println(root.val); } }题6：重建二叉树题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如：前序遍历序列｛ 1, 2, 4, 7, 3, 5, 6, 8｝和中序遍历序列｛4, 7, 2, 1, 5, 3, 8,6}，重建出下图所示的二叉树并输出它的头结点。函数使用：Arrays.copyOfRange(preSort, 1, i + 1) import java.util.Arrays; class BinaryTreeNode{ public int value=0; public BinaryTreeNode leftNode; public BinaryTreeNode rightNode; } public class Main { public static void main(String[] args) throws Exception{ int[] preSort = {1, 2, 4, 7, 3, 5, 6, 8}; int[] inSort = {4, 7, 2, 1, 5, 3, 8, 6}; BinaryTreeNode root = constructCore(preSort, inSort); System.out.print(root.value+\" \"+root.leftNode.value+\" \"+root.rightNode.value); } public static BinaryTreeNode constructCore(int[] preSort, int[] inSort) throws Exception { if(preSort==null||inSort==null){ return null; } if(preSort.length!=inSort.length){ throw new Exception(\"长度不一样，非法的输入！\"); } BinaryTreeNode root = new BinaryTreeNode(); for (int i = 0; i &lt; preSort.length; i++) { if (preSort[0] == inSort[i]) { root.value = preSort[0]; root.leftNode = constructCore(Arrays.copyOfRange(preSort, 1, i + 1), Arrays.copyOfRange(inSort, 0, i)); root.rightNode = constructCore(Arrays.copyOfRange(preSort, i + 1, preSort.length), Arrays.copyOfRange(inSort, i + 1, inSort.length)); } } return root; } }题7：两个栈实现队列题目：用两个栈实现一个队列。队列的生命如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 import java.util.Stack; public class Main&lt;T&gt; { private Stack&lt;T&gt; stack1=new Stack&lt;T&gt;(); private Stack&lt;T&gt; stack2=new Stack&lt;T&gt;(); public void appendTail(T t){ stack1.push(t); } public T deleteHead() throws Exception{ if(stack2.isEmpty()){ if(!stack1.isEmpty()){ stack2.push(stack1.pop()); } } if(stack2.isEmpty()){ throw new Exception(\"队列为空，不能删除！\"); } return stack2.pop(); } public static void main(String[] args) throws Exception{ Main&lt;String&gt; p7=new Main&lt;&gt;(); p7.appendTail(\"1\"); p7.appendTail(\"2\"); p7.appendTail(\"3\"); System.out.println(p7.stack1); //[1, 2, 3] p7.deleteHead(); System.out.println(p7.stack1); // [1, 2] System.out.println(p7.deleteHead()); // 2 System.out.println(p7.stack1); // [1] } }题8：旋转数组的最小数字题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之数组的旋转。输入一个递增排序的数组的一个旋转， 输出旋转数组的最小元素。例如数组{3 ,4,5, 1, 2 ｝为｛ 1,2,3, 4,5}的一个旋转，该数组的最小值为 1。 public class Main { public static void main(String[] args) { // int [] array={3 ,4,5, 1, 2 }; int [] array={1 ,1,1, 2, 0 }; // int [] array={1 ,1,1, 0, 1 }; System.out.println(findMin(array)); } public static Integer findMin(int [] arr){ if(arr==null) return null; int start=0; int end=arr.length-1; while (start&lt;end){ int mid=(start+end)/2; if(arr[mid]&gt;arr[end]){ start=mid+1; }else if(arr[mid]&lt;arr[end]){ end=mid; }else{ start++; end--; } } return arr[start]; } }题9：斐波那契数列写一个函数，输入n，求斐波那契（Fibonacci) 数列的第n项 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); System.out.println(Fibonacci(n)); } public static long Fibonacci(int n){ long res=0; long numb1=0; long numb2=1; if(n==0){ return numb1; } if(n==1){ return numb2; } while(n!=1){ res=numb1+numb2; numb1=numb2; numb2=res; n--; } return res; } }题10：二进制中1的个数请实现一个函数， 输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001 ，有2位是1. 因此如果输入9，该出2。 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); System.out.println(numberOf1(n)); } public static int numberOf1(int n){ int count=0; while (n!=0){ n=n&amp;(n-1); count++; } return count; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}]},{"title":"LeetCode解题思路(一)","slug":"LeetCode解题思路-一","date":"2017-06-26T14:48:16.000Z","updated":"2017-08-05T15:00:00.001Z","comments":true,"path":"2017/06/26/leetcode-jie-ti-si-lu-yi/","link":"","permalink":"http://www.zhoudamin.com/2017/06/26/leetcode-jie-ti-si-lu-yi/","excerpt":"做的一些题的解题思路","text":"做的一些题的解题思路 Product of Array Except Self除本身之外的数组之积Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].Solve it without division and in O(n).For example, given [1,2,3,4], return [24,12,8,6]. 解题思路：拆分法[A_234 , A_134 , A_124 , A_123 ]=[1 , A_1 , A_12 , A_123 ]*[A_234 , A_34 , A_4 , 1 ] /** * Created by Administrator on 2017/5/8. */ public class LeetCode { public static void main(String[] args) { // int [] nums={5, 7, 1, 8,3, 10}; //测试 int[] nums = {1, 3, 5, 6}; int k = 5; int [] res = productExceptSelf(nums); for (int i=0;i&lt;res.length;i++) { System.out.print(res[i]+\" \"); } } public static int[] productExceptSelf(int[] nums) { final int [] result = new int [nums.length]; final int [] right = new int [nums.length]; final int [] left = new int [nums.length]; left[0]=1; for(int i=1;i&lt;nums.length;i++){ left[i]=left[i-1]*nums[i-1]; } right[nums.length-1]=1; for(int i=nums.length-2;i&gt;=0;i--){ right[i]=right[i+1]*nums[i+1]; } for (int i=0;i&lt;nums.length;i++){ result[i]=right[i]*left[i]; } return result; } } # Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should:Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Your algorithm should run in O(n) time complexity and O(1) space complexity. Examples:Given [1, 2, 3, 4, 5],return true. Given [5, 4, 3, 2, 1],return false.用整数最大值去比较，x1记录第一个数，x2记录第二大的数，当出现第三大的数，则return true。 public class Solution { public boolean increasingTriplet(int[] nums) { int x1=Integer.MAX_VALUE; int x2=Integer.MAX_VALUE; for(int x: nums){ if(x&lt;=x1) x1=x; else if(x&lt;=x2) x2=x; else return true; } return false; } } # Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 维护一个HashMap,key为整数，value为下标，将数组中的元素不断添加到这个Hashmap中，遇到重复时，计算下标距离；用Integer.MAX_VALUE 设置为比较的初始值；学会用HashMap是非常关键的。 public class LeetCode { public static void main(String[] args) { int[] nums = {1, 3, 5, 1,6}; int k=3; System.out.print(containsNearbyDuplicate(nums,k)); } public static boolean containsNearbyDuplicate(int[] nums, int k) { final Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int min=Integer.MAX_VALUE; for(int i=0;i&lt;nums.length;i++){ if(map.containsKey(nums[i])){ final int preIndex=map.get(nums[i]); final int gap = i-preIndex; min = Math.min(min,gap); } map.put(nums[i],i); } return min&lt;=k; } } # Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8主要学习怎么创建链表，怎么定义链表 public class LeetCode { public static void main(String[] args) { int[] inputl1=new int[]{2,4,3}; int[] inputl2=new int[]{5,6,4}; ListNode l1=buildListNode(inputl1); ListNode l2=buildListNode(inputl2); ListNode listNode =addTwoNumbers(l1,l2); while(listNode!=null){ System.out.println(\"val \"+listNode.val); listNode=listNode.next; } } //定义链表 public static class ListNode{ int val; ListNode next; ListNode(int val){ this.val=val; this.next=null; } } //创建链表 private static ListNode buildListNode(int[] input){ ListNode first = null,last = null,newNode; int num; if(input.length&gt;0){ for(int i=0;i&lt;input.length;i++){ newNode=new ListNode(input[i]); newNode.next=null; if(first==null){ first=newNode; last=newNode; } else{ last.next=newNode; last=newNode; } } } return first; } /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ public static ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy =new ListNode(-1); int carry = 0; ListNode prev = dummy; for(ListNode pa=l1 , pb=l2 ; pa!=null || pb!=null ; pa=pa==null?null : pa.next, pb=pb==null ? null : pb.next, prev=prev.next){ final int ai=pa==null?0:pa.val; final int bi=pb==null?0:pb.val; final int value=(ai+bi+carry)%10; carry=(ai+bi+carry)/10; prev.next=new ListNode (value); } if(carry&gt;0) prev.next=new ListNode (carry); return dummy.next; } }Evaluate Reverse Polish Notation计算逆波兰表达式（又叫后缀表达式）的值 ‘’ 2 ‘’,’’ 1 ‘’,’’ + ‘’, ‘’3’’, ‘’* ‘’ –&gt;(2+1)*3–&gt;9 用堆栈遇到运算符则把前面两个拿出来运算 public class Main { public static void main(String[] args) { String []tokens={\"2\", \"1\", \"+\", \"3\", \"*\"}; System.out.print(evalRPN(tokens)); } public static int evalRPN(String [] tokens){ Stack&lt;String> s = new Stack&lt;>(); if(tokens.length==1){ return Integer.parseInt(tokens[0]); } for(String token:tokens){ if(!isOperator(token)){ s.push(token); }else { int y=Integer.parseInt(s.pop()); int x=Integer.parseInt(s.pop()); switch (token.charAt(0)){ case '+':x+=y;break; case '-':x-=y;break; case '*':x*=y;break; case '/':x/=y;break; } s.push(String.valueOf(x)); } } return Integer.parseInt(s.peek()); } private static boolean isOperator(final String op){ return op.length() == 1 &amp;&amp; OPS.indexOf(op)!=-1; } private static String OPS = new String(\"+-*/\"); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhoudamin.com/tags/LeetCode/"}]},{"title":"Efounds笔试","slug":"Efounds笔试","date":"2017-06-24T03:38:56.000Z","updated":"2018-04-25T03:34:43.221Z","comments":true,"path":"2017/06/24/efounds-bi-shi/","link":"","permalink":"http://www.zhoudamin.com/2017/06/24/efounds-bi-shi/","excerpt":"Efounds的笔试~","text":"Efounds的笔试~ 1.比较两个浮点数大小 一般不会直接用“==”或者“!=”对两个浮点数进行比较。 判断两个浮点数float a 与 float b 是否相等可以根据他们的差的绝对值是否大于0来进行判断。 判断相等： if（Math.abs(a-b)&lt;=0）{相等} 或者 if（!Math.abs(a-b)&gt;0）{相等} 判断不等： if（Math.abs(a-b)&gt;0）{不相等} 2，用最快排序找到无序的数组里第K大的数 public class AlgCode { public static void main(String[] args) { // int [] nums={5, 7, 1, 8,3, 10}; //测试 int [] nums= {3,1,4,7,5,8,0}; int k=5; int res= findKth(nums,0,nums.length-1,k-1); System.out.print(\"The Kth is: \"+res); } private static int findKth(int [] data ,int first , int last ,int k){ int kth; if(first==last) kth=data[first]; else { int pivot = data[first]; int splitPoint = partition(data, first, last); if (k &lt; splitPoint) kth = findKth(data, first, splitPoint - 1, k); else if(k&gt;splitPoint) kth = findKth(data, splitPoint + 1, last, k); else kth = pivot; } return kth; } private static int partition(int [] data ,int first , int last){ int pivot = data[first]; while(first&lt;last) { while (first &lt; last &amp;&amp; data[last] &gt; pivot) last--; data[first] = data[last]; while (first &lt; last &amp;&amp; data[first] &lt; pivot) first++; data[last] = data[first]; } data[first]=pivot; return first; } }3，单链表是否有环并如何找到环入口首先要了解什么叫环，如图，Join.next-&gt;Pos，Pos.next-&gt;Join，那么该链表有环 public class LinkedLoop{ //内部静态类定义结点类 static class Node{ int val; Node next; public Node(int val){ this.val = val; } } //判断单链表是否有环 public static boolean hasLoop(Node head){ Node p1=head; //指向头节点 Node p2=head.next; //指向下一个节点 while(p2!=null &amp;&amp;p2.next!=null){ p1=p1.next; p2=p2.next.next; if(p2==null){ return false; } int val1=p1.val; int val2=p2.val; if(val1==val2) return true; } return false; } public static void main(String [] args){ Node n1=new Node(1); Node n2=new Node(3); Node n3=new Node(6); Node n4=new Node(4); Node n5=new Node(5); Node n6=new Node(10); n1.next = n2; n2.next = n3; n3.next = n4; n4.next = n5; n5.next = n6; n6.next = n5; System.out.println(hasLoop(n1)); } }4，快排第一次排列后的顺序 int [] nums= {3,1,4,7,5,8,0}; 如果基准为3； 第一次快排后: nums={0,1,3,7,5,8,4}; 5，Java 数据输入 int a =0; Scanner input = new Scanner(System.in); System.out.println(\"输入数字:\"); a = input.nextInt();6，软件生命周期 软件生命周期(SDLC，Systems Development Life Cycle,SDLC)是软件的产生直到报废或停止使用的生命周期。软件生存周期包括： 一，问题定义。要求系统分析员与用户进行交流，弄清“用户需要计算机解决什么问题”然后提出关于“系统目标与范围的说明”，提交用户审查和确认。 二，可行性研究。一方面在于把待开发的系统的目标以明确的语言描述出来，另一方面从经济、技术、法律等多方面进行可行性分析。 三，需求分析。弄清用户对软件系统的全部需求，编写需求规格说明书和初步的用户手册，提交评审。 四，开发阶段。开发阶段由三个阶段组成：1，设计2，实现：根据选定的程序设计语言完成源程序的编码。3，测试 五，维护：维护包括四个方面1，改正性维护：在软件交付使用后，由于开发测试时的不彻底、不完全、必然会有一部分隐藏的错误被带到运行阶段，这些隐藏的错误在某些特定的使用环境下就会暴露。2，适应性维护：是为适应环境的变化而修改软件的活动。3，完善性维护 ：是根据用户在使用过程中提出的一些建设性意见而进行的维护活动。4，预防性维护：是为了进一步改善软件系统的可维护性和可靠性，并为以后的改进奠定基础。 7,多线程和多进程的区别a.进程是资源分配的基本单位，线程是cpu调度，或者说是程序执行的最小单位。在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。 b.进程有独立的地址空间，比如在linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的局部变量和堆栈（注意不是堆）的，比如在windows中用_begin threadex创建一个新进程就会在调用CreateThread的同时申请一个专属于线程的数据块（_tiddata)。 c.线程之间的通信比较方便。统一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过进程通信的方式进行。 d.由b，可以轻易地得到结论：多进程比多线程程序要健壮。一个线程死掉整个进程就死掉了，但是在保护模式下，一个进程死掉对另一个进程没有直接影响。 e.线程的执行与进程是有区别的。每个独立的线程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附与程序之中，由应用程序提供多个线程的并发控制。 8,多线程同步和互斥有何异同，在什么情况下分别使用他们？举例说明 所谓同步，表示有先有后，比较正式的解释是“线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。” 所谓互斥，比较正式的说明是“线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。”表示不能同时访问，也是个顺序问题，所以互斥是一种特殊的同步操作。 举个例子，设有一个全局变量global，为了保证线程安全，我们规定只有当主线程修改了global之后下一个子线程才能访问global，这就需要同步主线程与子线程，可用关键段实现。当一个子线程访问global的时候另一个线程不能访问global，那么就需要互斥。 9,网络协议：访问某个网址都经过了哪些协议·域名解析协议DNS应用层协议，网址相当于是域名，访问DNS服务器，这个过程有域名解析协议，解析出域名对应的IP地址。 ·超文本传输协议HTTP应用层协议，基于请求和响应的协议，通过请求行、消息报头、请求正文向目的地址发送请求。目的服务器在接受请求后，返回一个状态行、消息报头、响应正文的响应。 ·传输控制协议TCP传输层协议，HTTP协议是基于TCP协议的，也就是说HTTP无论是请求还是响应都是把HTTP的内容作为TCP的正文封装到TCP的报文中的。TCP协议是传输安全，面向连接的协议，在客户端和服务端建立TCP/IP五层模型的协议 连接的过程中需要经过三次握手，发送第一个SYN的一端将执行主动打开，接收这个SYN并发回下一个SYN的另一端执行被动打开，以及四次释放的过程才停止发送数据。 ·网际协议IP协议IP协议在整个传输过程中都起着重要的作用，网址通过DNS解析为IP地址，在TCP建立连接以及传输数据的整个过程中都在使用着IP协议。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"http://www.zhoudamin.com/tags/%E7%AC%94%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"Java之查找算法","slug":"Java之查找算法","date":"2017-06-22T02:57:01.000Z","updated":"2018-07-26T15:29:16.128Z","comments":true,"path":"2017/06/22/java-zhi-cha-zhao-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2017/06/22/java-zhi-cha-zhao-suan-fa/","excerpt":"用Java实现一些基本查找算法。","text":"用Java实现一些基本查找算法。 Search for a Range描述Given a sorted array of integers, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n) .If the target is not found in the array, return [-1, -1] .For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4] .分析已经排好了序，用二分查找。重新实现 lower_bound 和 upper_boundSearch for a Range // Search for a Range // 重新实现 lower_bound 和 upper_bound // 时间复杂度O(logn)，空间复杂度O(1) public class Solution{ private static int[] searchRange(int [] nums,int target){ int lower=lower_bound(nums,0,nums.length,target); int high=upper_bound(nums,0,nums.length,target); if(lower == nums.length || nums[lower]!=target) return new int[]{-1,-1}; else return new int[]{lower,high-1}; } private static int lower_bound(int [] A , int first ,int last ,int target){ while(first!=last){ int mid=(first+last)/2; if(target&gt;A[mid]) first=++mid; else last=mid; } return first; } private static int upper_bound(int [] A , int first ,int last ,int target){ while(first!=last){ int mid=(first+last)/2; if(target&gt;=A[mid]) first=++mid; //找到最远边界 else last=mid; } return first; } }Search Insert Position描述Given a sorted array and a target value, return the index if the target is found. If not, return the indexwhere it would be if it were inserted in order.You may assume no duplicates in the array.Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0分析即 std::lower_bound() 。 public static int searchInsert(int [] nums , int target){ int first=0; int last=nums.length; while(first!=last){ int mid=(first+last)/2; if(target&gt;nums[mid]) first=mid+1; else last=mid; } return first; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"Java实现常见排序算法","slug":"Java实现常见排序算法","date":"2017-06-21T08:44:12.000Z","updated":"2017-06-27T01:59:45.933Z","comments":true,"path":"2017/06/21/java-shi-xian-chang-jian-pai-xu-suan-fa/","link":"","permalink":"http://www.zhoudamin.com/2017/06/21/java-shi-xian-chang-jian-pai-xu-suan-fa/","excerpt":"一些常见的排序算法实现！","text":"一些常见的排序算法实现！ ·查找算法典型的二分查找对于二分查找算法要求, 查找前的数据必须是已经排好序的, 然后得到数组的开始位置start和结束位置end, 取中间位置mid的数据a[mid]跟待查找数据key进行比较, 若 a[mid] &gt; key, 则取end = mid - 1; 若 a[mid] &lt; key, 则取start = mid + 1; 若 a[mid] = key 则直接返回当前mid为查找到的位置. 依次遍历直到找到数据或者最终没有该条数据. public static int binarySearch(int [] nums , int key ){ int start =0; int end = nums.length-1; while(start&lt;end){ int mid = (end+start)/2; if(nums[mid]&gt;key){ end=mid-1; }else if(nums[mid]&lt;key){ start=mid+1; }else{ return mid; } } return -1; }·插入排序插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i] 又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤ L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j] ≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过程，共需要(a),(b),(c)三次插入稳定，时间复杂度 O(n^2) public static void insertSort(int [] a){ for(int i=2 ; i&lt; a.length ;i++ ){ if(a[i]&lt;a[i-1]){ a[0]=a[i]; a[i]=a[i-1]; int j=0; for(j= i-2;a[j]&gt;a[0];j--){ a[j+1]=a[j]; } a[j+1]=a[0]; } } }·选择排序选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。 不稳定, 时间复杂度 O(n^2) public static void selectSort(int [] a){ for(int i=1 ; i&lt;a.length ;i++){ int j=selectMinKey(a,i); if(i!=j){ swap(a,i,j); } } } private static int selectMinKey(int [] a, int i){ int key=i; for(int j=i+1;j&lt;a.length;j++){ if(a[j]&lt;a[key]){ key=j; } } return key; }·冒泡排序冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。显然，处理一遍之后，“最轻”的元素就浮到了最高位置；处理二遍之后，“次轻”的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是“最轻”元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。 稳定，时间复杂度 O(n^2) public static void bubbleSort(int [] a){ for(int i=0;i&lt;a.length-1;i++){ for(int j=i;j&lt;a.length;j++){ if(a[j+1]&lt;a[j]){ swap(a,j+1,j); } } } }·快速排序不稳定，时间复杂度 最理想 O(nlogn) 最差时间O(n^2) 快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。 public static void quickSort(int [] a,int low ,int high){ int pivotLoc=0;//中心点 if(low&lt;high){ pivotLoc=partitionLoc(a,low,high); quickSort(a,low,pivotLoc-1); quickSort(a,pivotLoc+1,high); } } //获取到a的下标 low ~ high 中, a[low]的应该放的位置, 即左边的数 &lt; a[low] 右边的数 &gt; a[low] private static int partitionLoc(int [] a,int low ,int high){ a[0]=a[low]; while(low&lt;high){ while(low&lt;high &amp;&amp; a[high]&gt;a[0]){ high--; } a[low]=a[high]; while( low &lt; high &amp;&amp; a[low]&lt;=a[0]){ low++; } a[high] = a[low]; } a[low]=a[0]; return low; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"JS Notes","slug":"JS-Notes","date":"2017-05-20T03:14:42.000Z","updated":"2018-04-25T03:35:44.174Z","comments":true,"path":"2017/05/20/js-notes/","link":"","permalink":"http://www.zhoudamin.com/2017/05/20/js-notes/","excerpt":"项目需求，初学JS Notes。","text":"项目需求，初学JS Notes。 1.基础常用函数 alert(\"提示框\"); document.write(\"输出内容\");定义变量 var 变量名=值;内置对象 String 对象 Number 对象 Boolean 对象 Math 对象 Date 对象 Array 对象自定义对象 Java：用class 来定义对象 JS：用 function 来定义对象 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.zhoudamin.com/tags/JS/"}]},{"title":"二维码前沿发展","slug":"二维码前沿发展","date":"2017-04-26T09:21:07.000Z","updated":"2017-05-13T06:13:42.781Z","comments":true,"path":"2017/04/26/er-wei-ma-qian-yan-fa-zhan/","link":"","permalink":"http://www.zhoudamin.com/2017/04/26/er-wei-ma-qian-yan-fa-zhan/","excerpt":"二维码纠错、定位、去模糊都已经研究很透了，现在很多公司都在推自己的闭源码！","text":"二维码纠错、定位、去模糊都已经研究很透了，现在很多公司都在推自己的闭源码！ Facebook正努力使之用户在Messenger上更容易互相联系，所以它推出了许多新方式来让用户聊天。Messenger用户现在已经有专门的个人链接（m.me/username），让对方可以访问并且开始聊天。Facebook也推出了所谓的Messenger Codes，这相当于Snapchat的Snapcodes。 现在从安全性考虑，大家都在做自己的闭源码！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"二维码","slug":"二维码","permalink":"http://www.zhoudamin.com/categories/%E4%BA%8C%E7%BB%B4%E7%A0%81/"}],"tags":[{"name":"二维码","slug":"二维码","permalink":"http://www.zhoudamin.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"}]},{"title":"算法总结","slug":"算法总结","date":"2017-04-24T08:15:30.000Z","updated":"2017-05-03T02:35:40.839Z","comments":true,"path":"2017/04/24/suan-fa-zong-jie/","link":"","permalink":"http://www.zhoudamin.com/2017/04/24/suan-fa-zong-jie/","excerpt":"一些常用算法分类总结","text":"一些常用算法分类总结 1.字符串 ·字符串(String) 通常把它作为字符数组 java : String内置类型，不可更改，要更改的话可考虑转StringBuffer, StringBuilder, char []之类 Java: ［0..65535] ·和数组相关，内容广泛 概念理解：字典序 简单操作：插入、删除字符，旋转 规则判断 （罗马数字转换 是否是合法的整数、浮点数） 数字运算（ 大数加法、二进制加法） 排序、交换 （partition过程） 字符计数（hash)：变位词 匹配 （正则表达式、全串匹配、KMP、周期判断） 动态规划 (LCS、编辑距离、最长回文子串） 搜索 （单词变换、排列组合） 总结： ·我理解的in-place (原地） 本身O(1)空间 递归，堆栈空间可以不考虑 ·原地相关的问题 字符串循环左移、右移动 快排partition相关 ·滑动窗口 能达到O(n)的的时间复杂度 O(1)的空间复杂度 ·规则相关——细致 ·匹配 （暴力）：KMP比较少见 ·Manacher——要求比较高的笔试2.数组 ·数组(array) java : [], ArrayList 数组下标是一种特殊的hash…做计数 理解数组与map 给数组“顺序” ·查找和排序 二分查找 元素交换 排序，中位数 归并 位运算 前缀和的应用 ·动态规划 ·排列组合 总结： ·利用序 理解二分查找 ·利用前缀和 查找、计算、排序 ·理解数组 map ·用数组实现高级数据结构 一般树： 存每个节点的父亲 （并查集） 二叉树： 下标从1开始a[i]的儿子是a[i * 2]和a[i * 2 + 1] (堆） ·抓住简单题 分治法求逆序对数 有序数组归并 两个有序数组的中位数 两头扫的方法 （2-SUM, 3-SUM)3.栈和队列简介： 堆栈和队列统称线性表 简单的线性结构 数组和链表可以实现这两种数据结构 堆栈 后进先出 (Last In First Out) 队列 先进先出 (First In First Out) 面试题总体分析： 堆栈 基本理解 DFS 深度优先——按深度遍历 递归转非递归 队列 基本理解 BFS 广度优先——按层序遍历 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"}]},{"title":"上交会防伪展总结","slug":"上交会防伪展总结","date":"2017-04-24T07:38:49.000Z","updated":"2017-04-24T07:47:31.107Z","comments":true,"path":"2017/04/24/shang-jiao-hui-fang-wei-zhan-zong-jie/","link":"","permalink":"http://www.zhoudamin.com/2017/04/24/shang-jiao-hui-fang-wei-zhan-zong-jie/","excerpt":"防伪，是企业在目前社会诚信缺失、假冒伪劣商品扰乱企业正常经营和损害企业、消费者利益的情况下，为保护企业品牌、保护市场、保护广大消费者合法权益而采取的一种防范性技术措施。","text":"防伪，是企业在目前社会诚信缺失、假冒伪劣商品扰乱企业正常经营和损害企业、消费者利益的情况下，为保护企业品牌、保护市场、保护广大消费者合法权益而采取的一种防范性技术措施。 这次博览会主要学习到了几类防伪技术： 激光防伪材料用特殊材料做成全息图案，达到人眼辨别真假的目的，如恒大冰泉的瓶盖贴标；缺点：全息材料防伪技术发展很成熟，防伪材料容易被仿制。 纸张防伪纸张防伪技术主要用于纸币、贵重物品包装防伪。该防伪技术关键在于复制印刷版的难度大。该技术首先需要根据需求图案刻板，然后印刷出有图案的纸张，用该纸张印刷纸币或者用该纸张包装商品，以达到防伪目的，难点在于，如果没有源板，无法印刷出相同图案的纸张，如果按照纸张图案仿制印刷板，难度很大。 三阖追溯提出该方案的公司为珠海三纬码信息技术有限公司，该技术主要服务对象为中高端产品，流程如下：1）首先生产厂家对每一个产品提供一个编号和密码，编号存入二维码中，密码存入系统数据库中。然后物流信息根据扫描二维码得到商品编号存入数据库中。2）当商品到达专卖店时，专卖店扫描二维码入库，可以从系统得到编号以及密码；3）当客户去专卖店买该商品时，专卖店根据系统查询编号，给客户密码，客户可根据二维码中的编号和密码去官网查询，如果编号和密码正确，则显示该商品所有信息，信息包括商品信息、商品状态及溯源信息；4）当专卖店出售该商品时，扫描二维码会传递信息回到系统，将商品状态：待售改为售出！故该商品无法再二次销售，避免了掉包商品二次销售的风险！ 公众号扫描防伪用公司公众号扫描商品二维码，进入页面溯源，优点是公司公众号是唯一的，从公众号进入，避免了进入假页面的风险！该方案是为了解决一般溯源扫描二维码进入假页面，欺骗消费者的风险！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"防伪","slug":"防伪","permalink":"http://www.zhoudamin.com/categories/%E9%98%B2%E4%BC%AA/"}],"tags":[{"name":"二维码防伪","slug":"二维码防伪","permalink":"http://www.zhoudamin.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%98%B2%E4%BC%AA/"}]},{"title":"链表","slug":"链表","date":"2017-04-13T09:40:39.000Z","updated":"2017-04-14T07:50:22.340Z","comments":true,"path":"2017/04/13/lian-biao/","link":"","permalink":"http://www.zhoudamin.com/2017/04/13/lian-biao/","excerpt":"链表基础总结。","text":"链表基础总结。 1.遍历 for(Node x=first ; x!=null ; x=x.next){ //处理x.item }2.定义链表 private class Data{ private object obj; private Data next=null; Data(Object obj){ this.obj=obj; } }3.首节点为空 private Data first=null;4.insertFirst ： 在表头插入一个新的链接点，时间复杂度为O(1) public void insertFirst(Object obj){ Data data=new Data(obj); data.next=first; first=data; }5.deleteFirst :删除表头首节点，时间复杂度为O(1) public Object deleteFirst() throws Exception{ if(first==null){ throw new Exception(\"empty!\"); } Data temp=first; first=first.next; return temp.obj; }6.find: 查找包含指定关键字的链接点，遍历查找，平均需要查找N/2次,即O(N) public Object find (Object obj) throws Exception{ if(first ==null){ throw new Exception(\"LinkedList is empty!\"); } Data cur=first; while (cur!=null){ if(cur.obj.equals(obj)){ return cur.obj; } cur=cur.next; } return null; }7.remove ：删除包含指定关键字的链接点，遍历查找，平均需要查找N/2次,即O(N) public void remove(Object obj) throws Exception{ if(first == null) throw new Exception(\"LinkedList is empty!\"); if(first.obj.equals(obj)){ first=first.next; }else{ Data pre = first; Data cur = first.next; while(cur!=null){ if(cur.obj.equals(obj)){ pre.next=cur.next; } pre=cur; cur=cur.next; } } }8.isEmpt public boolean isEmpty(){ return (first==null); }9.打印链表 public void display(){ if(first==null) System.out.println(\"empty\"); Data cur=first; while(cur!=null){ System.out.print(cur.obj.toString()+\"-&gt;\"); cur=cur.next; } System.out.print(\"\\n\"); }10.删除指定节点 public void deleteNode(ListNode node) { if(node!=null&amp;&amp;node.next!=null){ node.val=node.next.val; node.next=node.next.next; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://www.zhoudamin.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Java笔记","slug":"Java笔记","date":"2017-04-05T04:36:47.000Z","updated":"2020-04-23T15:44:06.213Z","comments":true,"path":"2017/04/05/java-bi-ji/","link":"","permalink":"http://www.zhoudamin.com/2017/04/05/java-bi-ji/","excerpt":"Java笔记","text":"Java笔记 动态数组ArrayList&lt;String&gt; List = new ArrayList&lt;String&gt;(); //定义动态数组 List.add(temp); //添加字符串 List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); ret.add(i+1); 分割字符串单词String.Trim 方法 ·Trim() 从当前 String 对象移除所有前导空白字符和尾部空白字符。 java.lang.string.split split 方法 将一个字符串分割为子字符串，然后将结果作为字符串数组返回。 String[] res = s.trim().split(\"\\\\s+\"); 将头尾空格去掉，并且切割成单词 sb.append(res[i]).append(\" \"); //每次添加 单词+“ ” 组合 return sb.toString().trim(); //将字符串头尾空格去掉 数字转化成字母，存在字符串中arr.insert(0,(char)('A'+n%26));进制转换函数十进制转成十六进制： Integer.toHexString(int i) 十进制转成八进制 Integer.toOctalString(int i) 十进制转成二进制 Integer.toBinaryString(int i) 十六进制转成十进制 Integer.valueOf(\"FFFF\",16).toString() 八进制转成十进制 Integer.valueOf(\"876\",8).toString() 二进制转十进制 Integer.valueOf(\"0101\",2).toString() 数组·整数转为二进制 Integer.toBinaryString(i)； 数组排序· Arrays.sort(nums); Set：Set s=new HashSet(); contains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。 add()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。 remove如果指定元素存在于此 set 中，则将其移除。 clear从此 set 中移除所有元素。 Java.lang.Character.getNumericValue()方法·java.lang.Character.getNumericValue(char ch) 返回指定Unicode字符表示的int值。例如，字符'\\ u216C'（罗马数字50）将返回一个int值50。 ·字母的大写的AZ（'\\ u0041'到'\\ u005A'），小写字母（'\\ u0061'到'\\ u007A'），全宽度变体（'\\ uFF21“的通过'\\ uFF3A'和'\\ uFF41”通过'\\ uFF5A'）的形式从10到35的数值。这是独立的Unicode规范，这些字符的值不分配数值。 ·如果该字符没有一个数字值，则返回-1。如果字符具有一个数字值，该值不能被表示为一个非负整数（例如，一个分数值），则返回-2。基础import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Main{ public static void print(int index ,Object obj){ System.out.println(String.format(\"{%d},%s\",index,obj.toString())); } public static void main(String[] args){ //demoString(); demoList(); } public static void demoList(){ List&lt;String&gt; strList=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;4;i++){ strList.add(String.valueOf(i)); } print(1,strList); List&lt;String&gt; strListB=new ArrayList&lt;String&gt;(); for(int i=0;i&lt;4;i++){ strListB.add(String.valueOf(i*i)); } strList.addAll(strListB); print(2,strList); strList.remove(0); print(3,strList); strList.remove(String.valueOf(1)); print(4,strList); print(5,strList.get(1)); Collections.sort(strList); print(6,strList); Collections.sort(strList, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o2.compareTo(o1); } }); print(7,strList); } /* {1},[0, 1, 2, 3] {2},[0, 1, 2, 3, 0, 1, 4, 9] {3},[1, 2, 3, 0, 1, 4, 9] {4},[2, 3, 0, 1, 4, 9] {5},3 {6},[0, 1, 2, 3, 4, 9] {7},[9, 4, 3, 2, 1, 0] */ public static void demoString(){ String str=\"Hello nowcoder\"; print(1,\"Hello!\"); print(2,str.charAt(6)); print(3,str.codePointAt(1)); print(4,str.compareTo(\"Hello mewcoder\")); print(5,str.compareTo(\"Hello pewcoder\")); print(6,str.contains(\"Hello\")); print(7,str.indexOf('e')); print(8,str.compareToIgnoreCase(\"Hello Nowcoder\")); print(9,str.concat(\"!!\")); print(10,str.endsWith(\"nowcoder\")); print(11,str.startsWith(\"Hello\")); print(12,str.lastIndexOf('o')); print(13,str.toUpperCase()); print(14,str.replace('o','a')); print(15,str.replaceAll(\"o|l\",\"a\")); print(16,str.replaceAll(\"Hello\",\"hi\")); StringBuilder sb =new StringBuilder(); sb.append(true); sb.append(1); sb.append(2.2); print(17,sb.toString()); print(18,\"a\"+\"b\"+String.valueOf(12)); } /*{1},Hello! {2},n {3},101 {4},1 {5},-2 {6},true {7},1 {8},0 {9},Hello nowcoder!! {10},true {11},true {12},10 {13},HELLO NOWCODER {14},Hella nawcader {15},Heaaa nawcader {16},hi nowcoder {17},true12.2 {18},ab12 */ } 数组随机打乱List&lt;Integer&gt; array = Arrays.asList(new Integer[]{1,2,3,4,5}); Collections.shuffle(array); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.zhoudamin.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Algorithms code","slug":"Algorithms-code","date":"2017-04-03T03:37:50.000Z","updated":"2018-04-25T03:34:31.616Z","comments":true,"path":"2017/04/03/algorithms-code/","link":"","permalink":"http://www.zhoudamin.com/2017/04/03/algorithms-code/","excerpt":"一些值得回看的小算法。","text":"一些值得回看的小算法。 最长的连续子数组子数组数字不重复 int [] arr={1,2,3,4,7}; //输出4 int [] arr1={1,2,3,4,1,2,3,4,5,1}; //输出5 package RecursiveAndDynamic; /** * Created by zdmein on 2017/9/2. * 最长的连续子数组（子数组数字不重复） * int [] arr={1,2,3,4,7}; 输出4 * int [] arr1={1,2,3,4,1,2,3,4,5,1}; 输出5 */ public class longestSubArr1 { public static void main(String [] args){ int [] arr={1,2,3,4,7}; int [] arr1={1,2,3,4,1,2,3,4,5,1}; longestSubArr(arr1); } public static void longestSubArr(int [] arr){ if(arr==null||arr.length==0){ return; } int len=1; int maxlen=1; for(int i=1;i&lt;arr.length;i++){ if(arr[i]==arr[i-1]+1){ len++; maxlen=Math.max(len,maxlen); }else { len=1; } } System.out.println(maxlen); } } 删除链表中的元素样例给出链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;3, 和 val = 3, 你需要返回删除3之后的链表：1-&gt;2-&gt;4-&gt;5。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ public class Solution { /** * @param head a ListNode * @param val an integer * @return a ListNode */ public ListNode removeElements(ListNode head, int val) { // Write your code here if(head==null) return head; ListNode p=head,q=head.next; while(q!=null){ if(q.val==val){ p.next=q.next; q=q.next; }else{ p=p.next; q=q.next; } } if(head.val==val) head=head.next; return head; } }求n的阶乘结果后有几个零//结果后的零是由n中的5组成的，多少个5就有多少个0，所以只需要统计有多少5就可以了 public class Solution { public int trailingZeroes(int n) { int rs=0; while(n!=0){ rs+=n/5; n/=5; } return rs; } } 统计小于n的素数个数我写的用 n/2;改进为 Math.sqrt(n)；复杂度还是高了点； public class Solution { public int countPrimes(int n) { boolean [] notPrimes = new boolean[n]; int count =0; for(int i=2;i&lt;n;i++){ if(notPrimes[i]==false){ count++; for(int j=2;i*j&lt;n;j++){ notPrimes[i*j]=true; } } } return count; } }这个算法降低了复杂度，值得学习！！ 同构字符串Given “egg”, “add”, return true.Given “foo”, “bar”, return false.Given “paper”, “title”, return true.即结构相同我的 public class Solution { public boolean isIsomorphic(String s, String t) { int [] count=new int [s.length()]; for(int i=0;i&lt;s.length();i++){ count[i]=s.charAt(i)-t.charAt(i); for(int j=0;j&lt;i;j++){ if(s.charAt(i)==s.charAt(j)){ if(count[i]!=count[j]){ return false; } } if(t.charAt(i)==t.charAt(j)){ if(count[i]!=count[j]){ return false; } } } } return true; } }降低复杂度,用数组装字符，很重要的思想！ public class Solution { public boolean isIsomorphic(String s, String t) { int [] m=new int [256]; int [] n=new int [256]; for(int i=0;i&lt;s.length();i++){ if(m[s.charAt(i)]!=n[t.charAt(i)]){ return false; } m[s.charAt(i)]=i+1; //关键部分，通过i，实现错位 n[t.charAt(i)]=i+1; //不同位置加的值不同 } return true; } }组合成最大的数given [3, 30, 34, 5, 9], the largest formed number is 9534330.[0,0]，输出0. public class Solution { public String largestNumber(int[] nums) { String [] rs=new String[nums.length]; String sb=new String(); for(int i=0;i&lt;nums.length;i++){ rs[i]=String.valueOf(nums[i]); } for(int j=0;j&lt;nums.length-1;j++){ for(int i=0;i&lt;nums.length-j-1;i++){ String s1=rs[i]+rs[i+1]; String s2=rs[i+1]+rs[i]; if(s2.compareTo(s1)&gt;0){ String temp=rs[i]; rs[i]=rs[i+1]; rs[i+1]=temp; } } } for(int i=0;i&lt;nums.length;i++){ sb+=rs[i]; } if(sb.charAt(0) == '0') return \"0\"; return sb; } }判断n是不是2的幂只需要将n转化为二进制，然后计算二进制位里面有多少个1，如果计数为1，那么n是2的幂 快乐数写一个算法来判断一个数是不是”快乐数”。 一个数是不是快乐是这么定义的：对于一个正整数，每一次将该数替换为他每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，或是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。 您在真实的面试中是否遇到过这个题？ Yes样例19 就是一个快乐数。 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 public class Solution { /** * @param n an integer * @return true if this is a happy number or false */ public boolean isHappy(int n) { // Write your code here Set&lt;Integer&gt; inLoop = new HashSet&lt;Integer&gt;(); int squareSum,remain; while (inLoop.add(n)) { squareSum = 0; while (n &gt; 0) { remain = n%10; squareSum += remain*remain; n /= 10; } if (squareSum == 1) return true; else n = squareSum; } return false; } }Add BinaryGiven two binary strings, return their sum (also a binary string). For example,a = “11”b = “1”Return “100”. package leetCode; public class Temp { public static void main(String [] args) { String a=\"11\"; String b=\"1\"; System.out.print(addBinary(a,b)); } public static String addBinary(String a, String b) { if(a == null || a.isEmpty()) return b; if(b == null || b.isEmpty()) return a; StringBuilder stb = new StringBuilder(); int i = a.length() - 1; int j = b.length() - 1; int aBit; int bBit; int carry = 0; int result; while(i &gt;= 0 || j &gt;= 0 || carry == 1) { aBit = (i &gt;= 0) ? Character.getNumericValue(a.charAt(i--)) : 0; bBit = (j &gt;= 0) ? Character.getNumericValue(b.charAt(j--)) : 0; result = aBit ^ bBit ^ carry; carry = ((aBit + bBit + carry) &gt;= 2) ? 1 : 0; stb.append(result); } return stb.reverse().toString(); } } 徒手开平方·牛顿法-直线逼近原理 package leetCode; public class Temp { public static void main(String [] args) { int a=7; System.out.print(mySqrt(a)); } public static int mySqrt(int x) { long rs=x; while(rs*rs&gt;x){ rs=(rs+x/rs)/2; } return (int)rs; } } # 数学之美 —— 0x5f375a86float InvSqrt(float x){ float xhalf = 0.5fx; int i = *(int)&amp;x; // get bits for floating VALUE i = 0x5f375a86- (i&gt;&gt;1); // gives initial guess y0 x = (float)&amp;i; // convert bits BACK to float x = x(1.5f-xhalfx*x); // Newton step, repeating increases accuracy return x;} # 两数字字符串相加 Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is &lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly.package leetCode; public class Temp{ public static void main(String [] args) { String a=”1001”; String b=”1341”; System.out.print(addStrings(a,b)); } public static String addStrings(String num1, String num2) { StringBuilder sb=new StringBuilder(); int carry=0; for(int i=num1.length()-1,j=num2.length()-1;i&gt;=0||j&gt;=0||carry==1;i--,j--){ int x=i&lt;0?0:num1.charAt(i)-'0'; int y=j&lt;0?0:num2.charAt(j)-'0'; sb.append((x+y+carry)%10); carry=(x+y+carry)/10; } return sb.reverse().toString(); }} # 字符串中出现多少字母 存一下有多少个非0次出现的int nonZero = 0; for (int i = 0; i &lt; lenb; ++i) if (++num[b[i] – ‘a’] == 1) ++nonZero; `` 12.单词翻转 ``翻转句子中全部的单词，单词内容不变例如I’m a student. 变为student. a I’m in-place翻转 字符串第i位到第j位while (i &lt; j) swap(s[i++], s[j–]);有什么用？翻转整个句子 ： .tneduts a m’I每个单词单独翻转： student. a I’m难点？ 如何区分单词？找空格，split # HashSet public static int[] intersection(int[] nums1, int [] nums2){ Set set= new HashSet&lt;&gt;(); Set interset=new HashSet&lt;&gt;(); for(int i=0;i&lt;nums1.length;i++){ set.add(nums1[i]); //存入不重复的值 } for(int i=0;i&lt;nums2.length;i++){ if(set.contains(nums2[i])){ //如果重复上个set数组里的值 interset.add(nums2[i]); //添加上个数组里有的值 } } int [] res=new int [interset.size()]; int i=0; for(Integer num:interset){ res[i++]=num; } return res; }} # 350. Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. 先排序，一个一个对比，相等的才存，不等就小的数组指针加1。 public static int[] intersection(int[] nums1, int [] nums2){ Arrays.sort(nums1); Arrays.sort(nums2); int p1=0; int p2=0; ArrayList myList= new ArrayList (); while((p1&lt;nums1.length)&amp;&amp;(p2&lt;nums2.length)){ if(nums1[p1]&lt;nums2[p2]){ p1++; }else{ if(nums1[p1]&gt;nums2[p2]){ p2++; }else{ myList.add(nums1[p1]); p1++; p2++; } } } int[] res= new int [myList.size()]; for(int i=0;i&lt;res.length;i++){ res[i]=myList.get(i); //ArrayList取值方法 } return res; //转化成正常数组输出 } # 将字符数组转化为字符串 public static String reverseString(String s) { char [] rs= new char[s.length()]; for(int i=0;i&lt;s.length();i++){ rs[i]=s.charAt(i); } for(int i=0;i&lt;s.length()/2;i++){ char temp=rs[i]; rs[i]=rs[s.length()-i-1]; rs[s.length()-i-1]=temp; } return new String(rs); //转化 } # 不用加号实现两数相加public int getSum(int a, int b) { return b == 0 ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; 1);} 合并排序数组合并两个排序的整数数组A和B变成一个新的数组。 给出A=[1,2,3,4]，B=[2,4,5,6]，返回** [1,2,2,3,4,4,5,6]** public class Solution { /* * @param A: sorted integer array A * @param B: sorted integer array B * @return: A new sorted integer array */ public int[] mergeSortedArray(int[] A, int[] B) { // write your code here int indexA=0; int indexB=0; int []C =new int [A.length+B.length]; int indexC=0; while(indexA!=A.length &amp;&amp; indexB!=B.length) { if (A[indexA] &lt; B[indexB]) { C[indexC++]=A[indexA++]; }else if (A[indexA] > B[indexB]) { C[indexC++]=B[indexB++]; }else { C[indexC++]=A[indexA++]; C[indexC++]=B[indexB++]; } } if(indexA==A.length &amp;&amp; indexB!=B.length){ for(int i=indexB;i&lt;B.length;i++){ C[indexC++]=B[i]; } } if(indexA!=A.length &amp;&amp; indexB==B.length){ for(int i=indexA;i&lt;A.length;i++){ C[indexC++]=A[i]; } } return C; } } 写代码：多线程实现从A,B,C三个文件中读取文件放到D文件中，优化：如何同步实现。 写一个单例模式，什么时候用到在某些情况下，有些对象只需要一个就可以了，即每个类只需要一个实例。单例模式的作用就是保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个。实现一个单例模式： public class Test{ private Test(){} private static Test uniqueInstance = new Test(); public static Test getInstence(){ return uniqueInstance; } } 由于在使用前就创建好了对象，因此，可以在多线程环境下使用这种方法。 装饰者模式是什么，举例装饰者模式通过组合的方式扩展对象的特性，这种方式允许我们在任何时候对对象的功能进行扩展，甚至是运行时扩展，而若我们用继承来完成对类的扩展，则只能在编译阶段实现，所以在某些时候装饰者模式比继承更灵活。 特征： 装饰者和被装饰者的对象有着共同的超类 我们可以用多个装饰者修饰一个对象 可以用修饰过的对象替代代码中的原对象 一个对象在任何时候都可以被装饰，甚至是运行时 应用场景：一家奶茶店，一杯奶茶是10元；如果加糖+2、加奶+3、加葡萄+5元…如果写类去继承，会要写n多个如果用装饰就直接在类里加价钱 return mTea.getPrice()+2; return mTea.getPrice()+15; return mTea.getPrice()+20; ----- mTea = new SimpleTea(); mTea = new SugarDecorator(mTea); mTea = new MilkDecorator(mTea); int price1 = mTea.getPrice(); System.out.println(\"price1=\"+price1); 写代码：找出字符数组中第一次只出现三次的字符package Array; /** * Created by zdmein on 2017/9/6. * 找出字符数组中第一次只出现三次的字符 思路： 1、统计各字符出现次数 2、遍历字符串，如果出现字符次数为3则输出该字符并跳出循环；否则如果不存在则输出\" . \" */ public class ThreeChar1 { public static void main(String [] args){ String str=\"abesabjdwsjibuhfrsadfesdsferewh\"; char [] chars=str.toCharArray(); ThreeChar(chars); } public static void ThreeChar(char [] chars){ if(chars==null||chars.length==0){ System.out.println(\".\"); } int [] res=new int[256]; for(int i=0;i&lt;chars.length;i++){ res[chars[i]]++; } for(int i=0;i&lt;chars.length;i++){ if(res[chars[i]]==3){ System.out.println(chars[i]); break; } } } } 验证身份证是否正确身份证号码验证 1、号码的结构 公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码， 八位数字出生日期码，三位数字顺序码和一位数字校验码。 2、地址码(前六位数） 表示编码对象常住户口所在县(市、旗、区)的行政区划代码，按GB/T2260的规定执行。 3、出生日期码（第七位至十四位） 表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。 4、顺序码（第十五位至十七位） 表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号， 顺序码的奇数分配给男性，偶数分配给女性。 5、校验码（第十八位数） （1）十七位数字本体码加权求和公式 S = Sum(Ai * Wi), i = 0, , 16 ，先对前17位数字的权求和 Ai:表示第i位置上的身份证号码数字值 Wi:表示第i位置上的加权因子 Wi: 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 （2）计算模 Y = mod(S, 11) （3）通过模得到对应的校验码 Y: 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2 功能：身份证的有效验证 网易笔试：一个合法的括号匹配 给一个合法的括号匹配序列s，找到同样长的所有的括号匹配序列t， 1.t和s不同，但是长度相同 2.t也合法 3.LCS（s,t） 是满足上面两个条件的t中最大的。 eg: s=”(())()” 匹配的有： “()(())”、”((()))”、”()()()”、”(()())” 其中 LCS（”(())()”,”()(())”）为4，其余都是5，所以输出3 package ProgrammingWritten; import java.util.ArrayList; import java.util.HashMap; import java.util.Map.Entry; import java.util.Scanner; /** * Created by zdmein on 2017/9/10. */ public class NetEase1 { public static int cnt; public static HashMap&lt;String,Integer> map = new HashMap&lt;>(); public static void main(String[] args) { HashMap&lt;Integer,Integer> map2 = new HashMap&lt;>(); Scanner input = new Scanner(System.in); String str1 = input.nextLine(); // int n = Integer.parseInt(str); int n2 = str1.length(); int n = (int) n2 / 2; // StringBuffer bf = new StringBuffer(\"\"); // String str1 = bf.append(str).reverse().toString(); // n += Integer.parseInt(str1); // System.out.println(n); ArrayList&lt;String> list = getBracketsOfN(n); for (String str2 : list) { if (str1.equals(str2)) { continue; }else { int[][] re = longestCommonSubsequence(str1, str2); cnt=0; print(re, str1, str2, str1.length(), str2.length()); map.put(str2, cnt); } } for (Entry&lt;String, Integer> entry : map.entrySet()) { if (map2.containsKey(entry.getValue())) { int count=map2.get(entry.getValue()); map2.put(entry.getValue(), ++count); } else { map2.put(entry.getValue(), 1); } } int result = 0; int max= 0; for(Entry&lt;Integer, Integer> entry : map2.entrySet()) { if (max&lt;entry.getKey()) { result = entry.getValue(); } } System.out.println(result); } /** * Given the number N, return all of the correct brackets. * * @param n * @return */ @SuppressWarnings(\"unchecked\") public static ArrayList&lt;String> getBracketsOfN(int n) { @SuppressWarnings(\"rawtypes\") ArrayList[] dp = new ArrayList[n + 1]; for (int i = 0; i &lt; dp.length; i++) dp[i] = new ArrayList&lt;String>(); dp[0].add(\"\"); dp[1].add(\"()\"); if (n == 0) return dp[0]; if (n == 1) return dp[1]; int count = 2; while (count &lt; n + 1) { ArrayList&lt;String> lcount = dp[count]; for (int i = 0; i &lt; count; i++) { ArrayList&lt;String> l1 = dp[i]; ArrayList&lt;String> l2 = dp[count - i - 1]; for (int j = 0; j &lt; l1.size(); j++) { for (int k = 0; k &lt; l2.size(); k++) { StringBuffer sb = new StringBuffer(); sb.append(l1.get(j)); sb.append(\"(\"); sb.append(l2.get(k)); sb.append(\")\"); lcount.add(sb.toString()); } } } dp[count++] = lcount; } return dp[n]; } // 假如返回两个字符串的最长公共子序列的长度 public static int[][] longestCommonSubsequence(String str1, String str2) { int[][] matrix = new int[str1.length() + 1][str2.length() + 1];//建立二维矩阵 // 初始化边界条件 for (int i = 0; i &lt;= str1.length(); i++) { matrix[i][0] = 0;//每行第一列置零 } for (int j = 0; j &lt;= str2.length(); j++) { matrix[0][j] = 0;//每列第一行置零 } // 填充矩阵 for (int i = 1; i &lt;= str1.length(); i++) { for (int j = 1; j &lt;= str2.length(); j++) { if (str1.charAt(i - 1) == str2.charAt(j - 1)) { matrix[i][j] = matrix[i - 1][j - 1] + 1; } else { matrix[i][j] = (matrix[i - 1][j] >= matrix[i][j - 1] ? matrix[i - 1][j] : matrix[i][j - 1]); } } } return matrix; } //根据矩阵输出LCS public static void print(int[][] opt, String X, String Y, int i, int j) { if (i == 0 || j == 0) { return; } if (X.charAt(i - 1) == Y.charAt(j - 1)) { print(opt, X, Y, i - 1, j - 1); cnt++; // System.out.print(X.charAt(i - 1)); } else if (opt[i - 1][j] >= opt[i][j]) { print(opt, X, Y, i - 1, j); } else { print(opt, X, Y, i, j - 1); } } } 滴滴笔试：求解第n个丑数我们把只包含因子2,3和5的数称为丑数（Ugly Number),求从小到大的顺序第n的丑数，例如6,8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当作第1个丑数 package ProgrammingWritten; import java.util.Scanner; /** * Created by zdmein on 2017/9/10. */ public class didi2 { public static void main(String args[]) { Scanner cin = new Scanner(System.in); int n = cin.nextInt(); System.out.println(getugly(n)); } public static int getugly(int n) { if(n==0) return 0; int[] a = new int[n]; int count = 1; a[0] = 1; int num2 = 0; int num3 = 0; int num5 = 0; while(count&lt;n){ int min = min(a[num2]*2,a[num3]*3,a[num5]*5); a[count] = min; while(a[num2]*2&lt;=a[count]) num2++; while(a[num3]*3&lt;=a[count]) num3++; while(a[num5]*5&lt;=a[count]) num5++; count++; } int result = a[n-1]; return result; } public static int min(int a,int b,int c){ int tmp = a>b?b:a; return tmp>c?c:tmp; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2017-04-03T02:17:35.000Z","updated":"2017-08-21T14:38:14.460Z","comments":true,"path":"2017/04/03/java-duo-xian-cheng/","link":"","permalink":"http://www.zhoudamin.com/2017/04/03/java-duo-xian-cheng/","excerpt":"","text":"基础创建线程：1.通过继承线程类Thread来创建线程类；2.建立一个实现Runnable接口的类来运行线程。 通过继承Thread创建一个子类，在主控程序中同时运行两个线程。 class Thread1{ public static void main(String args[]){ testThread t1 = new testThread(\"thread1\"); testThread t2 = new testThread(\"thread2\"); t1.start(); t2.start(); } } class testThread extends Thread{ public testThread(String str){ super(str); } public void run(){ for(int i=0;i&lt;3;i++){ System.out.println(getName()+\"在运行\")； try{ sleep(1000); }catch(InterruptedException e){} } System.out.println(getName()+\"已结束\")； } }线程的生命周期·创建（New Thread）·运行（Runnable）·挂起（Not Runnable）·结束（Dead） 以下三种情况会使线程转入Not Runnable状态1.调用sleep方法时，延时结束，重新转入Runnable状态；2.调用wait方法等待一个特定状态发生时，状态发生后，其他对象必须调用notify或notifyAll方法向等待中的线程发出通知，才能唤醒这个线程；3.当线程被I/O阻塞时，I/O完成后可唤醒线程。 售票系统之多线程买火车票是大家春节回家最为关注的事情，我们就简单模拟一下火车票的售票系统：有500张从广州到长沙的火车票，在8个窗口同时出售，保证系统的稳定性和数据的原子性。 show my code . class Service{ private String ticketName; private int totalCount; private int remaining; public Service(String ticketName , int totalCount){ this.ticketName=ticketName; this.totalCount=totalCount; this.remaining=totalCount; } public synchronized int saleTicket(int ticketNum){ if(remaining>0){ remaining-=ticketNum; try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } if(remaining>=0){ return remaining; }else{ remaining+=ticketNum; return -1; } } return -1; } public synchronized int getRemaining(){ return remaining; } public String getTicketName(){ return this.ticketName; } } class TicketSaler implements Runnable{ private String name; private Service service; public TicketSaler(String windowName , Service service){ this.name=windowName; this.service=service; } @Override public void run(){ while(service.getRemaining()>0){ synchronized (this){ System.out.println(Thread.currentThread().getName()+\"出售第\"+service.getRemaining()+\"张票，\"); int remaining =service.saleTicket(1); if(remaining>=0){ System.out.println(\"出票成功！剩余\"+remaining+\"张票。\"); }else { System.out.println(\"出票失败！ 该票已售完 。\"); } } } } } public class MyThreadTests{ public static void main(String [] args){ //testThread(); Service service=new Service(\"广州 --> 长沙\",500); TicketSaler ticketSaler=new TicketSaler(\"售票系统\" , service); Thread threads []=new Thread[8]; for(int i=0;i&lt;threads.length;i++){ threads[i]=new Thread(ticketSaler,\"窗口\"+(i+1)); System.out.println(\"窗口\"+(i+1)+\"开始出售\"+service.getTicketName()+\"的票...\"); threads[i].start(); } } } 部分结果： 窗口1开始出售广州 --> 长沙的票... 窗口2开始出售广州 --> 长沙的票... 窗口3开始出售广州 --> 长沙的票... 窗口4开始出售广州 --> 长沙的票... 窗口5开始出售广州 --> 长沙的票... 窗口6开始出售广州 --> 长沙的票... 窗口7开始出售广州 --> 长沙的票... 窗口8开始出售广州 --> 长沙的票... 窗口1出售第500张票， 出票成功！剩余499张票。 窗口3出售第499张票， 出票成功！剩余498张票。 窗口3出售第498张票， ...... 窗口7出售第0张票， 出票失败！ 该票已售完 。 窗口2出售第0张票， 出票失败！ 该票已售完 。 窗口1出售第0张票， 出票失败！ 该票已售完 。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://www.zhoudamin.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"JSP学习笔记","slug":"JSP学习笔记","date":"2017-04-02T02:03:23.000Z","updated":"2017-04-24T07:37:20.523Z","comments":true,"path":"2017/04/02/jsp-xue-xi-bi-ji/","link":"","permalink":"http://www.zhoudamin.com/2017/04/02/jsp-xue-xi-bi-ji/","excerpt":"JSP : Java Server Pages ,是一个简化的Servlet设计，实现了在Java中使用HTML标签。","text":"JSP : Java Server Pages ,是一个简化的Servlet设计，实现了在Java中使用HTML标签。 JSP基础语法：1.JSP指令·page指令：通常位于Jsp页面的顶端，同一个页面可以有多个page指令。·include指令：将一个外部文件嵌入到当前JSP文件中，同时解析这个页面中的JSP语句。·taglib指令：使用标签库定义新的自定义标签，在JSP页面中启动定制行为。 2.JSP注释·HTML的注释：&lt; !–heml注释–&gt; //客户端可见·JSP的注释：&lt;%–html注释–%&gt; //客户端不可见·JSP脚本注释：//单行注释/**/多行注释 3.JSP脚本&lt;%Java代码%&gt; 4.JSP声明在JSP页面中定义变量或者方法。&lt;%!JAVA代码%&gt;5.Java 表达式在JSP页面中执行的表达式。&lt;% =表达式 %&gt; //注意:表达式不以分号结束 6.JSP页面生命周期·用户发出请求index.jsp·是否是第一次请求—&gt;·是–&gt;JSP引擎把该JSP文件转换成为一个Servlet，生成字节码文件，并执行jspInit()–&gt;再访问生成的字节码文件·否–&gt;直接访问生成的字节码文件·解析执行，jspService() 当用户第一次请求一个jsp页面时，首先被执行的方法是构造方法。 JSP内置对象 1.内置对象简介 JSP内置对象是Web容器创建的一组对象，不使用new关键就可以使用的内置对象。 2.四种作用域范围 3.out 4.request 5.session 6.application 7.其他内置对象 缓冲区：Buffer 缓冲区就是内存的一块区域用来保存临时数据。 8.ContextConfig 的 init 方法将会主要完成以下工作：·创建用于解析 xml 配置文件的 contextDigester 对象·读取默认 context.xml 配置文件，如果存在解析它·读取默认 Host 配置文件，如果存在解析它·读取默认 Context 自身的配置文件，如果存在解析它·设置 Context 的 DocBase 9.ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：·创建读取资源文件的对象·创建 ClassLoader 对象·设置应用的工作目录·启动相关的辅助类如：logger、realm、resources 等·修改启动状态，通知感兴趣的观察者（Web 应用的配置）·子容器的初始化·获取 ServletContext 并设置必要的参数·初始化“load on startup”的 Servlet 10.与 Servlet 主动关联的是三个类，分别是 ServletConfig、ServletRequest 和 ServletResponse。这三个类都是通过容器传递给 Servlet 的，其中 ServletConfig 是在 Servlet 初始化时就传给 Servlet 了，而后两个是在请求达到时调用 Servlet 时传递过来的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"}],"tags":[{"name":"框架 JSP","slug":"框架-JSP","permalink":"http://www.zhoudamin.com/tags/%E6%A1%86%E6%9E%B6-JSP/"}]},{"title":"Spring 笔记","slug":"Spring-笔记","date":"2017-03-31T02:27:27.000Z","updated":"2018-04-25T03:37:24.614Z","comments":true,"path":"2017/03/31/spring-bi-ji/","link":"","permalink":"http://www.zhoudamin.com/2017/03/31/spring-bi-ji/","excerpt":"Spring 是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。","text":"Spring 是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 框架与类库的区别：-框架一般是封装了逻辑、搞内聚的，类库则是松散的工具组合；-框架专注于某一领域，类库则是更通用的。 接口实体把自己提供给外界的一种抽象化的说明；接口是对外的一种说明，说明了我会提供哪些功能，然后至于内部的实现，对外是不公开的；对应java接口即声明，声明了哪些方法是对外公开提供的； 接口：只能有声明，不能有实现 抽象类：既能有声明，也有实现 普通类：只能有完全的实现在Java8中，接口可以拥有方法体。 面向接口编程‘面向接口编程’中的’接口’是用于隐藏具体实现和实现多态性的组件。 什么是IOCIOC:控制反转，控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护DI（依赖注入）是其一种实现方式目的：创建对象并且组装对象之间的关系 IOC ·找IOC容器 ·容器返回对象 ·使用对象在Spring 中的bean应满足如下几个原则：（1）每个bean实现类都应提供无参数的构造器。（2）接受构造注入的bean，则应提供对应的构造函数。（3）接受设值注入的bean，则应提供对应的setter方法，并不强制要求提供对应的getter方法。 Bean 的作用域·singleton ： 单例，指一个Bean容器中只存在一份·prototype ： 每次请求（每次使用）创建新的实例，destroy方式不生效·request ： 每次http请求创建一个实例且仅在当前request内有效·session ： 同上，每次http请求创建，当前session内有效·global session：基于portlet的web中有效（portlet定义了global session ），如果是在web中，同session 关于bean初始化和销毁同时使用的注意情况：1，默认全局的初始化和销毁方法；2，实现接口的初始化和销毁方法；3，配置文件中配置初始化和销毁方法；这三个方法同时使用时，1默认的则不执行，而23两种都会执行，并且是2实现接口的方式先于配置中3的执行。1默认的全局初始化和销毁方法可以有可以没有，有没有对配置都没有太大影响，当然如果一个bean没有采取23初始化销毁方法，而有1默认的方法的话，这两个方法还是会执行的。即使没有，系统也不会报错。 学习关键点：1.依赖注入2.面向切面3.Spring MVC4.Spring对jdbc的支持 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring","slug":"Spring","permalink":"http://www.zhoudamin.com/categories/Spring/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"剑指Offer(11-20)","slug":"剑指Offer(11-20)","date":"2017-03-26T15:20:11.000Z","updated":"2017-07-03T03:22:15.915Z","comments":true,"path":"2017/03/26/jian-zhi-offer-11-20/","link":"","permalink":"http://www.zhoudamin.com/2017/03/26/jian-zhi-offer-11-20/","excerpt":"关于剑指Offer的一些解题思路","text":"关于剑指Offer的一些解题思路 题11：数值的整数次方实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 import java.util.Scanner; public class Main { public static void main(String[] args)throws Exception { Scanner sc=new Scanner(System.in); double n=sc.nextDouble(); int exp=sc.nextInt(); System.out.println(power(n,exp)); } public static double power(double base ,int exponent)throws Exception{ if(equal(base,0.0) &amp;&amp; exponent&lt;0){ throw new Exception(\"0的负次数幂无意义\"); // 1/0 没意义 } if(exponent&lt;0){ return 1.0/powerWithExponent(base,-exponent); }else { return powerWithExponent(base,exponent); } } public static double powerWithExponent(double base , int exponent){ if(base==0) return 1; if(exponent==1) return base; double res =1; for(int i=0;i&lt;exponent;i++){ res=res*base; } return res; } public static boolean equal(double base , double none){ if((base-none&gt;-0.0000001)&amp;&amp;base-none&lt;0.0000001){ //在0附近，误差0.0000001 return true; }else { return false; } } } # 题12：打印1到最大的n位数 输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3 一直到最大的3位数即999。 ``` &lt;br/&gt; # 题13： &lt;br/&gt; # 题14：调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位予数组的后半部分。public class Main { public static void main(String[] args)throws Exception { int[] array = {1, 4, 2, 5, 21, 67, 21, 66, 23, 77, 68}; for (int i = 0; i &lt; array.length; i++) { System.out.println(order(array)[i]); } } public static int [] order(int [] array){ if(array.length==0||array==null) return array; int start=0; int end=array.length-1; while (start&lt;end){ while (start&lt;end &amp;&amp; !isEven(array[start])){ start++; } while (start&lt;end&amp;&amp; isEven(array[end])){ end--; } if(start&lt;end){ int temp=array[start]; array[start]=array[end]; array[end]=temp; } } return array; } public static boolean isEven(int n){ return n%2==0; }} &lt;br/&gt; # 题15：链表中倒数第k个结点 题目：输入一个链表，输出该链表中倒数第k 个结点．为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾结点是倒数第 1 个结点．例如一个链表有 6 个结点，从头结点开始它们的值依次是 1 、2、3、4、5 、6。这个个链表的倒数第 3 个结点是值为 4 的结点。public class Main { public static void main(String[] args){ ListNode head=new ListNode(); ListNode second=new ListNode(); ListNode third= new ListNode(); ListNode forth=new ListNode(); head.next=second; second.next=third; third.next=forth; head.val=1; second.val=2; third.val=3; forth.val=4; System.out.println(findKToTail(head,3).val); } public static ListNode findKToTail(ListNode head , int k){ if (head==null&amp;&amp;k==0){ return null; } int count=0; ListNode resNode = new ListNode(); ListNode headNode=head; while (headNode!=null){ headNode=headNode.next; count++; } for(int i=0;i&lt;=count-k;i++){ head=head.next; } return head.next; } public static class ListNode{ int val; ListNode next; }} &lt;br/&gt; # 题16：反转链表 &lt;br/&gt; # 题17：合并两个排序的链表 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的 `递归的方法真是好用`public class Main { public static void main(String[] args){ ListNode head1=new ListNode(); ListNode second1=new ListNode(); ListNode third1= new ListNode(); ListNode forth1=new ListNode(); head1.next=second1; second1.next=third1; third1.next=forth1; head1.val=1; second1.val=5; third1.val=8; forth1.val=13; ListNode head2=new ListNode(); ListNode second2=new ListNode(); ListNode third2= new ListNode(); ListNode forth2=new ListNode(); head2.next=second2; second2.next=third2; third2.next=forth2; head2.val=2; second2.val=4; third2.val=7; forth2.val=9; ListNode resNode=mergeList(head1,head2); while (resNode!=null) { System.out.println(resNode.val); resNode = resNode.next; } } public static ListNode mergeList(ListNode head1 , ListNode head2){ if(head1==null){ return head2; } if(head2==null){ return head1; } ListNode mergeNode=null; if(head1.val&lt;head2.val){ mergeNode=head1; mergeNode.next=mergeList(head1.next,head2); }else { mergeNode=head2; mergeNode.next=mergeList(head1,head2.next); } return mergeNode; } public static class ListNode{ int val; ListNode next; }} &lt;br/&gt; # 题18：树的子结构 &lt;br/&gt; # 题19：二叉树的镜像 题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述: 二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } }*/public class Solution { public void Mirror(TreeNode root) { if(root==null ) return ; TreeNode temp; temp=root.left; root.left=root.right; root.right=temp; Mirror(root.left); Mirror(root.right); }} &lt;br/&gt; # 题20：顺时针打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.import java.util.ArrayList;public class Solution { public ArrayList printMatrix(int [][] matrix) { if (matrix == null) return null; ArrayList result = new ArrayList(); int start = 0; while(matrix[0].length &gt; start *2 &amp;&amp; matrix.length &gt; start *2){ printMatrixInCircle(matrix,result,start); start++; } return result; } public static void printMatrixInCircle(int [][]matix,ArrayList&lt;Integer&gt;result,int start){ int endX = matix[0].length - start -1; int endY = matix.length - start -1; //从左向右打印一行 for(int i = start;i &lt;=endX;i++){ result.add(matix[start][i]); } //从上到下 for(int i = start+1; i &lt;=endY;i++) result.add(matix[i][endX]); //从右到左 if(start &lt; endX &amp;&amp;start &lt; endY) for(int i = endX -1;i&gt;= start;i--) result.add(matix[endY][i]); //从下到上 if(start &lt; endX &amp;&amp; start &lt; endY-1) for(int i = endY - 1;i &gt;=start+1;i--) result.add(matix[i][start]); } } ``` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.zhoudamin.com/tags/%E5%89%91%E6%8C%87Offer/"}]},{"title":"网易笔试","slug":"网易笔试","date":"2017-03-26T12:32:34.000Z","updated":"2017-03-26T12:52:16.772Z","comments":true,"path":"2017/03/26/wang-yi-bi-shi/","link":"","permalink":"http://www.zhoudamin.com/2017/03/26/wang-yi-bi-shi/","excerpt":"网易2017年校招","text":"网易2017年校招 java1.下厨房每组输入多行，每行有多种食材，求每组共多少食材，用hashtable不添加重复的特性解决。 import java.util.Hashtable; import java.util.Scanner; public class 下厨房{ public static void main(String [] args){ Scanner sc=new Scanner(System.in); Hashtable&lt;String,Integer&gt; set = new Hashtable&lt;String .Integer&gt;(); while(sc.hasNext()){ String str = sc.next(); set.put(str,1); } System.out.println(set.size()); } }注：在Iterator类中，我们经常用到两个方法：hasNext(),next()。具体含义：next(),是返回当前元素，并指向下一个元素。 hasNext(),是判断当前元素是否存在，并指向下一个元素（即索引）。 Java代码实现 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"网易","slug":"网易","permalink":"http://www.zhoudamin.com/tags/%E7%BD%91%E6%98%93/"}]},{"title":"MySQL学习笔记","slug":"MySQL学习笔记","date":"2017-03-16T13:40:15.000Z","updated":"2017-10-07T04:25:01.358Z","comments":true,"path":"2017/03/16/mysql-xue-xi-bi-ji/","link":"","permalink":"http://www.zhoudamin.com/2017/03/16/mysql-xue-xi-bi-ji/","excerpt":"关于MySQL学习过程中的一些总结！","text":"关于MySQL学习过程中的一些总结！ 基础知识MySQL默认的端口号是3306；MySQL中的超级用户叫 root；创建数据库： create database ；修改数据库： alter database ；删除数据库： drop database ； 登陆MySQL客户端 : mysql -uroot -p16213018 -P3306 -h127.0.0.1 查看数据库 ： SHOW DATABASES； 打开test数据库 : USE test ; 创建数据表： CREATE TABLE tb1( username VARCHAR(20), age TINYINT UNSIGNED, salary FLOAT(8,2) UNSIGNED ); 查看数据表： SHOW TABLES ； 查看数据表结构： SHOW COLUMNS FROM tb1 ; 插入记录： INSERT tb1 VALUES(‘Tom’,25,6843.34); 记录查找： SELECT * FROM tb1;空值与非空：CREATE TABLE(20) tb2(username VARCHAR(20) NOT NULL,age TINYINT UNSIGNED NULL); 查表： SHOW COLUMNS tb2; 事务事务是数据库中一个单独的执行单元（Unit） 事务必须满足4个属性： 原子性：事务必须被完整执行 一致性：执行前和执行后，数据库数据必须保持一致的状态 隔离性：也称为独立性，当两个或多个事务并发执行时，为了保证数据的安全性，将事务隔离，不被其他正在进行的事务看到 持久性：永久性，事务完成后，对数据库的更改是永久的 创建用户表以及问题表如果存在则先删除再创建 DROP TABLE IF EXISTS `question`; CREATE TABLE `question` ( `id` INT NOT NULL AUTO_INCREMENT, `title` VARCHAR(255) NOT NULL, `content` TEXT NULL, `user_id` INT NOT NULL, `created_date` DATETIME NOT NULL, `comment_count` INT NOT NULL, PRIMARY KEY (`id`), INDEX `date_index` (`created_date` ASC)); DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` INT(11) UNSIGNED NOT NULL AUTO_INCREMENT, `name` VARCHAR(64) NOT NULL DEFAULT ‘’, `password` VARCHAR(128) NOT NULL DEFAULT ‘’ , ‘salt’ VARCHAR(32) NOT NULL DEFAULT ‘’ , ‘head_url’ VARCHAR(256) NOT NULL DEFAULT ‘’ , PRIMARY KEY (`id`) UNIQUE KEY ‘name’ (‘name’) ) ENGINE=INNODB DEFAULT CHARSET=utf8 查询表格SELECT * FROM question; 删除数据库cache DROP DATABASE CACHE; 创建数据库cacheCREATE DATABASE CACHE; // 创建一个数据库 创建表格CREATE TABLE SYS_ROLE( ID INTEGER, NAME VARCHAR(255) NOT NULL ); CREATE TABLE SYS_ROLE_USER( SYS_USER_ID INTEGER, ROLES_ID INTEGER ); INSERT INTO SYS_ROLE(id,NAME) VALUES(1,'ROLE_ADMIN'); INSERT INTO SYS_ROLE(id,NAME) VALUES(2,'ROLE_USER'); INSERT INTO SYS_ROLE_USER(SYS_USER_ID,ROLES_ID) VALUES(1,1); INSERT INTO SYS_ROLE_USER(SYS_USER_ID,ROLES_ID) VALUES(2,2); DROP TABLE IF EXISTS `city`; CREATE TABLE `city` ( `id` INT(10) UNSIGNED NOT NULL , `province_id` INT(10) UNSIGNED NOT NULL , `city_name` VARCHAR(25) DEFAULT NULL , `description` VARCHAR(25) DEFAULT NULL , PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; INSERT INTO city(id,province_id,city_name,description) VALUES(2 ,2,'长沙','我家在长沙'); CREATE DATABASE Persion; CREATE TABLE `persion` ( `id` INT(10) UNSIGNED NOT NULL , `persion_id` INT(10) UNSIGNED NOT NULL , `persion_name` VARCHAR(25) DEFAULT NULL , `description` VARCHAR(25) DEFAULT NULL , PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 实验楼学习笔记开发准备# 打开 MySQL 服务 sudo service mysql start #使用 root 用户登录，密码为空 mysql -u root 新建数据库CREATE DATABASE mysql_shiyan; CREATE DATABASE name1; create database name2; CREATE database name3; create DAtabaSE name4; 连接数据库use mysql_shiyan 新建数据表CREATE TABLE employee (id int(10),name char(20),phone int(12)); 插入数据INSERT INTO employee(id,name,phone) VALUES(01,'Tom',110110110); INSERT INTO employee VALUES(02,'Jack',119119119); INSERT INTO employee(id,name) VALUES(03,'Rose'); 主键create table abc ( id int(10) primary key, name char(20) ); 对数据库修改SHOW DATABASES; DROP DATABASE test_01; ALTER TABLE 表名字 DROP COLUMN 列名字; 索引ALTER TABLE employee ADD INDEX idx_id (id); #在employee表的id列上建立名为idx_id的索引 CREATE INDEX idx_name ON employee (name); #在employee表的name列上建立名为idx_name的索引 show index from employee; 视图CREATE VIEW v_emp(v_name,v_age,v_phone) AS SELECT name,age,phone FROM employee; select * from v_emp; 操作命令mysql> SELECT VERSION(), CURRENT_DATE; //查时间 mysql> SELECT SIN(PI()/4), (4+1)*5; //计算 mysql> SELECT VERSION(); SELECT NOW(); //现在的时间 MySQL操作mysql> SHOW DATABASES; mysql> CREATE DATABASE test; mysql> USE test //创建表 mysql> CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20), -> species VARCHAR(20), sex CHAR(1), birth DATE, death DATE); mysql> SHOW TABLES; //描述 mysql> DESCRIBE pet; //装载文本到表中 mysql> LOAD DATA INFILE '/home/shiyanlou/Desktop/pet.txt' INTO TABLE pet; //检索表 mysql> SELECT * FROM pet; //选择特点行 mysql> SELECT * FROM pet WHERE name = 'Bowser'; //选择条件 mysql> SELECT * FROM pet WHERE birth > '1998-1-1'; //选择特殊列 mysql> SELECT name, birth FROM pet; //选择行与列 mysql> SELECT name, species, birth FROM pet -> WHERE species = 'dog' OR species = 'cat'; //计算行数 mysql> SELECT COUNT(*) FROM pet; MySQL笔试的4个问题问题来源 问题1：如何删除mysql表中的重复数据，只保留一条记录？先添加唯一性字段，若有则直接删除 ALTER TABLE city1 ADD id int default 0; alter table city1 modify id int auto_increment primary key delete from city2 where id not in( select * from (select min(id) from city2 group by name having count (name)>1 ) as a ) 问题2：找出表中的出现次数最多的某条记录（或某个字段）SELECT sid ,count (sid) FROM city2 group by sid order by count(sid) DESC limit 1 问题3：用一条SQL语句查询出grade表中每门课都大于80分的学生姓名name course score 张三 语文 81 张三 数学 75 李四 语文 76 李四 数学 90 王五 语文 81 王五 数学 100 王五 英语 90 ------ select name from grade group by name having min(分数)>80 问题4：将表city1中num_person字段根据人数进行重新编码要求:0&lt;=x&lt;500,000编码为1500,000&lt;=x&lt;1,000,000编码为21,000,000&lt;=x编码为3 select name, case when num_persion >=0 and num_persion =500000 and num_persion =1000000 then 3 end as mark from city1 运算符案例mysql -h localhost -u root -p16213018 mysql> CREATE DATABASE db1; mysql> use db1; mysql> CREATE TABLE tmp ( note VARCHAR(100),price INT); mysql> INSERT INTO tmp VALUES (\"this is good\" , 50); mysql> SELECT price ,price +10,price-10,price*2,price /2,price %2 FROM tmp; +-------+-----------+----------+---------+----------+----------+ | price | price +10 | price-10 | price*2 | price /2 | price %2 | +-------+-----------+----------+---------+----------+----------+ | 50 | 60 | 40 | 100 | 25.0000 | 0 | +-------+-----------+----------+---------+----------+----------+ mysql> SELECT price ,price BETWEEN 30 AND 80 , GREATEST(price ,70,30),price IN(20,50,35) , price IN(10,20,35) FROM tmp; +-------+-------------------------+------------------------+-----------------------+--------------------+ | price | price BETWEEN 30 AND 80 | GREATEST(price ,70,30) | price IN(20,50,35) | price IN(10,20,35) | +-------+-------------------------+------------------------+-----------------------+--------------------+ | 50 | 1 | 70 | 1 | 0 | +-------+-------------------------+------------------------+-----------------------+--------------------+ mysql> SELECT price ,price&2 ,price|4 ,~price FROM tmp; +-------+---------+---------+----------------------+ | price | price&2 | price|4 | ~price | +-------+---------+---------+----------------------+ | 50 | 2 | 54 | 18446744073709551565 | +-------+---------+---------+----------------------+ 查找数据 GROUP BY 和 ORDER BY-- 建表 show databases; use db1; create table orderitems ( o_num int not null, o_item int not null , f_id char(10) NOT NULL, quantity int NOT NULL, item_price decimal(8,2) NOT NULL, PRIMARY KEY (o_num , o_item) ); -- 插入数据 Insert into orderitems (o_num,o_item , f_id , quantity , item_price) values (30001,1,'a1',10,5.2), (30001,2,'b2',3,7.6), (30001,3,'bs1',5,11.2), (30001,4,'bs2',15,9.2), (30002,1,'b3',2,20.0), (30003,1,'c0',100,10), (30004,1,'o2',50,2.50), (30005,1,'c0',5,10), (30005,2,'b1',10,8.99), (30005,3,'a2',10,2.2), (30005,4,'m1',10,14.99); -- 查看下表 select * from orderitems; -- 查找订单价格大于100的订单号和总订单价格 select o_num ,sum(quantity*item_price) AS orderTotal -- 选列 FROM orderitems -- 目标表 group by o_num -- 按订单号对数据进行分组 having sum(quantity*item_price)>=100; -- 条件语句 -- 用ORDER BY 显示返回 select o_num ,sum(quantity*item_price) AS orderTotal -- 选列 FROM orderitems -- 目标表 group by o_num -- 按订单号对数据进行分组 having sum(quantity*item_price)>=100 -- 条件语句 order by orderTotal ; -- 排序输出 select * from orderitems limit 4; -- 查询结果的前4行 select * from orderitems limit 4,3; -- 查询结果的第4个结果开始的(不包括第4个),3行记录 -- 查询表中的总行数 select count(*) AS order_num from orderitems; -- 查询o_num 的价格的平均值 select o_num , avg(item_price) as avg_price from orderitems group by o_num; -- 查询o_num=30001 的价格的平均值 select o_num , avg(item_price) as avg_price from orderitems where o_num=30001; -- 查询价格最高的 select max(item_price) as max_price from orderitems; -- 查询价格最低的 select o_num , min(item_price) as min_price from orderitems; -- 查询各个供应商提供的价格最低的 select o_num , min(item_price) as min_price from orderitems group by o_num; 记录的插入、删除、更新-- 创建表 create table books ( id int(11) NOT NUll primary key , name varchar(50) not null , authors varchar(100) not null , price float not null , pubdate year not null , note varchar(100) not null , num int(11) not null default 0 ); select * from books; -- 插入行 insert into books (id , name , authors ,price , pubdate , note ,num) values (1,'Table of AAA' ,'Dickes',23,'1995','novel',111) ; -- 插入行 方式二 insert into books values (2,'Emmat' ,'Jane lura',35,'1993','joke',22); select * from books; ----------------------------------------------------------------------------- id name authors price pubdate note num 1 Table of AAA Dickes 23 1995 novel 111 2 Emmat Jane lura 35 1993 joke 22 ------------------------------------------------------------------------------ insert into books values (3,'Story of Jane' ,'Jane Tim',40,'2001','novel',0), (4,'Lovey Day' ,'cswd',20,'2005','novel',30), (5,'Old Land' ,'dsfre',30,'2010','law',0), (6,'The battle' ,'safs',33,'1999','medicine',40), (7,'Rose Hood' ,'Richard Kale',28,'2008','cartoon',28); select * from books; ----------------------------------------------------------------------- id name authors price pubdate note num 1 Table of AAA Dickes 23 1995 novel 111 2 Emmat Jane lura 35 1993 joke 22 3 Story of Jane Jane Tim 40 2001 novel 0 4 Lovey Day cswd 20 2005 novel 30 5 Old Land dsfre 30 2010 law 0 6 The battle safs 33 1999 medicine 40 7 Rose Hood Richard Kale 28 2008 cartoon 28 ------------------------------------------------------------------------- UPDATE books SET price =price +5 WHERE note='novel'; select id ,name,price , note from books where note = 'novel'; ---------------------------------------------------------------- id name price note 1 Table of AAA 28 novel 3 Story of Jane 45 novel 4 Lovey Day 25 novel ----------------------------------------------------------------- -- 更改价格方法二 直接改 UPDATE books set price=40 ,note ='joke' where name = 'emmat'; select id ,name,price , note from books where note = 'joke'; --------------------------------------------------------- id name price note 2 Emmat 40 joke ---------------------------------------------------------- -- 条件删除行 delete from books where num=0; select * from books; -------------------------------------------------------- id name authors price pubdate note num 1 Table of AAA Dickes 28 1995 novel 111 2 Emmat Jane lura 40 1993 joke 22 4 Lovey Day cswd 25 2005 novel 30 6 The battle safs 33 1999 medicine 40 7 Rose Hood Richard Kale 28 2008 cartoon 28 ------------------------------------------------------------- document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.zhoudamin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.zhoudamin.com/tags/MySQL/"}]},{"title":"麻省理工：算法导论-分治法--上课笔记","slug":"麻省理工：算法导论-上课笔记","date":"2017-03-14T12:35:35.000Z","updated":"2017-03-16T04:24:18.058Z","comments":true,"path":"2017/03/14/ma-sheng-li-gong-suan-fa-dao-lun-shang-ke-bi-ji/","link":"","permalink":"http://www.zhoudamin.com/2017/03/14/ma-sheng-li-gong-suan-fa-dao-lun-shang-ke-bi-ji/","excerpt":"学习麻省理工算法导论的笔记。","text":"学习麻省理工算法导论的笔记。 分治：步骤：1、分2、治 3、合并 实例：一、归并排序：1、将排序数组一分为二2、将两个子数组排序3、合并两个有序子数组 二、二分查找：在一个有序数组中查找x1、先将x和有序数组中间的数比较2、再将x和左或右子数组的中间的数比较3、done 三、乘方问题：求x的n次方1、分解 x^n= x^(n/2)*x^(n/2) n为偶 x^((n-1)/2)*x^((n-1)/2)*x n为奇 ``` 2、先求两边乘(子算法规模为n/2)，再乘一起 算法时间为O(lg n) 四、斐波那契数列问题：{ 0 ; n=0Fn= | 1 ; n=1 { F(n-1)+F(n-2) 这是个指数级问题，然而可以用朴素平方递归来降低到O(lg n){ F2 F1 } = ( 1 1 ){ F1 F0 } ( 1 0 ) { Fn+1 Fn } = { Fn Fn-1 }( 1 1 ) = ( 1 1 )^n-1 * ( 1 1 ) =( 1 1 )^n{ Fn Fn-1 } { Fn-1 Fn-2 }( 1 0 ) ( 1 0 ) ( 1 0 ) ( 1 0 ) ``` $\\LaTeX$ _ss This expression $\\sqrt{3x-1}+(1+x)^2$ is an example of a $\\LaTeX$ inline equation. he Lorenz Equations: $$\\begin{aligned}\\dot{x} &amp; = \\sigma(y-x) \\\\dot{y} &amp; = \\rho x - y - xz \\\\dot{z} &amp; = -\\beta z + xy\\end{aligned}$$ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"公开课","slug":"公开课","permalink":"http://www.zhoudamin.com/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"}]},{"title":"快速排序","slug":"快速排序","date":"2017-03-12T09:06:27.000Z","updated":"2017-09-28T07:02:29.414Z","comments":true,"path":"2017/03/12/kuai-su-pai-xu/","link":"","permalink":"http://www.zhoudamin.com/2017/03/12/kuai-su-pai-xu/","excerpt":"选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。","text":"选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。 Java代码实现 package Sort; import java.util.Arrays; /** * Created by zdmein on 2017/9/27. * 快排 */ public class quickSort1 { public static void main(String[] args) { int[] testData = {49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; int[] dataSorted = quickSort(testData, 0, testData.length-1); for(int a : dataSorted) { System.out.print(a + \" \"); } } /** * 快速排序 */ private static int partition(int[] data, int low, int high) { int key = data[low]; while(low &lt; high) { while(low&lt;high &amp;&amp; data[high]>=key) { high--; } data[low] = data[high];//(此时因low=high或data[high]&lt;key)将high下标处的数赋给low下标处的数，保证data[low]&lt;key while(low&lt;high &amp;&amp; data[low]&lt;=key) { low++; } data[high] = data[low];//(此时因low=high或data[low]>key)将low下标处的数赋给high下标处的数，保证data[high]>key } data[low] = key; return low; } public static int[] quickSort(int[] data, int low, int high) { if(low &lt; high) { int result = partition(data, low, high); quickSort(data, low, result-1);//对low到result-1下标间数进行排序 quickSort(data, result+1, high);//对result+1到high下标间数进行排序 } return data; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.zhoudamin.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2017-03-12T03:31:43.000Z","updated":"2017-03-12T03:34:37.469Z","comments":true,"path":"2017/03/12/mou-pao-pai-xu/","link":"","permalink":"http://www.zhoudamin.com/2017/03/12/mou-pao-pai-xu/","excerpt":"自下往上对相邻的两个数进行比较和调整Key：大的数往下沉，小的数往上浮","text":"自下往上对相邻的两个数进行比较和调整Key：大的数往下沉，小的数往上浮 Java实现 package algorithms4th; public class BubbleSort { public static void main(String [] args){ int a []={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; for(int j=0;j&lt;a.length-1;j++){ for(int i=a.length-1;i&gt;j;i--){ if(a[i]&lt;a[i-1]){ int temp=a[i]; a[i]=a[i-1]; a[i-1]=temp; } } } for(int i=0;i&lt;a.length;i++){ System.out.print(a[i]+\" \"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.zhoudamin.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2017-03-12T02:48:27.000Z","updated":"2017-03-12T02:50:14.809Z","comments":true,"path":"2017/03/12/xi-er-pai-xu/","link":"","permalink":"http://www.zhoudamin.com/2017/03/12/xi-er-pai-xu/","excerpt":"基本思想：算法先要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。","text":"基本思想：算法先要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。 Math.ceil()是常见编程语言中的常用代码,ceil() 方法执行的是向上取整计算，它返回的是大于或等于函数参数，并且与之最接近的整数。 Java代码实现 package algorithms4th; public class ShellSort { public static void main (String []args){ int a []={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; int temp=0; double d1=a.length; while(true){ d1=Math.ceil(d1/3); int d=(int)d1; for(int x=0;x&lt;d;x++){ for(int j=(int) (x+d);j&lt;a.length;j+=d){ int i=(int) (j-d); if(a[i]&gt;a[j]){ temp=a[j]; a[j]=a[i]; a[i]=temp; } } } if(d==1){ break; } } for(int i=0;i&lt;a.length;i++){ System.out.print(a[i]+\" \"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.zhoudamin.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"简单直接排序","slug":"简单直接排序","date":"2017-03-12T02:38:57.000Z","updated":"2017-03-12T02:41:40.933Z","comments":true,"path":"2017/03/12/jian-dan-zhi-jie-pai-xu/","link":"","permalink":"http://www.zhoudamin.com/2017/03/12/jian-dan-zhi-jie-pai-xu/","excerpt":"基本思想：每个数与第一个数相比，选最小的放第一个；然后从第二个数开始，每个数与第二个数相比，选最小的放第二；……","text":"基本思想：每个数与第一个数相比，选最小的放第一个；然后从第二个数开始，每个数与第二个数相比，选最小的放第二；…… Java代码实现 package algorithms4th; public class SelectSort { public static void main(String [] args){ int a []={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; for (int i=0;i&lt;a.length;i++){ for(int j=i+1;j&lt;a.length;j++){ if(a[j]&lt;a[i]){ int temp=a[j]; a[j]=a[i]; a[i]=temp; } } } for(int i=0;i&lt;a.length;i++){ System.out.print(a[i]+\" \"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.zhoudamin.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"直接插入排序","slug":"直接插入排序","date":"2017-03-08T13:47:48.000Z","updated":"2017-03-11T13:53:51.122Z","comments":true,"path":"2017/03/08/zhi-jie-cha-ru-pai-xu/","link":"","permalink":"http://www.zhoudamin.com/2017/03/08/zhi-jie-cha-ru-pai-xu/","excerpt":"基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。","text":"基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。 Java代码实现 package algorithms4th; public class InsertSort { public static void main (String [] args){ int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51}; int temp=0; for(int i=1;i&lt;a.length;i++){ for(int j=i-1;j&gt;0;j--){ if(a[j]&lt;a[j-1]){ temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; } } } for(int i=0;i&lt;a.length;i++){ System.out.print(a[i]+\" \"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.zhoudamin.com/tags/%E6%8E%92%E5%BA%8F/"}]}],"categories":[{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"},{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"观点与感想","slug":"观点与感想","permalink":"http://www.zhoudamin.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"},{"name":"Linux","slug":"Linux","permalink":"http://www.zhoudamin.com/categories/Linux/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.zhoudamin.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"编程语言","slug":"开发者手册/编程语言","permalink":"http://www.zhoudamin.com/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"理解计算机","slug":"理解计算机","permalink":"http://www.zhoudamin.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"云计算","slug":"云计算","permalink":"http://www.zhoudamin.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Notes","slug":"Notes","permalink":"http://www.zhoudamin.com/categories/Notes/"},{"name":"图像","slug":"图像","permalink":"http://www.zhoudamin.com/categories/%E5%9B%BE%E5%83%8F/"},{"name":"Life","slug":"Life","permalink":"http://www.zhoudamin.com/categories/Life/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.zhoudamin.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/categories/Java/"},{"name":"面经","slug":"面经","permalink":"http://www.zhoudamin.com/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"读书","slug":"读书","permalink":"http://www.zhoudamin.com/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"框架","slug":"框架","permalink":"http://www.zhoudamin.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.zhoudamin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"二维码","slug":"二维码","permalink":"http://www.zhoudamin.com/categories/%E4%BA%8C%E7%BB%B4%E7%A0%81/"},{"name":"防伪","slug":"防伪","permalink":"http://www.zhoudamin.com/categories/%E9%98%B2%E4%BC%AA/"},{"name":"Spring","slug":"Spring","permalink":"http://www.zhoudamin.com/categories/Spring/"},{"name":"数据库","slug":"数据库","permalink":"http://www.zhoudamin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"应用开发","slug":"应用开发","permalink":"http://www.zhoudamin.com/tags/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"findbugs","slug":"findbugs","permalink":"http://www.zhoudamin.com/tags/findbugs/"},{"name":"总结","slug":"总结","permalink":"http://www.zhoudamin.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.zhoudamin.com/tags/leetcode/"},{"name":"Apollo","slug":"Apollo","permalink":"http://www.zhoudamin.com/tags/Apollo/"},{"name":"算法","slug":"算法","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"http://www.zhoudamin.com/tags/Java/"},{"name":"工作","slug":"工作","permalink":"http://www.zhoudamin.com/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"随想","slug":"随想","permalink":"http://www.zhoudamin.com/tags/%E9%9A%8F%E6%83%B3/"},{"name":"AI","slug":"AI","permalink":"http://www.zhoudamin.com/tags/AI/"},{"name":"Linux","slug":"Linux","permalink":"http://www.zhoudamin.com/tags/Linux/"},{"name":"算法与数学","slug":"算法与数学","permalink":"http://www.zhoudamin.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/"},{"name":"观点与感想","slug":"观点与感想","permalink":"http://www.zhoudamin.com/tags/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"},{"name":"Notes","slug":"Notes","permalink":"http://www.zhoudamin.com/tags/Notes/"},{"name":"并发","slug":"并发","permalink":"http://www.zhoudamin.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Java 二维码","slug":"Java-二维码","permalink":"http://www.zhoudamin.com/tags/Java-%E4%BA%8C%E7%BB%B4%E7%A0%81/"},{"name":"HTTP","slug":"HTTP","permalink":"http://www.zhoudamin.com/tags/HTTP/"},{"name":"云计算","slug":"云计算","permalink":"http://www.zhoudamin.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.zhoudamin.com/tags/Hexo/"},{"name":"博主","slug":"博主","permalink":"http://www.zhoudamin.com/tags/%E5%8D%9A%E4%B8%BB/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.zhoudamin.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"源码","slug":"源码","permalink":"http://www.zhoudamin.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"基础","slug":"基础","permalink":"http://www.zhoudamin.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"笔试","slug":"笔试","permalink":"http://www.zhoudamin.com/tags/%E7%AC%94%E8%AF%95/"},{"name":"腾讯","slug":"腾讯","permalink":"http://www.zhoudamin.com/tags/%E8%85%BE%E8%AE%AF/"},{"name":"操作系统","slug":"操作系统","permalink":"http://www.zhoudamin.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://www.zhoudamin.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"开发者手册","slug":"开发者手册","permalink":"http://www.zhoudamin.com/tags/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.zhoudamin.com/tags/SpringBoot/"},{"name":"书籍","slug":"书籍","permalink":"http://www.zhoudamin.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"Java程序员面试笔试宝典","slug":"Java程序员面试笔试宝典","permalink":"http://www.zhoudamin.com/tags/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E5%AE%9D%E5%85%B8/"},{"name":"绘图","slug":"绘图","permalink":"http://www.zhoudamin.com/tags/%E7%BB%98%E5%9B%BE/"},{"name":"贪心","slug":"贪心","permalink":"http://www.zhoudamin.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"面试","slug":"面试","permalink":"http://www.zhoudamin.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"阿里","slug":"阿里","permalink":"http://www.zhoudamin.com/tags/%E9%98%BF%E9%87%8C/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.zhoudamin.com/tags/%E5%89%91%E6%8C%87Offer/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.zhoudamin.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.zhoudamin.com/tags/LeetCode/"},{"name":"JS","slug":"JS","permalink":"http://www.zhoudamin.com/tags/JS/"},{"name":"二维码","slug":"二维码","permalink":"http://www.zhoudamin.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"},{"name":"二维码防伪","slug":"二维码防伪","permalink":"http://www.zhoudamin.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%98%B2%E4%BC%AA/"},{"name":"链表","slug":"链表","permalink":"http://www.zhoudamin.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"笔记","slug":"笔记","permalink":"http://www.zhoudamin.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"多线程","slug":"多线程","permalink":"http://www.zhoudamin.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"框架 JSP","slug":"框架-JSP","permalink":"http://www.zhoudamin.com/tags/%E6%A1%86%E6%9E%B6-JSP/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.zhoudamin.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"网易","slug":"网易","permalink":"http://www.zhoudamin.com/tags/%E7%BD%91%E6%98%93/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.zhoudamin.com/tags/MySQL/"},{"name":"公开课","slug":"公开课","permalink":"http://www.zhoudamin.com/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"排序","slug":"排序","permalink":"http://www.zhoudamin.com/tags/%E6%8E%92%E5%BA%8F/"}]}